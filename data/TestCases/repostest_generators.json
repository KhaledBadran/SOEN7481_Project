{
    "functionName": "test_generators",
    "className": "TestFeatureGeneration",
    "fileName": "/SUNCAT-Center_&_CatLearn/test_&_test_1_feature_generation.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "\"\"\"Generate features from atoms objects.\"\"\"\nget_mendeleev_params(atomic_number=78)\nget_mendeleev_params(atomic_number=[78, 79], params=default_params + [\n    'en_ghosh'])\ngadb = DataConnection('{}/data/gadb.db'.format(wkdir))\nprint('Getting candidates from the database')\nall_cand = gadb.get_all_relaxed_candidates(use_extinct=False)\ntestset = get_unique(atoms=all_cand, size=test_size, key='raw_score')\nself.assertTrue(len(testset['atoms']) == test_size)\nself.assertTrue(len(testset['taken']) == test_size)\ntrainset = get_train(atoms=all_cand, size=train_size, taken=testset['taken'\n    ], key='raw_score')\nself.assertTrue(len(trainset['atoms']) == train_size)\nself.assertTrue(len(trainset['target']) == train_size)\nprint('Getting the fingerprints')\nf = FeatureGenerator(element_parameters='atomic_radius', nprocs=1)\nf.normalize_features(trainset['atoms'], testset['atoms'])\ndata = f.return_vec(trainset['atoms'], [f.nearestneighbour_vec])\nn, d = np.shape(data)\nself.assertTrue(n == train_size and d == 4)\nself.assertTrue(len(f.return_names([f.nearestneighbour_vec])) == d)\nprint('passed nearestneighbour_vec')\ntrain_fp = f.return_vec(trainset['atoms'], [f.bond_count_vec])\nn, d = np.shape(train_fp)\ndata = np.concatenate((data, train_fp), axis=1)\nself.assertTrue(n == train_size and d == 52)\nprint('passed bond_count_vec')\ntrain_fp = f.return_vec(trainset['atoms'], [f.distribution_vec])\nn, d = np.shape(train_fp)\ndata = np.concatenate((data, train_fp), axis=1)\nself.assertTrue(n == train_size and d == 10)\nprint('passed distribution_vec')\ntrain_fp = f.return_vec(testset['atoms'], [f.connections_vec])\nn, d = np.shape(train_fp)\nself.assertTrue(n == test_size and d == 26)\nprint('passed connections_vec')\ntrain_fp = f.return_vec(trainset['atoms'], [f.rdf_vec])\nn, d = np.shape(train_fp)\ndata = np.concatenate((data, train_fp), axis=1)\nself.assertTrue(n == train_size and d == 20)\nprint('passed rdf_vec')\ntrain_fp = f.return_vec(trainset['atoms'], [f.element_mass_vec])\nn, d = np.shape(train_fp)\ndata = np.concatenate((data, train_fp), axis=1)\nself.assertTrue(n == train_size and d == 1)\nself.assertTrue(len(f.return_names([f.element_mass_vec])) == d)\nprint('passed element_mass_vec')\ntrain_fp = f.return_vec(trainset['atoms'], [f.element_parameter_vec])\nn, d = np.shape(train_fp)\ndata = np.concatenate((data, train_fp), axis=1)\nself.assertTrue(n == train_size and d == 4)\nself.assertTrue(len(f.return_names([f.element_parameter_vec])) == d)\nprint('passed element_parameter_vec')\ntrain_fp = f.return_vec(trainset['atoms'], [f.composition_vec])\nn, d = np.shape(train_fp)\ndata = np.concatenate((data, train_fp), axis=1)\nself.assertTrue(n == train_size and d == 2)\nself.assertTrue(len(f.return_names([f.composition_vec])) == d)\nprint('passed composition_vec')\ntrain_fp = f.return_vec(trainset['atoms'], [f.eigenspectrum_vec])\nn, d = np.shape(train_fp)\ndata = np.concatenate((data, train_fp), axis=1)\nself.assertTrue(n == train_size and d == 147)\nself.assertTrue(len(f.return_names([f.eigenspectrum_vec])) == d)\nprint('passed eigenspectrum_vec')\ntrain_fp = f.return_vec(trainset['atoms'], [f.distance_vec])\nn, d = np.shape(train_fp)\ndata = np.concatenate((data, train_fp), axis=1)\nself.assertTrue(n == train_size and d == 2)\nself.assertTrue(len(f.return_names([f.distance_vec])) == d)\nprint('passed distance_vec')\ntrain_fp = f.return_vec(trainset['atoms'], [f.eigenspectrum_vec, f.\n    element_mass_vec, f.composition_vec])\nn, d = np.shape(train_fp)\nself.assertTrue(n == train_size and d == 150)\nself.assertTrue(len(f.return_names([f.eigenspectrum_vec, f.element_mass_vec,\n    f.composition_vec])) == d)\nprint('passed combined generation')\ntrain_fp = f.return_vec(trainset['atoms'], [f.neighbor_sum_vec])\nn, d = np.shape(train_fp)\nself.assertTrue(n == train_size and d == len(trainset['atoms'][0]))\nprint('passed neighbor_sum_vec')\ntrain_fp = f.return_vec(trainset['atoms'], [f.neighbor_mean_vec])\nn, d = np.shape(train_fp)\nself.assertTrue(n == train_size and d == len(trainset['atoms'][0]))\nprint('passed neighbor_mean_vec')\nf = FeatureGenerator(element_parameters='atomic_radius', max_neighbors=\n    'full', nprocs=1)\nf.normalize_features(trainset['atoms'], testset['atoms'])\ntrain_fp = f.return_vec(trainset['atoms'], [f.neighbor_sum_vec])\nn, d = np.shape(train_fp)\nself.assertTrue(n == train_size and d == len(trainset['atoms'][0]))\nprint('passed neighbor_sum_vec all neighbors')\ntrain_fp = f.return_vec(trainset['atoms'], [f.neighbor_mean_vec])\nn, d = np.shape(train_fp)\nself.assertTrue(n == train_size and d == len(trainset['atoms'][0]))\nprint('passed neighbor_mean_vec all neighbors')\nno_prop = []\nan_prop = []\nfor atoms in testset['atoms']:\n    no_prop.append(neighbor_features(atoms=atoms))\n    an_prop.append(neighbor_features(atoms=atoms, property=['atomic_number']))\nself.assertTrue(np.shape(no_prop) == (test_size, 15))\nself.assertTrue(np.shape(an_prop) == (test_size, 30))\nprint('passed graph_vec')\nself.__class__.all_cand = all_cand\nself.__class__.data = data\n"
}
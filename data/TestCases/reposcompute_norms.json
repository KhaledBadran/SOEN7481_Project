{
    "functionName": "compute_norms",
    "className": null,
    "fileName": "/Lasagne_&_Lasagne/lasagne_&_utils.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\" Compute incoming weight vector norms.\n\n    Parameters\n    ----------\n    array : numpy array or Theano expression\n        Weight or bias.\n    norm_axes : sequence (list or tuple)\n        The axes over which to compute the norm.  This overrides the\n        default norm axes defined for the number of dimensions\n        in `array`. When this is not specified and `array` is a 2D array,\n        this is set to `(0,)`. If `array` is a 3D, 4D or 5D array, it is\n        set to a tuple listing all axes but axis 0. The former default is\n        useful for working with dense layers, the latter is useful for 1D,\n        2D and 3D convolutional layers.\n        Finally, in case `array` is a vector, `norm_axes` is set to an empty\n        tuple, and this function will simply return the absolute value for\n        each element. This is useful when the function is applied to all\n        parameters of the network, including the bias, without distinction.\n        (Optional)\n\n    Returns\n    -------\n    norms : 1D array or Theano vector (1D)\n        1D array or Theano vector of incoming weight/bias vector norms.\n\n    Examples\n    --------\n    >>> array = np.random.randn(100, 200)\n    >>> norms = compute_norms(array)\n    >>> norms.shape\n    (200,)\n\n    >>> norms = compute_norms(array, norm_axes=(1,))\n    >>> norms.shape\n    (100,)\n    \"\"\"\nif not isinstance(array, theano.Variable) and not isinstance(array, np.ndarray\n    ):\n    raise RuntimeError(\n        'Unsupported type {}. Only theano variables and numpy arrays are supported'\n        .format(type(array)))\nndim = array.ndim\nif norm_axes is not None:\n    sum_over = tuple(norm_axes)\nelif ndim == 1:\n    sum_over = ()\nelif ndim == 2:\n    sum_over = 0,\nelif ndim in [3, 4, 5]:\n    sum_over = tuple(range(1, ndim))\nelse:\n    raise ValueError(\n        'Unsupported tensor dimensionality {}. Must specify `norm_axes`'.\n        format(array.ndim))\nif isinstance(array, theano.Variable):\n    if len(sum_over) == 0:\n        norms = T.abs_(array)\n    else:\n        norms = T.sqrt(T.sum(array ** 2, axis=sum_over))\nelif isinstance(array, np.ndarray):\n    if len(sum_over) == 0:\n        norms = abs(array)\n    else:\n        norms = np.sqrt(np.sum(array ** 2, axis=sum_over))\nreturn norms\n"
}
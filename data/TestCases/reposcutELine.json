{
    "functionName": "cutELine",
    "className": "DataSet",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Perform cut along energy in steps between two Q Point \n        \n        Args:\n\n            - Q1 (3D or 2D vector): Starting point for energy cut.\n\n            - Q2 (3D or 2D vector): End of energy cut\n            \n\n        Kwargs: \n\n            - Emin (float): Start energy (default is self.Energy.min() for data in cut).\n            \n            - Emax (float): End energy (default is self.Energy.max() for data in cut).\n\n            - energyWidth (float): Height of energy bins (default 0.05 meV)\n\n            - minPixel (float): Minimal size of binning along the cutting direction. Points will be binned if they are closer than minPixel (default 0.1).\n\n            - width (float): Full width of cut in q-plane (default 0.02).\n\n            - rlu (bool): If True, provided Q point is interpreted as (h,k,l) otherwise as (qx,qy), (Default true)\n            \n            - dataFiles (list): Data files to be used. If none provided use the ones in self (default None)\n\n            - constantBins (bool): If True only bins of size minPixel is used (default False)\n            \n        Returns:\n            \n            - Data (pandas DataFrame): DataFrame containing qx,qy,H,K,L,Intensity,Normalization,Monitor,BinCount,Int,binDistance for 1D cut.\n            \n            - Bin (1 array): Bin edge positions in energy\n\n        \"\"\"\nif dataFiles is None:\n    if len(self.convertedFiles) == 0:\n        raise AttributeError(\n            'No data file to be binned provided in either input or DataSet object.'\n            )\n    else:\n        I = self.I.extractData()\n        qx = self.qx.extractData()\n        qy = self.qy.extractData()\n        energy = self.energy.extractData()\n        Norm = self.Norm.extractData()\n        Monitor = self.Monitor.extractData()\n        samples = self.sample\n        maskIndices = self.maskIndices\n        DS = self\nelse:\n    DS = DataSet(convertedFiles=dataFiles)\n    I, qx, qy, energy, Norm, Monitor, samples, maskIndices = DS.I.extractData(\n        ), DS.qx.extractData(), DS.qy.extractData(), DS.energy.extractData(\n        ), DS.Norm.extractData(), DS.Monitor.extractData(\n        ), DS.sample, DS.maskIndices\nQ1 = np.asarray(Q1, dtype=float)\nQ2 = np.asarray(Q2, dtype=float)\ndirvec = Q2 - Q1\noriginalMask = DS.mask\nQ1re = Q1.copy().reshape(-1, 1, 1)\nif rlu:\n    normal = DS.sample[0].planeNormal\n    normal *= 1.0 / np.linalg.norm(normal)\n    perp = np.cross(dirvec, normal) / np.linalg.norm(dirvec)\n    mask = [np.array([np.logical_or(np.abs(np.einsum('i...,i->...', A -\n        Q1re, dirvec) - 0.5) > 0.5, np.abs(np.einsum('i...,i->...', A -\n        Q1re, perp)) > width) for A in zip(d.h, d.k, d.l)]) for d in DS]\nelse:\n    perp = dirvec[[1, 0]]\n    mask = [np.array([np.logical_or(np.abs(np.einsum('i...,i->...', A -\n        Q1re, dirvec) - 0.5) > 0.5, np.abs(np.einsum('i...,i->...', A -\n        Q1re, perp)) > width) for A in zip(d.qx, d.qy)]) for d in DS]\nDS.mask = [np.logical_or(mNew, mOld) for mNew, mOld in zip(mask, self.mask)]\npoints = np.linalg.norm(dirvec) / minPixel\nif Emin is None:\n    Emin = DS.energy.min()\nif Emax is None:\n    Emax = DS.energy.max()\nQPoints = np.array([(Q1 + dirvec * x) for x in np.linspace(0.0, 1.0, int(np\n    .floor(points)))])\nif rlu == True:\n    rotationMatrices = [np.dot(samples[0].RotMat.T, s.RotMat) for s in samples]\n    Q = [[QX, QY] for QX, QY in zip(np.split(qx, maskIndices), np.split(qy,\n        maskIndices))]\n    qx, qy = np.concatenate([np.einsum('ij,j...->i...', rot, q) for rot, q in\n        zip(rotationMatrices, Q)], axis=1)\n    positions = np.array([qx, qy, energy])\n    Qs = np.array([DS.convertToQxQy(q) for q in QPoints])\nelse:\n    positions = np.array([qx, qy, energy])\n    Qs = QPoints\nData = []\nBins = []\nfor i, Q in enumerate(Qs):\n    Q = Q.flatten()\n    [intensity, MonitorCount, Normalization, normcounts], bins = cut1DE(\n        positions=positions, I=I, Norm=Norm, Monitor=Monitor, E1=Emin, E2=\n        Emax, q=Q, width=width, minPixel=energyWidth, constantBins=constantBins\n        )\n    data = pd.DataFrame()\n    HKL = self.convertToHKL(Q.flatten())\n    data['Qx'] = Q[0] * np.ones_like(intensity)\n    data['Qy'] = Q[1] * np.ones_like(intensity)\n    data['H'] = HKL[0] * np.ones_like(intensity)\n    data['K'] = HKL[1] * np.ones_like(intensity)\n    data['L'] = HKL[2] * np.ones_like(intensity)\n    data['Energy'] = 0.5 * (bins[0][1:] + bins[0][:-1])\n    data['Intensity'] = intensity.astype(int)\n    data['Monitor'] = MonitorCount.astype(int)\n    data['Normalization'] = Normalization.astype(int)\n    data['BinCount'] = normcounts.astype(int)\n    data['QCut'] = i * np.ones_like(intensity).astype(int)\n    data['Int'] = data['Intensity'] * data['BinCount'] / (data[\n        'Normalization'] * data['Monitor'])\n    Data.append(data)\n    Bins.append(bins)\nData = pd.concat(Data)\nDS.mask = originalMask\nreturn Data, Bins\n"
}
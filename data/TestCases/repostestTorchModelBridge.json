{
    "functionName": "testTorchModelBridge",
    "className": "TorchModelBridgeTest",
    "fileName": "/facebook_&_Ax/ax_&_modelbridge_&_tests_&_test_torch_modelbridge.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "torch_dtype = torch.float64\ntorch_device = torch.device('cpu')\nma = TorchModelBridge(experiment=None, search_space=None, data=None, model=\n    None, transforms=[], torch_dtype=torch.float64, torch_device=torch.\n    device('cpu'))\nself.assertEqual(ma.dtype, torch.float64)\nself.assertEqual(ma.device, torch.device('cpu'))\nself.assertFalse(mock_init.call_args[-1]['fit_out_of_design'])\nmodel = mock.MagicMock(TorchModel, autospec=True, instance=True)\nX = np.array([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0]])\nY = np.array([[3.0], [4.0]])\nvar = np.array([[1.0], [2.0]])\nma._model_fit(model=model, Xs=[X], Ys=[Y], Yvars=[var], bounds=None,\n    feature_names=[], metric_names=[], task_features=[], fidelity_features=\n    [], candidate_metadata=[])\nmodel_fit_args = model.fit.mock_calls[0][2]\nself.assertTrue(torch.equal(model_fit_args['Xs'][0], torch.tensor(X, dtype=\n    torch_dtype, device=torch_device)))\nself.assertTrue(torch.equal(model_fit_args['Ys'][0], torch.tensor(Y, dtype=\n    torch_dtype, device=torch_device)))\nself.assertTrue(torch.equal(model_fit_args['Yvars'][0], torch.tensor(var,\n    dtype=torch_dtype, device=torch_device)))\nma._model_update(Xs=[X], Ys=[Y], Yvars=[var], candidate_metadata=[])\nmodel_update_args = model.update.mock_calls[0][2]\nself.assertTrue(torch.equal(model_update_args['Xs'][0], torch.tensor(X,\n    dtype=torch_dtype, device=torch_device)))\nself.assertTrue(torch.equal(model_update_args['Ys'][0], torch.tensor(Y,\n    dtype=torch_dtype, device=torch_device)))\nself.assertTrue(torch.equal(model_update_args['Yvars'][0], torch.tensor(var,\n    dtype=torch_dtype, device=torch_device)))\nmodel.predict.return_value = torch.tensor([3.0]), torch.tensor([4.0])\nf, var = ma._model_predict(X)\nself.assertTrue(torch.equal(model.predict.mock_calls[0][2]['X'], torch.\n    tensor(X, dtype=torch_dtype, device=torch_device)))\nself.assertTrue(np.array_equal(f, np.array([3.0])))\nself.assertTrue(np.array_equal(var, np.array([4.0])))\nmodel.gen.return_value = torch.tensor([1.0, 2.0, 3.0]), torch.tensor([1.0]), {\n    }, []\nX, w, _gen_metadata, _candidate_metadata = ma._model_gen(n=3, bounds=[(0, 1\n    )], objective_weights=np.array([1.0, 0.0]), outcome_constraints=None,\n    linear_constraints=None, fixed_features={(1): 3.0},\n    pending_observations=[np.array([]), np.array([1.0, 2.0, 3.0])],\n    model_gen_options={'option': 'yes'}, rounding_func=np.round,\n    target_fidelities=None)\ngen_args = model.gen.mock_calls[0][2]\nself.assertEqual(gen_args['n'], 3)\nself.assertEqual(gen_args['bounds'], [(0, 1)])\nself.assertTrue(torch.equal(gen_args['objective_weights'], torch.tensor([\n    1.0, 0.0], dtype=torch_dtype, device=torch_device)))\nself.assertIsNone(gen_args['outcome_constraints'])\nself.assertIsNone(gen_args['linear_constraints'])\nself.assertEqual(gen_args['fixed_features'], {(1): 3.0})\nself.assertTrue(torch.equal(gen_args['pending_observations'][0], torch.\n    tensor([], dtype=torch_dtype, device=torch_device)))\nself.assertTrue(torch.equal(gen_args['pending_observations'][1], torch.\n    tensor([1.0, 2.0, 3.0], dtype=torch_dtype, device=torch_device)))\nself.assertEqual(gen_args['model_gen_options'], {'option': 'yes'})\nself.assertIsNone(gen_args['target_fidelities'])\nt = torch.tensor([0.1, 0.6], dtype=torch_dtype, device=torch_device)\nself.assertTrue(torch.equal(gen_args['rounding_func'](t), torch.round(t)))\nself.assertTrue(np.array_equal(X, np.array([1.0, 2.0, 3.0])))\nself.assertTrue(np.array_equal(w, np.array([1.0])))\nmodel.cross_validate.return_value = torch.tensor([3.0]), torch.tensor([4.0])\nf, var = ma._model_cross_validate(Xs_train=[X], Ys_train=[Y], Yvars_train=[\n    var], X_test=X)\nmodel_cv_args = model.cross_validate.mock_calls[0][2]\nself.assertTrue(torch.equal(model_cv_args['Xs_train'][0], torch.tensor(X,\n    dtype=torch_dtype, device=torch_device)))\nself.assertTrue(torch.equal(model_cv_args['Ys_train'][0], torch.tensor(Y,\n    dtype=torch_dtype, device=torch_device)))\nself.assertTrue(torch.equal(model_cv_args['Yvars_train'][0], torch.tensor(\n    var, dtype=torch_dtype, device=torch_device)))\nself.assertTrue(torch.equal(model_cv_args['X_test'], torch.tensor(X, dtype=\n    torch_dtype, device=torch_device)))\nself.assertTrue(np.array_equal(f, np.array([3.0])))\nself.assertTrue(np.array_equal(var, np.array([4.0])))\nobsf = [ObservationFeatures(parameters={'x': 1.0, 'y': 2.0})]\nma.parameters = ['x', 'y']\nX = ma._transform_observation_features(obsf)\nself.assertTrue(torch.equal(X, torch.tensor([[1.0, 2.0]], dtype=torch_dtype,\n    device=torch_device)))\nma = TorchModelBridge(experiment=None, search_space=None, data=None, model=\n    None, transforms=[], torch_dtype=torch.float64, torch_device=torch.\n    device('cpu'), fit_out_of_design=True)\nself.assertTrue(mock_init.call_args[-1]['fit_out_of_design'])\nmock.patch('ax.modelbridge.array.ArrayModelBridge.__init__', autospec=True,\n    return_value=None)"
}
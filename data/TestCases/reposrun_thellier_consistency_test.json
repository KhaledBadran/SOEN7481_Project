{
    "functionName": "run_thellier_consistency_test",
    "className": null,
    "fileName": "/PmagPy_&_PmagPy/dialogs_&_thellier_consistency_test.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "\"\"\"\n\n    \"\"\"\ndef find_sample_min_std(Intensities):\n\n    def find_close_value(LIST, value):\n        diff = inf\n        for a in LIST:\n            if abs(value - a) < diff:\n                diff = abs(value - a)\n                result = a\n        return result\n    Best_array = []\n    best_array_std = inf\n    Best_array_tmp = []\n    Best_interpretations = {}\n    Best_interpretations_tmp = {}\n    for this_specimen in list(Intensities.keys()):\n        for value in Intensities[this_specimen]:\n            Best_interpretations_tmp[this_specimen] = value\n            Best_array_tmp = [value]\n            all_other_specimens = list(Intensities.keys())\n            all_other_specimens.remove(this_specimen)\n            for other_specimen in all_other_specimens:\n                closest_value = find_close_value(Intensities[other_specimen\n                    ], value)\n                Best_array_tmp.append(closest_value)\n                Best_interpretations_tmp[other_specimen] = closest_value\n            if std(Best_array_tmp, ddof=1) < best_array_std:\n                Best_array = Best_array_tmp\n                best_array_std = std(Best_array, ddof=1)\n                Best_interpretations = copy.deepcopy(Best_interpretations_tmp)\n                Best_interpretations_tmp = {}\n    return Best_interpretations, mean(Best_array), std(Best_array, ddof=1)\ndef find_sample_min_max_interpretation(Intensities, acceptance_criteria):\n    tmp_Intensities = {}\n    Acceptable_sample_min, Acceptable_sample_max = '', ''\n    for this_specimen in list(Intensities.keys()):\n        B_list = copy.deepcopy(Intensities[this_specimen])\n        if len(B_list) > 0:\n            B_list.sort()\n            tmp_Intensities[this_specimen] = B_list\n    while len(list(tmp_Intensities.keys())) >= float(acceptance_criteria[\n        'sample_int_n']):\n        B_tmp = []\n        B_tmp_min = 10000000000.0\n        for sample in list(tmp_Intensities.keys()):\n            B_tmp.append(min(tmp_Intensities[sample]))\n            if min(tmp_Intensities[sample]) < B_tmp_min:\n                sample_to_remove = sample\n                B_tmp_min = min(tmp_Intensities[sample])\n        if std(B_tmp, ddof=1) <= acceptance_criteria['sample_int_sigma_uT'\n            ] or 100 * (std(B_tmp, ddof=1) / mean(B_tmp)\n            ) <= acceptance_criteria['sample_int_sigma_perc']:\n            Acceptable_sample_min = mean(B_tmp)\n            break\n        else:\n            tmp_Intensities[sample_to_remove].remove(B_tmp_min)\n            if len(tmp_Intensities[sample_to_remove]) == 0:\n                break\n    tmp_Intensities = {}\n    for this_specimen in list(Intensities.keys()):\n        B_list = copy.deepcopy(Intensities[this_specimen])\n        if len(B_list) > 0:\n            B_list.sort()\n            tmp_Intensities[this_specimen] = B_list\n    counter = 0\n    while len(list(tmp_Intensities.keys())) >= float(acceptance_criteria[\n        'sample_int_n']):\n        counter += 1\n        B_tmp = []\n        B_tmp_max = 0\n        for sample in list(tmp_Intensities.keys()):\n            B_tmp.append(max(tmp_Intensities[sample]))\n            if max(tmp_Intensities[sample]) > B_tmp_max:\n                sample_to_remove = sample\n                B_tmp_max = max(tmp_Intensities[sample])\n        if std(B_tmp, ddof=1) < acceptance_criteria['sample_int_sigma_uT'\n            ] or 100 * (std(B_tmp, ddof=1) / mean(B_tmp)\n            ) < acceptance_criteria['sample_int_sigma_perc']:\n            Acceptable_sample_max = mean(B_tmp)\n            break\n        else:\n            tmp_Intensities[sample_to_remove].remove(B_tmp_max)\n            if len(tmp_Intensities[sample_to_remove]) < 1:\n                break\n    if Acceptable_sample_min == '' or Acceptable_sample_max == '':\n        return 0.0, 0.0\n    return Acceptable_sample_min, Acceptable_sample_max\nlogfile = open(WD + '/consistency_test/consistency_test_optimizer.log', 'w')\nstart_time = time.time()\naccept_new_parameters = {}\ncriteria_sample_list = ['sample_int_n', 'sample_int_sigma_uT',\n    'sample_int_sigma_perc', 'sample_int_interval_uT',\n    'sample_int_interval_perc']\ncriteria_specimen_list = preferences['show_statistics_on_gui']\nthellier_optimizer_master_file = gzip.open(WD +\n    '/consistency_test/consistency_test_log.txt.gz', 'wb')\nString = 'er_specimen_name\\t' + 't_min\\t' + 't_max_\\t' + 'specimen_int_uT\\t'\nfor crit in criteria_specimen_list:\n    String = String + 'specimen_' + crit + '\\t'\nString = String[:-1] + '\\n'\nthellier_optimizer_master_file.write(String.encode('utf-8'))\nString = ''\nOptimizer_results_file = open(WD +\n    '/consistency_test/consistency_test_results.txt', 'w')\nString = (\n    \"\"\"%s\t%s\tTest_Site\tSamples\tB_samples\tTest Site Mean\tTest Site STD\tTest Site [STD/Mean]\n\"\"\"\n     % (stat1_range[0], stat2_range[0]))\nOptimizer_results_file.write(String)\noptimization_functions = []\nfin = open(WD + '/' + optimizer_functions_path, 'r')\nfor line in fin.readlines():\n    optimization_functions.append(line.strip('\\n'))\nsites_samples = {}\nsamples_expected_intensity = {}\nfin = open(optimizer_group_file_path, 'r')\nline = fin.readline()\nline = fin.readline()\nheader = line.strip('\\n').split('\\t')\nfor line in fin.readlines():\n    tmp_data = {}\n    line = line.strip('\\n').split('\\t')\n    for i in range(len(line)):\n        tmp_data[header[i]] = line[i]\n    sample = tmp_data['er_sample_name']\n    site = tmp_data['er_group_name']\n    if 'comments' in list(tmp_data.keys()) and 'exclude' in tmp_data['comments'\n        ]:\n        logfile.write('-W- WARNING: ignoring sample %s\\n' % sample)\n        continue\n    if 'sample_int' in list(tmp_data.keys()) and tmp_data['sample_int'] != '':\n        try:\n            samples_expected_intensity[sample] = float(tmp_data['sample_int']\n                ) * 1000000.0\n        except:\n            pass\n    if site not in list(sites_samples.keys()):\n        sites_samples[site] = []\n    if sample not in sites_samples[site]:\n        sites_samples[site].append(sample)\nlogfile.write('-I- Now looping through all data points in the Arai plot\\n')\nthellier_optimizer_master_table = {}\nn_min = int(acceptance_criteria['specimen_int_n']['value'])\nspecimens = list(Data.keys())\nspecimens.sort()\nif stat1_range[0] == 'specimen_b_beta':\n    beta_range = stat1_range[1]\nelif stat2_range[0] == 'specimen_b_beta':\n    beta_range = stat2_range[1]\nelif acceptance_criteria['specimen_b_beta']['value'] != -999:\n    beta_range = [acceptance_criteria['specimen_b_beta']['value']]\nelse:\n    beta_range = ['']\nfor s in specimens:\n    thellier_optimizer_master_table[s] = {}\n    t_Arai = Data[s]['t_Arai']\n    if len(t_Arai) < 4:\n        logfile.write('-W- skipping specimen %s. few datapints. \\n' % s)\n        continue\n    for start in range(0, len(t_Arai) - n_min + 1):\n        for end in range(start + n_min - 1, len(t_Arai)):\n            tmin = t_Arai[start]\n            tmax = t_Arai[end]\n            for beta in beta_range:\n                tmp_acceptance_criteria = copy.deepcopy(acceptance_criteria)\n                pars = thellier_gui_lib.get_PI_parameters(Data,\n                    tmp_acceptance_criteria, preferences, s, tmin, tmax,\n                    logfile, THERMAL, MICROWAVE)\n                thellier_optimizer_master_table[s][tmin, tmax, beta] = pars\ntemp = 'Done loopping through all points in Arai plot. All specimens\\n'\nthellier_optimizer_master_file.write(temp.encode('utf-8'))\ntime_1 = time.time()\nruntime_sec = time_1 - start_time\nm, s = divmod(runtime_sec, 60)\nh, m = divmod(m, 60)\ntemp = '-I- runtime from start (hh:mm:ss)' + '%d:%02d:%02ds\\n' % (h, m, s)\nthellier_optimizer_master_file.write(temp.encode('utf-8'))\nOptimizer_data = {}\nOptimizer_STDEV_OPT = {}\nfor stat1_value in stat1_range[1]:\n    for stat2_value in stat2_range[1]:\n        tmp_acceptance_criteria = copy.deepcopy(acceptance_criteria)\n        tmp_acceptance_criteria[stat1_range[0]]['value'] = stat1_value\n        tmp_acceptance_criteria[stat2_range[0]]['value'] = stat2_value\n        Key = '%s,%s' % (str(stat1_value), str(stat2_value))\n        Optimizer_data[Key] = {}\n        for sample in list(Data_hierarchy['samples'].keys()):\n            for specimen in Data_hierarchy['samples'][sample]:\n                if specimen not in specimens:\n                    continue\n                for t1_t2_beta in thellier_optimizer_master_table[specimen]:\n                    if t1_t2_beta[2] != '':\n                        if float(t1_t2_beta[2]) != float(\n                            tmp_acceptance_criteria['specimen_b_beta']['value']\n                            ):\n                            continue\n                    pars = thellier_optimizer_master_table[specimen][t1_t2_beta\n                        ]\n                    pars = thellier_gui_lib.check_specimen_PI_criteria(pars,\n                        tmp_acceptance_criteria)\n                    if pars['specimen_fail_criteria'] == []:\n                        Fail = False\n                    else:\n                        temp = (\n                            'key=%s - specimen %s, tmin,tmax =(%.0f,%.0f) fail on %s\\n'\n                             % (Key, specimen, float(pars[\n                            'measurement_step_min']) - 273, float(pars[\n                            'measurement_step_max']) - 273, ','.join(pars[\n                            'specimen_fail_criteria'])))\n                        thellier_optimizer_master_file.write(temp.encode(\n                            'utf-8'))\n                        Fail = True\n                    if Fail:\n                        continue\n                    if sample not in list(Optimizer_data[Key].keys()):\n                        Optimizer_data[Key][sample] = {}\n                    if specimen not in list(Optimizer_data[Key][sample].keys()\n                        ):\n                        Optimizer_data[Key][sample][specimen] = []\n                    Optimizer_data[Key][sample][specimen].append(pars)\n                    temp = (\n                        '-I- key= %s specimen %s pass tmin,tmax= (%.0f,%.0f)\\n'\n                         % (Key, specimen, float(pars[\n                        'measurement_step_min']) - 273, float(pars[\n                        'measurement_step_max']) - 273))\n                    thellier_optimizer_master_file.write(temp.encode('utf-8'))\nlogfile.write(\n    '-I- Loop now through statistic #1 and statistic #2 and find the best means\\n'\n    )\nfor stat1_value in stat1_range[1]:\n    for stat2_value in stat2_range[1]:\n        Key = '%s,%s' % (str(stat1_value), str(stat2_value))\n        temp = '-I- calulating best sample means, %s' % Key\n        thellier_optimizer_master_file.write(temp.encode('utf-8'))\n        B_specimens = {}\n        All_grade_A_Recs = {}\n        for sample in list(Optimizer_data[Key].keys()):\n            B_specimens[sample] = {}\n            for specimen in list(Optimizer_data[Key][sample].keys()):\n                if specimen not in list(B_specimens.keys()):\n                    B_specimens[sample][specimen] = []\n                if specimen not in list(All_grade_A_Recs.keys()):\n                    All_grade_A_Recs[specimen] = {}\n                for pars in Optimizer_data[Key][sample][specimen]:\n                    B_specimens[sample][specimen].append(pars[\n                        'specimen_int_uT'])\n                    TEMP = '%.0f,%.0f' % (float(pars['measurement_step_min'\n                        ]) - 273, float(pars['measurement_step_max']) - 273)\n                    new_pars = {}\n                    for k in list(pars.keys()):\n                        new_pars[k] = pars[k]\n                    All_grade_A_Recs[specimen][TEMP] = pars\n                B_specimens[sample][specimen].sort()\n            if len(list(B_specimens[sample].keys())) < 2:\n                continue\n            thellier_auto_interpreter = (thellier_interpreter.\n                thellier_auto_interpreter(Data, Data_hierarchy, WD,\n                acceptance_criteria, preferences, logfile, THERMAL, MICROWAVE))\n            thellier_auto_interpreter.thellier_interpreter_log = logfile\n            thellier_auto_interpreter.calc_upper_level_mean(B_specimens,\n                All_grade_A_Recs, sample)\n            thellier_interpreter_pars = (thellier_auto_interpreter.\n                thellier_interpreter_pars)\n            interpreter_mean = thellier_interpreter_pars['stdev-opt']['B']\n            interpreter_std = thellier_interpreter_pars['stdev-opt']['std']\n            interpreter_interval = thellier_interpreter_pars[\n                'sample_int_interval_uT']\n            if thellier_interpreter_pars['pass_or_fail'] == 'fail':\n                temp = '-I- sample/site fail on %s' % ','.join(\n                    thellier_interpreter_pars['fail_criteria'])\n                thellier_optimizer_master_file.write(temp.encode('utf-8'))\n            if thellier_interpreter_pars['pass_or_fail'] == 'pass':\n                temp = (\n                    '-I- sample/site %s pass. B=%.2f, STD=%.2f, interval=%.2f'\n                     % (sample, interpreter_mean, interpreter_std,\n                    interpreter_interval))\n                thellier_optimizer_master_file.write(temp.encode('utf-8'))\n            if Key not in list(Optimizer_STDEV_OPT.keys()):\n                Optimizer_STDEV_OPT[Key] = {}\n            if sample not in Optimizer_STDEV_OPT[Key]:\n                Optimizer_STDEV_OPT[Key][sample] = {}\n            Optimizer_STDEV_OPT[Key][sample]['sample_int_uT'\n                ] = thellier_interpreter_pars['stdev-opt']['B']\n            Optimizer_STDEV_OPT[Key][sample]['sample_int_sigma_uT'\n                ] = thellier_interpreter_pars['stdev-opt']['std']\n            Optimizer_STDEV_OPT[Key][sample]['sample_int_sigma_perc'\n                ] = thellier_interpreter_pars['stdev-opt']['std_perc']\n            Optimizer_STDEV_OPT[Key][sample]['sample_int_interval_uT'\n                ] = thellier_interpreter_pars['sample_int_interval_uT']\n            Optimizer_STDEV_OPT[Key][sample]['sample_int_interavl_perc'\n                ] = thellier_interpreter_pars['sample_int_interval_perc']\noptimization_functions_matrices = {}\nfor function in optimization_functions:\n    optimization_functions_matrices[function] = zeros((len(stat1_range[1]),\n        len(stat2_range[1])))\nstat1_index = 0\nfor stat1_value in stat1_range[1]:\n    stat2_index = 0\n    for stat2_value in stat2_range[1]:\n        Key = '%s,%s' % (str(stat1_value), str(stat2_value))\n        study_sample_n = len(list(Optimizer_STDEV_OPT[Key].keys()))\n        tmp = list(Optimizer_STDEV_OPT[Key].keys())\n        tmp.sort()\n        max_group_int_sigma_uT = 0\n        max_group_int_sigma_perc = 0\n        test_group_n = 0\n        for site in sites_samples:\n            site_B = []\n            site_samples_id = []\n            for sample in sites_samples[site]:\n                if sample in list(Optimizer_STDEV_OPT[Key].keys()):\n                    site_B.append(Optimizer_STDEV_OPT[Key][sample][\n                        'sample_int_uT'])\n                    site_samples_id.append(sample)\n            site_B = array(site_B)\n            if len(site_B) > 1:\n                test_group_n += 1\n                if std(site_B, ddof=1) > max_group_int_sigma_uT:\n                    max_group_int_sigma_uT = std(site_B, ddof=1)\n                if 100 * (std(site_B, ddof=1) / mean(site_B)\n                    ) > max_group_int_sigma_perc:\n                    max_group_int_sigma_perc = 100 * (std(site_B, ddof=1) /\n                        mean(site_B))\n            String = '%.2f\\t%.2f\\t%s\\t' % (stat1_value, stat2_value, site)\n            for sample_id in site_samples_id:\n                String = String + sample_id + ':'\n            String = String[:-1] + '\\t'\n            for B in site_B:\n                String = String + '%.1f' % B + ':'\n            String = String[:-1] + '\\t'\n            String = String + '%.2f' % mean(site_B) + '\\t'\n            String = String + '%.2f' % std(site_B, ddof=1) + '\\t'\n            String = String + '%.2f' % (100 * (std(site_B, ddof=1) / mean(\n                site_B))) + '\\t'\n            Optimizer_results_file.write(String[:-1] + '\\n')\n        max_sample_accuracy_uT = 0.0\n        for sample in list(samples_expected_intensity.keys()):\n            if sample in list(Optimizer_STDEV_OPT[Key].keys()):\n                if 'sample_int_uT_diff_from_expected_uT' in list(\n                    Optimizer_STDEV_OPT[Key][sample].keys()):\n                    max_sample_accuracy_uT = max(max_sample_accuracy_uT,\n                        Optimizer_STDEV_OPT[Key][sample][\n                        'sample_int_uT_diff_from_expected_uT'])\n        max_sample_accuracy_perc = 0.0\n        for sample in list(samples_expected_intensity.keys()):\n            if sample in list(Optimizer_STDEV_OPT[Key].keys()):\n                if 'sample_int_uT_diff_from_expected_perc' in list(\n                    Optimizer_STDEV_OPT[Key][sample].keys()):\n                    max_sample_accuracy_perc = max(max_sample_accuracy_perc,\n                        Optimizer_STDEV_OPT[Key][sample][\n                        'sample_int_uT_diff_from_expected_perc'])\n        for Function in optimization_functions:\n            try:\n                optimization_functions_matrices[Function][stat2_index,\n                    stat1_index] = eval(Function)\n            except:\n                logfile.write(\n                    \"\"\"-E Error: something is wrong with optimization function %s. Check!\n\"\"\"\n                     % Function)\n        stat2_index += 1\n    stat1_index += 1\ntry:\n    os.mkdir(WD + '/consistency_test/pdf')\nexcept:\n    pass\ntry:\n    os.mkdir(WD + '/consistency_test/svg')\nexcept:\n    pass\nFig_counter = 0\nfor function in optimization_functions:\n    if sum(optimization_functions_matrices[function].flatten()) == 0:\n        Fig_counter += 1\n        continue\n    x, y = meshgrid(stat1_range[1], stat2_range[1])\n    cmap = matplotlib.cm.get_cmap('jet')\n    figure(Fig_counter, (11, 8))\n    clf()\n    delta_stat1 = (stat1_range[1][1] - stat1_range[1][0]) / 2\n    delta_stat2 = (stat2_range[1][1] - stat2_range[1][0]) / 2\n    if 'study_sample_n' in function:\n        Flattened = optimization_functions_matrices[function].flatten()\n        N_colors = max(Flattened) - min(Flattened)\n        cdict = cmap._segmentdata.copy()\n        colors_i = linspace(0, 1.0, N_colors)\n        indices = linspace(0, 1.0, N_colors + 1)\n        for COLOR in ('red', 'green', 'blue'):\n            D = array(cdict[COLOR])\n            I = scipy.interpolate.interp1d(D[:, (0)], D[:, (1)])\n            colors = I(colors_i)\n            A = zeros((N_colors + 1, 3), float)\n            A[:, (0)] = indices\n            A[1:, (1)] = colors\n            A[:-1, (2)] = colors\n            L = []\n            for l in A:\n                L.append(tuple(l))\n            cdict[COLOR] = tuple(L)\n        discrete_jet = matplotlib.colors.LinearSegmentedColormap('colormap',\n            cdict, 1024)\n        img = imshow(optimization_functions_matrices[function],\n            interpolation='nearest', cmap=discrete_jet, extent=(stat1_range\n            [1][0] - delta_stat1, stat1_range[1][-1] + delta_stat1, \n            stat2_range[1][-1] + delta_stat2, stat2_range[1][0] - delta_stat2))\n    else:\n        img = imshow(optimization_functions_matrices[function],\n            interpolation='nearest', cmap=cmap, extent=(stat1_range[1][0] -\n            delta_stat1, stat1_range[1][-1] + delta_stat1, stat2_range[1][-\n            1] + delta_stat2, stat2_range[1][0] - delta_stat2))\n    xticks(stat1_range[1])\n    yticks(stat2_range[1])\n    colorbar()\n    stat1_index = 0\n    if True:\n        for stat1_value in stat1_range[1]:\n            stat2_index = 0\n            for stat2_value in stat2_range[1]:\n                try:\n                    text(stat1_value, stat2_value, '%i' % int(\n                        optimization_functions_matrices[function][\n                        stat1_index, stat2_index]), fontsize=8, color=\n                        'gray', horizontalalignment='center',\n                        verticalalignment='center')\n                except:\n                    pass\n                stat2_index += 1\n            stat1_index += 1\n    title('optimization function =\\n %s ' % function, fontsize=10)\n    xlabel(stat1_range[0])\n    ylabel(stat2_range[0])\n    Ax = gca()\n    xticks(rotation=90)\n    Ax.set_aspect('auto')\n    savefig('%s/consistency_test/pdf/optimization_function_%i' % (WD,\n        Fig_counter) + '.pdf')\n    savefig('%s/consistency_test/svg/optimization_function_%i' % (WD,\n        Fig_counter) + '.svg')\n    close()\n    Fig_counter += 1\nruntime_sec = time.time() - start_time\nm, s = divmod(runtime_sec, 60)\nh, m = divmod(m, 60)\nlogfile.write('-I- runtime from start (hh:mm:ss) ' + '%d:%02d:%02d\\n' % (h,\n    m, s))\nlogfile.write('-I- Finished sucsessfuly.\\n')\nlogfile.write('-I- DONE\\n')\n"
}
{
    "functionName": "categorical_accuracy",
    "className": null,
    "fileName": "/Lasagne_&_Lasagne/lasagne_&_objectives.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Computes the categorical accuracy between predictions and targets.\n\n    .. math:: L_i = \\\\mathbb{I}(t_i = \\\\operatorname{argmax}_c p_{i,c})\n\n    Can be relaxed to allow matches among the top :math:`k` predictions:\n\n    .. math::\n        L_i = \\\\mathbb{I}(t_i \\\\in \\\\operatorname{argsort}_c (-p_{i,c})_{:k})\n\n    Parameters\n    ----------\n    predictions : Theano 2D tensor\n        Predictions in (0, 1), such as softmax output of a neural network,\n        with data points in rows and class probabilities in columns.\n    targets : Theano 2D tensor or 1D tensor\n        Either a vector of int giving the correct class index per data point\n        or a 2D tensor of 1 hot encoding of the correct class in the same\n        layout as predictions\n    top_k : int\n        Regard a prediction to be correct if the target class is among the\n        `top_k` largest class probabilities. For the default value of 1, a\n        prediction is correct only if the target class is the most probable.\n\n    Returns\n    -------\n    Theano 1D tensor\n        An expression for the item-wise categorical accuracy in {0, 1}\n\n    Notes\n    -----\n    This is a strictly non differential function as it includes an argmax.\n    This objective function should never be used with a gradient calculation.\n    It is intended as a convenience for validation and testing not training.\n\n    To obtain the average accuracy, call :func:`theano.tensor.mean()` on the\n    result, passing ``dtype=theano.config.floatX`` to compute the mean on GPU.\n    \"\"\"\nif targets.ndim == predictions.ndim:\n    targets = theano.tensor.argmax(targets, axis=-1)\nelif targets.ndim != predictions.ndim - 1:\n    raise TypeError('rank mismatch between targets and predictions')\nif top_k == 1:\n    top = theano.tensor.argmax(predictions, axis=-1)\n    return theano.tensor.eq(top, targets)\nelse:\n    top = theano.tensor.argsort(predictions, axis=-1)\n    top = top[[slice(None) for _ in range(top.ndim - 1)] + [slice(-top_k,\n        None)]]\n    targets = theano.tensor.shape_padaxis(targets, axis=-1)\n    return theano.tensor.any(theano.tensor.eq(top, targets), axis=-1)\n"
}
{
    "functionName": "find_surface_pores",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_topotools_&_topotools.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Find the pores on the surface of the domain by performing a Delaunay\n    triangulation between the network pores and some external ``markers``. All\n    pores connected to these external marker points are considered surface\n    pores.\n\n    Parameters\n    ----------\n    network: OpenPNM Network Object\n        The network for which the surface pores are to be found\n\n    markers: array_like\n        3 x N array of the marker coordinates to use in the triangulation.  The\n        labeling is performed in one step, so all points are added, and then\n        any pores connected to at least one marker is given the provided label.\n        By default, this function will automatically generate 6 points outside\n        each axis of the network domain.\n\n        Users may wish to specify a single external marker point and provide an\n        appropriate label in order to identify specific faces.  For instance,\n        the marker may be *above* the domain, and the label might be\n        'top_surface'.\n\n    label : string\n        The label to apply to the pores.  The default is 'surface'.\n\n    Notes\n    -----\n    This function does not check whether the given markers actually lie outside\n    the domain, allowing the labeling of *internal* sufaces.\n\n    If this method fails to mark some surface pores, consider sending more\n    markers on each face.\n\n    Examples\n    --------\n    >>> import openpnm as op\n    >>> net = op.network.Cubic(shape=[5, 5, 5])\n    >>> op.topotools.find_surface_pores(network=net)\n    >>> net.num_pores('surface')\n    98\n\n    When cubic networks are created, the surfaces are already labeled:\n\n    >>> net.num_pores(['top','bottom', 'left', 'right', 'front','back'])\n    98\n\n    \"\"\"\nimport scipy.spatial as sptl\ndims = dimensionality(network)\ncoords = network['pore.coords'][:, (dims)]\nif markers is None:\n    coords -= np.amin(coords, axis=0)\n    coords /= np.amax(coords, axis=0)\n    coords -= 0.5\n    npts = max((network.Np / 10, 100))\n    if sum(dims) == 1:\n        network['pore.' + label] = True\n        return\n    if sum(dims) == 2:\n        r = 0.75\n        theta = np.linspace(0, 2 * np.pi, int(npts), dtype=float)\n        x = r * np.cos(theta)\n        y = r * np.sin(theta)\n        markers = np.vstack((x, y)).T\n    if sum(dims) == 3:\n        r = 1.0\n        indices = np.arange(0, int(npts), dtype=float) + 0.5\n        phi = np.arccos(1 - 2 * indices / npts)\n        theta = np.pi * (1 + 5 ** 0.5) * indices\n        x = r * np.cos(theta) * np.sin(phi)\n        y = r * np.sin(theta) * np.sin(phi)\n        z = r * np.cos(phi)\n        markers = np.vstack((x, y, z)).T\nelse:\n    if sum(dims) == 1:\n        pass\n    if sum(dims) == 2:\n        markers = np.atleast_2d(markers)\n        if markers.shape[1] != 2:\n            raise Exception('Network appears planar, so markers must be 2D')\n    if sum(dims) == 3:\n        markers = np.atleast_2d(markers)\n        if markers.shape[1] != 3:\n            raise Exception('Markers must be 3D for this network')\npts = np.vstack((coords, markers))\ntri = sptl.Delaunay(pts, incremental=False)\nindices, indptr = tri.vertex_neighbor_vertices\nfor k in range(network.Np, tri.npoints):\n    neighbors = indptr[indices[k]:indices[k + 1]]\n    inds = np.where(neighbors < network.Np)\n    neighbors = neighbors[inds]\n    if 'pore.' + label not in network.keys():\n        network['pore.' + label] = False\n    network['pore.' + label][neighbors] = True\n"
}
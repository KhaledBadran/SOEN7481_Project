{
    "functionName": "global_boundaries",
    "className": "TestTfCudaResample",
    "fileName": "/tum-pbs_&_PhiFlow/gpu_tests_&_test_tf_cuda_resample.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "with tf.device(device):\n    for i in range(self.N):\n        data = self.generate_data()\n        points = self.generate_points(data.shape)\n        boundary = rand.choice(self.BOUNDARIES)\n        data_placeholder = tf.placeholder(tf.float32, name=\n            'data_placeholder', shape=data.shape)\n        points_placeholder = tf.placeholder(tf.float32, name=\n            'points_placeholder', shape=points.shape)\n        cuda_resampled = resample_cuda(data_placeholder, points_placeholder,\n            boundary)\n        gradient = np.zeros(cuda_resampled.shape, np.float32)\n        for j in range(gradient.size):\n            gradient.flat[j] = rand.uniform(self.MIN_VALUE, self.MAX_VALUE)\n        gradient_placeholder = tf.placeholder(tf.float32, name=\n            'gradient_placeholder', shape=gradient.shape)\n        cuda_data_gradient = tf.gradients(cuda_resampled, data_placeholder,\n            gradient_placeholder)[0]\n        cuda_points_gradient = tf.gradients(cuda_resampled,\n            points_placeholder, gradient_placeholder)[0]\n        boundary_func = SUPPORTED_BOUNDARY[boundary.lower()]\n        nifty_resampled = _resample_linear_niftynet(data_placeholder,\n            points_placeholder, boundary, boundary_func)\n        nifty_data_gradient = tf.gradients(nifty_resampled,\n            data_placeholder, gradient_placeholder)[0]\n        nifty_points_gradient = tf.gradients(nifty_resampled,\n            points_placeholder, gradient_placeholder)[0]\n        with tf.Session(config=tf.ConfigProto(allow_soft_placement=True)\n            ) as sess:\n            result = sess.run([cuda_resampled, nifty_resampled,\n                cuda_data_gradient, nifty_data_gradient,\n                cuda_points_gradient, nifty_points_gradient], feed_dict={\n                data_placeholder: data, points_placeholder: points,\n                gradient_placeholder: gradient})\n        for k in range(3):\n            difference = result[2 * k + 1] - result[2 * k]\n            for j in range(difference.size):\n                assert -self.MAX_DIFFERENCE < difference.flat[j\n                    ] < self.MAX_DIFFERENCE\n"
}
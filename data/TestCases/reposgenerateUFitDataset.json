{
    "functionName": "generateUFitDataset",
    "className": "DataSet",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Generate uFitDataset from cut.\n\n        Args:\n\n            - pdData (pandas dataframe): Data generated from 1D cut\n\n            - q1 (array): Start point for cut\n\n            - q2 (array): End point for cut\n\n            - rlu (bool): If in reciprocal lattice unites or not\n\n            - width (float): Width size (used for rounding of labels)\n\n            - minPixel (float): Minimum pixel size (used for rounding of labels)\n\n            - Emin (float): Minimum energy\n             \n            - Emax (float): Maximum energy\n\n        Kwargs:\n\n            - QDirection (bool): If true ufitdata is created along Q, otherwise energy (default True)\n\n        \"\"\"\nif rlu:\n    variables = ['H', 'K', 'L']\nelse:\n    variables = ['Qx', 'Qy']\nvariables = variables\nif QDirection:\n    QRounding = int(-np.round(np.log10(minPixel)))\n    ERounding = int(np.round(6 / np.linalg.norm(Emin - Emax)))\n    ERounding = np.max([ERounding, 1])\n    QRounding = np.max([QRounding, 1])\n    dirVec = np.array(q2) - np.array(q1)\n    if rlu:\n        dirVec = _tools.LengthOrder(dirVec)\n    else:\n        dirVec = _tools.Norm2D(dirVec)\n    pdData['binDistance'] = np.linalg.norm(pdData[variables] - np.array(\n        pdData[variables].iloc[1]), axis=1) / np.linalg.norm(dirVec)\n    startPos = pdData[variables].iloc[0]\n    if rlu:\n        xdirection = _tools.generateLabel(np.round(dirVec, QRounding))[1:-1\n            ].split(', ')\n    else:\n        xdirection = _tools.generateLabel(np.round(dirVec, QRounding),\n            labels=['Qx', 'Qy'])[1:-1].split(', ')\n    xConstantOffset = np.round(startPos, QRounding)\n    xlabel = []\n    for l, val in zip(xdirection, xConstantOffset):\n        if np.isclose(val, 0):\n            xlabel.append(l)\n        elif l == '0':\n            xlabel.append('{}'.format(val))\n        else:\n            xlabel.append(l + '{:+}'.format(val))\nelse:\n    ERounding = int(-np.round(np.log10(minPixel)))\n    QRounding = int(-np.round(np.log10(width)))\n    ERounding = np.max([ERounding, 1])\n    QRounding = np.max([QRounding, 1])\n    pdData['binDistance'] = pdData['Energy']\n    xlabel = [str(x) for x in np.array(q1, dtype=float).round(QRounding)]\nx = np.array(pdData['binDistance'])\nEnergy = (Emin + Emax) * 0.5\nmeta = dict()\nmeta['instrument'] = self[0].instrument\nmeta['experiment'] = ', '.join(d.experimentIdentifier for d in self)\nmeta['title'] = self[0].title\nmeta['datafilename'] = ', '.join(d.name for d in self)\nInt = np.array(pdData['Int'])\nerr = np.sqrt(pdData['Intensity']) * pdData['BinCount'] / (pdData['Monitor'\n    ] * pdData['Normalization'])\ndata = np.array([x, Int, err]).T\nxcol = '\\n'.join(xlabel) + '\\n' + '{:.3}'.format(np.round(Energy, ERounding))\nif rlu:\n    xcol += '\\n[RLU,meV]'\nelse:\n    xcol += '\\n' + '[$\\\\AA^{-1}$,meV]'\nycol = 'Intensity'\nname = 'Intensity'\nufitData = Dataset(meta=meta, data=data, xcol=xcol, ycol=ycol, name=name)\nreturn ufitData\n"
}
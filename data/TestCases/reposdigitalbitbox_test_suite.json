{
    "functionName": "digitalbitbox_test_suite",
    "className": null,
    "fileName": "/bitcoin-core_&_HWI/test_&_test_digitalbitbox.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "try:\n    os.unlink('bitbox-emulator.stderr')\nexcept FileNotFoundError:\n    pass\nbitbox_log = open('bitbox-emulator.stderr', 'a')\nsimulator_proc = subprocess.Popen(['./' + os.path.basename(simulator),\n    '../../tests/sd_files/'], cwd=os.path.dirname(simulator), stderr=bitbox_log\n    )\nwhile True:\n    try:\n        dev = BitboxSimulator('127.0.0.1', 35345)\n        reply = send_plain(b'{\"password\":\"0000\"}', dev)\n        if 'error' not in reply:\n            break\n    except:\n        pass\n    time.sleep(0.5)\ndef cleanup_simulator():\n    simulator_proc.terminate()\n    simulator_proc.wait()\n    bitbox_log.close()\natexit.register(cleanup_simulator)\nsend_encrypt(json.dumps({'seed': {'source': 'backup', 'filename':\n    'test_backup.pdf', 'key': 'key'}}), '0000', dev)\ntype = 'digitalbitbox'\nfull_type = 'digitalbitbox'\npath = 'udp:127.0.0.1:35345'\nfingerprint = 'a31b978a'\nmaster_xpub = (\n    'xpub6BsWJiRvbzQJg3J6tgUKmHWYbHJSj41EjAAje6LuDwnYLqLiNSWK4N7rCXwiUmNJTBrKL8AEH3LBzhJdgdxoy4T9aMPLCWAa6eWKGCFjQhq'\n    )\nclass TestDBBManCommands(DeviceTestCase):\n\n    def test_restore(self):\n        result = self.do_command(self.dev_args + ['-i', 'restore'])\n        self.assertIn('error', result)\n        self.assertIn('code', result)\n        self.assertEqual(result['error'],\n            'The Digital Bitbox does not support restoring via software')\n        self.assertEqual(result['code'], -9)\n\n    def test_pin(self):\n        result = self.do_command(self.dev_args + ['promptpin'])\n        self.assertIn('error', result)\n        self.assertIn('code', result)\n        self.assertEqual(result['error'],\n            'The Digital Bitbox does not need a PIN sent from the host')\n        self.assertEqual(result['code'], -9)\n        result = self.do_command(self.dev_args + ['sendpin', '1234'])\n        self.assertIn('error', result)\n        self.assertIn('code', result)\n        self.assertEqual(result['error'],\n            'The Digital Bitbox does not need a PIN sent from the host')\n        self.assertEqual(result['code'], -9)\n\n    def test_display(self):\n        result = self.do_command(self.dev_args + ['displayaddress',\n            '--path', 'm/0h'])\n        self.assertIn('error', result)\n        self.assertIn('code', result)\n        self.assertEqual(result['error'],\n            'The Digital Bitbox does not have a screen to display addresses on'\n            )\n        self.assertEqual(result['code'], -9)\n\n    def test_setup_wipe(self):\n        result = self.do_command(self.dev_args + ['-i', 'setup', '--label',\n            'setup_test', '--backup_passphrase', 'testpass'])\n        self.assertEquals(result['code'], -10)\n        self.assertEquals(result['error'],\n            'Device is already initialized. Use wipe first and try again')\n        result = self.do_command(self.dev_args + ['wipe'])\n        self.assertTrue(result['success'])\n        result = self.do_command(self.dev_args + ['-i', 'setup', '--label',\n            'setup_test'])\n        self.assertEquals(result['code'], -7)\n        self.assertEquals(result['error'],\n            'The label and backup passphrase for a new Digital Bitbox wallet must be specified and cannot be empty'\n            )\n        result = self.do_command(self.dev_args + ['-i', 'setup',\n            '--backup_passphrase', 'testpass'])\n        self.assertEquals(result['code'], -7)\n        self.assertEquals(result['error'],\n            'The label and backup passphrase for a new Digital Bitbox wallet must be specified and cannot be empty'\n            )\n        result = self.do_command(self.dev_args + ['-i', 'setup', '--label',\n            'setup_test', '--backup_passphrase', 'testpass'])\n        self.assertTrue(result['success'])\n        result = self.do_command(self.dev_args + ['wipe'])\n        self.assertTrue(result['success'])\n        send_plain(b'{\"password\":\"0000\"}', dev)\n        send_encrypt(json.dumps({'seed': {'source': 'backup', 'filename':\n            'test_backup.pdf', 'key': 'key'}}), '0000', dev)\n        result = self.do_command(self.dev_args + ['-i', 'setup', '--label',\n            'setup_test', '--backup_passphrase', 'testpass'])\n        self.assertEquals(result['code'], -10)\n        self.assertEquals(result['error'],\n            'Device is already initialized. Use wipe first and try again')\n\n    def test_backup(self):\n        result = self.do_command(self.dev_args + ['backup', '--label',\n            'backup_test'])\n        self.assertEquals(result['code'], -7)\n        self.assertEquals(result['error'],\n            'The label and backup passphrase for a Digital Bitbox backup must be specified and cannot be empty'\n            )\n        result = self.do_command(self.dev_args + ['backup',\n            '--backup_passphrase', 'key'])\n        self.assertEquals(result['code'], -7)\n        self.assertEquals(result['error'],\n            'The label and backup passphrase for a Digital Bitbox backup must be specified and cannot be empty'\n            )\n        result = self.do_command(self.dev_args + ['wipe'])\n        self.assertTrue(result['success'])\n        result = self.do_command(self.dev_args + ['-i', 'setup', '--label',\n            'backup_test', '--backup_passphrase', 'testpass'])\n        self.assertTrue(result['success'])\n        result = self.do_command(self.dev_args + ['backup', '--label',\n            'backup_test_backup', '--backup_passphrase', 'testpass'])\n        self.assertTrue(result['success'])\nclass TestBitboxGetXpub(DeviceTestCase):\n\n    def test_getxpub(self):\n        result = self.do_command(self.dev_args + ['--expert', 'getxpub',\n            'm/44h/0h/0h/3'])\n        self.assertEqual(result['xpub'],\n            'xpub6Du9e5Cz1NZWz3dvsvM21tsj4xEdbAb7AcbysFL42Y3yr8PLMnsaxhetHxurTpX5Rp5RbnFFwP1wct8K3gErCUSwcxFhxThsMBSxdmkhTNf'\n            )\n        self.assertFalse(result['testnet'])\n        self.assertFalse(result['private'])\n        self.assertEqual(result['depth'], 4)\n        self.assertEqual(result['parent_fingerprint'], '31d5e5ea')\n        self.assertEqual(result['child_num'], 3)\n        self.assertEqual(result['chaincode'],\n            '7062818c752f878bf96ca668f77630452c3fa033b7415eed3ff568e04ada8104')\n        self.assertEqual(result['pubkey'],\n            '029078c9ad8421afd958d7bc054a0952874923e2586fc9375604f0479a354ea193'\n            )\nsuite = unittest.TestSuite()\nsuite.addTest(DeviceTestCase.parameterize(TestDBBManCommands, rpc, userpass,\n    type, full_type, path, fingerprint, master_xpub, '0000', interface=\n    interface))\nsuite.addTest(DeviceTestCase.parameterize(TestBitboxGetXpub, rpc, userpass,\n    type, full_type, path, fingerprint, master_xpub, '0000', interface=\n    interface))\nsuite.addTest(DeviceTestCase.parameterize(TestDeviceConnect, rpc, userpass,\n    type, full_type, path, fingerprint, master_xpub, '0000', interface=\n    interface))\nsuite.addTest(DeviceTestCase.parameterize(TestDeviceConnect, rpc, userpass,\n    'digitalbitbox_01_simulator', full_type, path, fingerprint, master_xpub,\n    '0000', interface=interface))\nsuite.addTest(DeviceTestCase.parameterize(TestGetDescriptors, rpc, userpass,\n    type, full_type, path, fingerprint, master_xpub, '0000', interface=\n    interface))\nsuite.addTest(DeviceTestCase.parameterize(TestGetKeypool, rpc, userpass,\n    type, full_type, path, fingerprint, master_xpub, '0000', interface=\n    interface))\nsuite.addTest(DeviceTestCase.parameterize(TestSignTx, rpc, userpass, type,\n    full_type, path, fingerprint, master_xpub, '0000', interface=interface))\nsuite.addTest(DeviceTestCase.parameterize(TestSignMessage, rpc, userpass,\n    type, full_type, path, fingerprint, master_xpub, '0000', interface=\n    interface))\nresult = unittest.TextTestRunner(stream=sys.stdout, verbosity=2).run(suite)\ncleanup_simulator()\natexit.unregister(cleanup_simulator)\nreturn result.wasSuccessful()\n"
}
{
    "functionName": "_initialize_tps",
    "className": null,
    "fileName": "/Lasagne_&_Lasagne/lasagne_&_layers_&_special.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Initializes the thin plate spline calculation by creating the source\n    point array and the inverted L matrix used for calculating the\n    transformations as in ref [2]_\n\n    :param num_control_points: the number of control points. Must be a\n        perfect square. Points will be used to generate an evenly spaced grid.\n    :param input_shape: tuple with 4 elements specifying the input shape\n    :param downsample_factor: tuple with 2 elements specifying the\n        downsample for the height and width, respectively\n    :param precompute_grid: boolean specifying whether to precompute the\n        grid matrix\n    :return:\n        right_mat: shape (num_control_points + 3, out_height*out_width) tensor\n        L_inv: shape (num_control_points + 3, num_control_points + 3) tensor\n        source_points: shape (2, num_control_points) tensor\n        out_height: tensor constant specifying the ouptut height\n        out_width: tensor constant specifying the output width\n\n    \"\"\"\n_, _, height, width = input_shape\ngrid_size = np.sqrt(num_control_points)\nx_control_source, y_control_source = np.meshgrid(np.linspace(-1, 1,\n    grid_size), np.linspace(-1, 1, grid_size))\nsource_points = np.vstack((x_control_source.flatten(), y_control_source.\n    flatten()))\nsource_points = source_points.astype(theano.config.floatX)\nnum_equations = num_control_points + 3\nL = np.zeros((num_equations, num_equations), dtype=theano.config.floatX)\nL[(0), 3:num_equations] = 1.0\nL[1:3, 3:num_equations] = source_points\nL[3:num_equations, (0)] = 1.0\nL[3:num_equations, 1:3] = source_points.T\nfor point_1 in range(num_control_points):\n    for point_2 in range(point_1, num_control_points):\n        L[point_1 + 3, point_2 + 3] = _U_func_numpy(source_points[0,\n            point_1], source_points[1, point_1], source_points[0, point_2],\n            source_points[1, point_2])\n        if point_1 != point_2:\n            L[point_2 + 3, point_1 + 3] = L[point_1 + 3, point_2 + 3]\nL_inv = np.linalg.inv(L)\nif precompute_grid:\n    out_height = np.array(height // downsample_factor[0]).astype('int64')\n    out_width = np.array(width // downsample_factor[1]).astype('int64')\n    x_t, y_t = np.meshgrid(np.linspace(-1, 1, out_width), np.linspace(-1, 1,\n        out_height))\n    ones = np.ones(np.prod(x_t.shape))\n    orig_grid = np.vstack([x_t.flatten(), y_t.flatten(), ones])\n    orig_grid = orig_grid[0:2, :]\n    orig_grid = orig_grid.astype(theano.config.floatX)\n    to_transform = orig_grid[:, :, (np.newaxis)].transpose(2, 0, 1)\n    stacked_transform = np.tile(to_transform, (num_control_points, 1, 1))\n    stacked_source_points = source_points[:, :, (np.newaxis)].transpose(1, 0, 2\n        )\n    r_2 = np.sum((stacked_transform - stacked_source_points) ** 2, axis=1)\n    log_r_2 = np.log(r_2)\n    log_r_2[np.isinf(log_r_2)] = 0.0\n    distances = r_2 * log_r_2\n    upper_array = np.ones(shape=(1, orig_grid.shape[1]), dtype=theano.\n        config.floatX)\n    upper_array = np.concatenate([upper_array, orig_grid], axis=0)\n    right_mat = np.concatenate([upper_array, distances], axis=0)\n    out_height = T.as_tensor_variable(out_height)\n    out_width = T.as_tensor_variable(out_width)\n    right_mat = T.as_tensor_variable(right_mat)\nelse:\n    out_height = None\n    out_width = None\n    right_mat = None\nL_inv = T.as_tensor_variable(L_inv)\nsource_points = T.as_tensor_variable(source_points)\nreturn right_mat, L_inv, source_points, out_height, out_width\n"
}
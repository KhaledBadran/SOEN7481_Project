{
    "functionName": "convNd",
    "className": null,
    "fileName": "/Lasagne_&_Lasagne/lasagne_&_tests_&_layers_&_test_conv.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Execute a batch of a stack of N-dimensional convolutions.\n\n    Parameters\n    ----------\n    input : numpy array\n    kernel : numpy array\n    pad : {0, 'valid', 'same', 'full'}, int or tuple of int\n    stride : int or tuple of int\n    groups: int\n    n : int\n\n    Returns\n    -------\n    numpy array\n    \"\"\"\nif groups > 1:\n    input = input.reshape(input.shape[0], groups, -1, *input.shape[2:])\n    kernel = kernel.reshape(groups, -1, *kernel.shape[1:])\n    return np.concatenate([convNd(input[:, (g)], kernel[g], pad, stride,\n        groups=1, n=n) for g in range(groups)], axis=1)\nif n is None:\n    n = input.ndim - 2\nif pad not in ['valid', 'same', 'full']:\n    pad = as_tuple(pad, n, int)\n    input = np.pad(input, [(p, p) for p in (0, 0) + pad], mode='constant')\n    pad = 'valid'\noutput = np.zeros((input.shape[0], kernel.shape[0]) + tuple(i + k - 1 for i,\n    k in zip(input.shape[2:], kernel.shape[2:])))\nif n == 1:\n    for i in range(kernel.shape[2]):\n        f = kernel[:, :, i:i + 1]\n        c = (input[:, (np.newaxis)] * f).sum(axis=2)\n        output[:, :, i:i + input.shape[2]] += c\nelif n == 2:\n    for i in range(kernel.shape[2]):\n        for j in range(kernel.shape[3]):\n            f = kernel[:, :, i:i + 1, j:j + 1]\n            c = (input[:, (np.newaxis)] * f).sum(axis=2)\n            output[:, :, i:i + input.shape[2], j:j + input.shape[3]] += c\nelif n == 3:\n    for i in range(kernel.shape[2]):\n        for j in range(kernel.shape[3]):\n            for k in range(kernel.shape[4]):\n                f = kernel[:, :, i:i + 1, j:j + 1, k:k + 1]\n                c = (input[:, (np.newaxis)] * f).sum(axis=2)\n                output[:, :, i:i + input.shape[2], j:j + input.shape[3], k:\n                    k + input.shape[4]] += c\nelse:\n    raise NotImplementedError('convNd() only supports n in (1, 2, 3)')\nif pad == 'valid':\n    trim = tuple(k - 1 for k in kernel.shape[2:])\n    slices = [slice(None), slice(None)]\n    slices += [slice(t, -t or None) for t in trim]\n    output = output[slices]\nelif pad == 'same':\n    shift = tuple((k - 1) // 2 for k in kernel.shape[2:])\n    slices = [slice(None), slice(None)]\n    slices += [slice(s, s + i) for s, i in zip(shift, input.shape[2:])]\n    output = output[slices]\nstride = as_tuple(stride, n, int)\nif any(s > 1 for s in stride):\n    slices = [slice(None), slice(None)]\n    slices += [slice(None, None, s) for s in stride]\n    output = output[slices]\nreturn output\n"
}
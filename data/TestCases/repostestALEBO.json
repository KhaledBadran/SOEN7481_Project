{
    "functionName": "testALEBO",
    "className": "ALEBOTest",
    "fileName": "/facebook_&_Ax/ax_&_models_&_tests_&_test_alebo.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "B = torch.tensor([[1.0, 2.0, 3.0, 4.0, 5.0], [2.0, 3.0, 4.0, 5.0, 6.0]],\n    dtype=torch.double)\ntrain_X = torch.tensor([[0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 1.0, 1.0, 1.0, 1.0\n    ], [2.0, 2.0, 2.0, 2.0, 2.0]], dtype=torch.double)\ntrain_Y = torch.tensor([[1.0], [2.0], [3.0]], dtype=torch.double)\ntrain_Yvar = 0.1 * torch.ones(3, 1, dtype=torch.double)\nm = ALEBO(B=B, laplace_nsamp=5, fit_restarts=1)\nself.assertTrue(torch.equal(B, m.B))\nself.assertEqual(m.laplace_nsamp, 5)\nself.assertEqual(m.fit_restarts, 1)\nself.assertEqual(m.refit_on_update, True)\nself.assertEqual(m.refit_on_cv, False)\nself.assertEqual(m.warm_start_refitting, False)\nm.fit(Xs=[train_X, train_X], Ys=[train_Y, train_Y], Yvars=[train_Yvar,\n    train_Yvar], bounds=[(-1, 1)] * 5, task_features=[], feature_names=[],\n    metric_names=[], fidelity_features=[])\nself.assertIsInstance(m.model, ModelListGP)\nself.assertTrue(torch.allclose(m.Xs[0], (B @ train_X.t()).t()))\nf, cov = m.predict(X=B)\nself.assertEqual(f.shape, torch.Size([2, 2]))\nself.assertEqual(cov.shape, torch.Size([2, 2, 2]))\nobjective_weights = torch.tensor([1.0, 0.0], dtype=torch.double)\nwith self.assertRaises(NotImplementedError):\n    m.best_point(bounds=[(-1, 1)] * 5, objective_weights=objective_weights)\nwith mock.patch('ax.models.torch.alebo.optimize_acqf', autospec=True,\n    return_value=(m.Xs[0], torch.tensor([]))):\n    Xopt, _, _, _ = m.gen(n=1, bounds=[(-1, 1)] * 5, objective_weights=\n        torch.tensor([1.0, 0.0], dtype=torch.double))\nself.assertFalse(torch.allclose(Xopt, train_X))\nself.assertTrue(Xopt.min() >= -1)\nself.assertTrue(Xopt.max() <= 1)\nwith mock.patch('ax.models.torch.alebo.optimize_acqf', autospec=True,\n    return_value=(torch.ones(1, 2, dtype=torch.double), torch.tensor([]))):\n    Xopt, _, _, _ = m.gen(n=1, bounds=[(-1, 1)] * 5, objective_weights=\n        torch.tensor([1.0, 0.0], dtype=torch.double))\nself.assertTrue(torch.allclose(Xopt, torch.tensor([[-0.2, -0.1, 0.0, 0.1, \n    0.2]], dtype=torch.double)))\ntrain_X2 = torch.tensor([[3.0, 3.0, 3.0, 3.0, 3.0], [1.0, 1.0, 1.0, 1.0, \n    1.0], [2.0, 2.0, 2.0, 2.0, 2.0]], dtype=torch.double)\nm.update(Xs=[train_X, train_X2], Ys=[train_Y, train_Y], Yvars=[train_Yvar,\n    train_Yvar])\nself.assertTrue(torch.allclose(m.Xs[0], (B @ train_X.t()).t()))\nself.assertTrue(torch.allclose(m.Xs[1], (B @ train_X2.t()).t()))\nm.refit_on_update = False\nm.update(Xs=[train_X, train_X2], Ys=[train_Y, train_Y], Yvars=[train_Yvar,\n    train_Yvar])\ngp = m.get_and_fit_model(Xs=[(B @ train_X.t()).t()], Ys=[train_Y], Yvars=[\n    train_Yvar])\nself.assertIsInstance(gp, ALEBOGP)\nf, cov = m.cross_validate(Xs_train=[train_X], Ys_train=[train_Y],\n    Yvars_train=[train_Yvar], X_test=train_X2)\nself.assertEqual(f.shape, torch.Size([3, 1]))\nself.assertEqual(cov.shape, torch.Size([3, 1, 1]))\nm.refit_on_cv = True\nf, cov = m.cross_validate(Xs_train=[train_X], Ys_train=[train_Y],\n    Yvars_train=[train_Yvar], X_test=train_X2)\nself.assertEqual(f.shape, torch.Size([3, 1]))\nself.assertEqual(cov.shape, torch.Size([3, 1, 1]))\n"
}
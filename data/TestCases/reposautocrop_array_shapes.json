{
    "functionName": "autocrop_array_shapes",
    "className": null,
    "fileName": "/Lasagne_&_Lasagne/lasagne_&_layers_&_merge.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Computes the shapes of the given arrays after auto-cropping is applied.\n\n    For more information on cropping, see the :func:`autocrop` function\n    documentation.\n\n    Parameters\n    ----------\n    input_shapes : the shapes of input arrays prior to cropping in\n        the form of a list of tuples\n\n    cropping : a list of cropping modes, one for each axis. If length of\n        `cropping` is less than the number of axes in the inputs, it is\n        padded with `None`. If `cropping` is None, `input_shapes` is returned\n        as is. For more information on their values and operation, see the\n        :func:`autocrop` documentation.\n\n    Returns\n    -------\n    list of tuples\n        each tuple is a cropped version of the corresponding input\n        shape tuple in `input_shapes`\n\n    For example, given three input shapes with 4 axes each:\n\n    >>> a = (1, 2, 3, 4)\n    >>> b = (5, 4, 4, 2)\n    >>> c = (7, 1, 8, 9)\n\n    Cropping mode for each axis:\n\n    >>> cropping = [None, 'lower', 'center', 'upper']\n\n    Apply:\n\n    >>> cropped_shapes = autocrop_array_shapes([a, b, c], cropping)\n    >>> cropped_shapes[0]\n    (1, 1, 3, 2)\n\n    >>> cropped_shapes[1]\n    (5, 1, 3, 2)\n\n    >>> cropped_shapes[2]\n    (7, 1, 3, 2)\n\n    Note that axis 0 remains unchanged, where all the others are cropped\n    to the minimum size in that axis.\n    \"\"\"\nif cropping is None:\n    return input_shapes\nelse:\n    ndim = len(input_shapes[0])\n    if not all(len(sh) == ndim for sh in input_shapes):\n        raise ValueError(\n            'Not all inputs are of the same dimensionality. Got {0} inputs of dimensionalities {1}.'\n            .format(len(input_shapes), [len(sh) for sh in input_shapes]))\n    result = []\n    cropping = list(cropping)\n    if ndim > len(cropping):\n        cropping = list(cropping) + [None] * (ndim - len(cropping))\n    for sh, cr in zip(zip(*input_shapes), cropping):\n        if cr is None:\n            result.append(sh)\n        elif cr in {'lower', 'center', 'upper'}:\n            min_sh = None if any(x is None for x in sh) else min(sh)\n            result.append([min_sh] * len(sh))\n        else:\n            raise ValueError(\"Unknown crop mode '{0}'\".format(cr))\n    return [tuple(sh) for sh in zip(*result)]\n"
}
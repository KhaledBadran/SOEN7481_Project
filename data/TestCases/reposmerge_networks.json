{
    "functionName": "merge_networks",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_topotools_&_topotools.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Combine multiple networks into one without doing any topological\n    manipulations (such as stiching nearby pores to each other).\n\n    Parameters\n    ----------\n    network : OpenPNM Network Object\n        The network to which all the other networks should be added.\n\n    donor : OpenPNM Network Object or list of Objects\n        The network object(s) to add to the given network\n\n    Notes\n    -----\n    This methods does *not* attempt to stitch the networks topologically.\n\n    See Also\n    --------\n    extend\n    trim\n    stitch\n\n    \"\"\"\nif type(donor) == list:\n    donors = donor\nelse:\n    donors = [donor]\nmain_proj = network.project\nmain_geoms = main_proj.geometries()\nfor donor in donors:\n    proj = donor.project\n    geoms = proj.geometries().values()\n    for geo in geoms:\n        if geo.name in network.project.names:\n            geo.name = network.project._generate_name(geo)\n        network.project.append(geo)\nfor donor in donors:\n    network['pore.coords'] = np.vstack((network['pore.coords'], donor[\n        'pore.coords']))\n    network['throat.conns'] = np.vstack((network['throat.conns'], donor[\n        'throat.conns'] + network.Np))\n    p_all = np.ones((np.shape(network['pore.coords'])[0],), dtype=bool)\n    t_all = np.ones((np.shape(network['throat.conns'])[0],), dtype=bool)\n    network.update({'pore.all': p_all})\n    network.update({'throat.all': t_all})\n    for key in set(network.keys()).union(set(donor.keys())):\n        if key.split('.')[1] not in ['conns', 'coords', '_id', 'all']:\n            if key in network.keys():\n                pop_flag = False\n                if key not in donor.keys():\n                    logger.debug('Adding ' + key + ' to donor')\n                    if network[key].dtype == bool:\n                        donor[key] = False\n                    else:\n                        element = key.split('.')[0]\n                        shape = list(network[key].shape)\n                        N = donor._count(element)\n                        shape[0] = N\n                        donor[key] = np.empty(shape=shape) * np.nan\n                    pop_flag = True\n                if len(network[key].shape) == 1:\n                    temp = np.hstack((network[key], donor[key]))\n                else:\n                    temp = np.vstack((network[key], donor[key]))\n                network[key] = temp\n                if pop_flag:\n                    donor.pop(key, None)\n            else:\n                logger.debug('Adding ' + key + ' to network')\n                if donor[key].dtype == bool:\n                    network[key] = False\n                else:\n                    data_shape = list(donor[key].shape)\n                    pore_prop = True if key.split('.')[0] == 'pore' else False\n                    data_shape[0] = network.Np if pore_prop else network.Nt\n                    network[key] = np.empty(data_shape) * np.nan\n                s = np.shape(donor[key])[0]\n                network[key][-s:] = donor[key]\nnetwork._am.clear()\nnetwork._im.clear()\n"
}
{
    "functionName": "cut1DE",
    "className": null,
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Perform 1D cut through constant Q point returning binned intensity, monitor, normalization and normcount. The width of the cut is given by \n    the width attribute. \n    \n    .. note::\n        Can only perform cuts for a constant energy plane of definable width.\n    \n    Args:\n        \n        - positions (3 arrays): position in Qx, Qy, and E in flattend arrays.\n        \n        - I (array): Flatten intensity array\n        \n        - Norm (array): Flatten normalization array\n        \n        - Monitor (array): Flatten monitor array\n        \n        - E1 (float): Start energy.\n        \n        - E2 (float): End energy.\n\n        - q (2d vector): Q point in (qx,qy)\n        \n        - width (float): Full width of cut in q-plane.\n        \n        - minPixel (float): Minimal size of binning along the cutting direction. Points will be binned if they are closer than minPixel.\n        \n        - Emin (float): Minimal energy to include in cut.\n        \n        - Emax (float): Maximal energy to include in cut\n\n    Kwargs:\n\n        - constantBins (bool): If True only bins of size minPixel is used (default False)\n        \n    Returns:\n        \n        - Data list (4 arrays): Intensity, monitor count, normalization and normalization counts binned in the 1D cut.\n        \n        - Bin list (1 array): Bin edge positions in energy\n        \n    \"\"\"\nif len(q.shape) == 1:\n    q.shape = 2, 1\ndistToQ = np.linalg.norm(positions[:2] - q, axis=0)\ninside = distToQ < width\ninsideEnergy = np.logical_and(positions[2] <= E2, positions[2] >= E1)\nif np.sum(insideEnergy) == 0:\n    raise AttributeError('No points are within the provided energy limits.')\nelif np.sum(inside) == 0:\n    raise AttributeError('No points are inside selected q range.')\nallInside = np.logical_and(inside, insideEnergy)\nEnergies = positions[2][allInside]\nif constantBins == False:\n    bins = np.array(_tools.binEdges(Energies, tolerance=minPixel))\nelse:\n    Min, Max = _tools.minMax(Energies)\n    bins = np.arange(Min, Max + 0.5 * minPixel, minPixel)\nif len(bins) == 0:\n    return [np.array(np.array([])), np.array([]), np.array([]), np.array([])\n        ], [[E1, E2]]\nnormcounts = np.histogram(Energies, bins=bins, weights=np.ones_like(\n    Energies).flatten())[0]\nintensity = np.histogram(Energies, bins=bins, weights=I[allInside].flatten())[0\n    ]\nMonitorCount = np.histogram(Energies, bins=bins, weights=np.array(Monitor[\n    allInside].flatten(), dtype=np.int64))[0]\nNormalization = np.histogram(Energies, bins=bins, weights=Norm[allInside].\n    flatten())[0]\nreturn [intensity, MonitorCount, Normalization, normcounts], [bins]\n"
}
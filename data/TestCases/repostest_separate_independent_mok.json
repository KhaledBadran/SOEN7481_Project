{
    "functionName": "test_separate_independent_mok",
    "className": null,
    "fileName": "/GPflow_&_GPflow/tests_&_gpflow_&_conditionals_&_test_multioutput.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "\"\"\"\n    We use different independent kernels for each of the output dimensions.\n    We can achieve this in two ways:\n        1) efficient: SeparateIndependentMok with Shared/SeparateIndependentMof\n        2) inefficient: SeparateIndependentMok with InducingPoints\n    However, both methods should return the same conditional,\n    and after optimization return the same log likelihood.\n    \"\"\"\nq_mu_1 = np.random.randn(Data.M * Data.P, 1)\nq_sqrt_1 = np.tril(np.random.randn(Data.M * Data.P, Data.M * Data.P))[None, ...\n    ]\nkern_list_1 = [SquaredExponential(variance=0.5, lengthscales=1.2) for _ in\n    range(Data.P)]\nkernel_1 = mk.SeparateIndependent(kern_list_1)\ninducing_variable_1 = InducingPoints(Data.X[:Data.M, (...)])\nmodel_1 = SVGP(kernel_1, Gaussian(), inducing_variable_1, num_latent_gps=1,\n    q_mu=q_mu_1, q_sqrt=q_sqrt_1)\nset_trainable(model_1, False)\nset_trainable(model_1.q_sqrt, True)\nset_trainable(model_1.q_mu, True)\ngpflow.optimizers.Scipy().minimize(model_1.training_loss_closure(Data.data),\n    variables=model_1.trainable_variables, method='BFGS', compile=True)\nq_mu_2 = np.random.randn(Data.M, Data.P)\nq_sqrt_2 = np.array([np.tril(np.random.randn(Data.M, Data.M)) for _ in\n    range(Data.P)])\nkern_list_2 = [SquaredExponential(variance=0.5, lengthscales=1.2) for _ in\n    range(Data.P)]\nkernel_2 = mk.SeparateIndependent(kern_list_2)\ninducing_variable_2 = mf.SharedIndependentInducingVariables(InducingPoints(\n    Data.X[:Data.M, (...)]))\nmodel_2 = SVGP(kernel_2, Gaussian(), inducing_variable_2, num_latent_gps=\n    Data.P, q_mu=q_mu_2, q_sqrt=q_sqrt_2)\nset_trainable(model_2, False)\nset_trainable(model_2.q_sqrt, True)\nset_trainable(model_2.q_mu, True)\ngpflow.optimizers.Scipy().minimize(model_2.training_loss_closure(Data.data),\n    variables=model_2.trainable_variables, method='BFGS', compile=True)\ncheck_equality_predictions(Data.data, [model_1, model_2])\n"
}
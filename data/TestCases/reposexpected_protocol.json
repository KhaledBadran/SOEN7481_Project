{
    "functionName": "expected_protocol",
    "className": null,
    "fileName": "/Galvant_&_InstrumentKit/instruments_&_tests_&___init__.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Given an instrument class, expected output from the host and expected input\n    from the instrument, asserts that the protocol in a context block proceeds\n    according to that expectation.\n\n    For an example of how to write tests using this context manager, see\n    the ``make_name_test`` function below.\n\n    :param ins_class: Instrument class to use for the protocol assertion.\n    :type ins_class: `~instruments.Instrument`\n    :param host_to_ins: Data to be sent by the host to the instrument;\n        this is checked against the actual data sent by the instrument class\n        during the execution of this context manager.\n    :type host_to_ins: ``str`` or ``list``; if ``list``, each line is\n        concatenated with the separator given by ``sep``.\n    :param ins_to_host: Data to be sent by the instrument; this is played\n        back during the execution of this context manager, and should\n        be used to assert correct behaviour within the context.\n    :type ins_to_host: ``str`` or ``list``; if ``list``, each line is\n        concatenated with the separator given by ``sep``.\n    :param str sep: Character to be inserted after each string in both\n        host_to_ins and ins_to_host parameters. This is typically the\n        termination character you would like to have inserted.\n    :param int repeat: The number of times the host_to_ins and\n        ins_to_host data sets should be duplicated. Typically the default\n        value of 1 is sufficient, but increasing this is useful when\n        testing multiple calls in the same test that should have the same\n        command transactions.\n    \"\"\"\nif isinstance(sep, bytes):\n    sep = sep.decode('utf-8')\nif isinstance(ins_to_host, list):\n    ins_to_host = [(item.encode('utf-8') if isinstance(item, str) else item\n        ) for item in ins_to_host]\n    ins_to_host = sep.encode('utf-8').join(ins_to_host) + (sep.encode(\n        'utf-8') if ins_to_host else b'')\nelif isinstance(ins_to_host, str):\n    ins_to_host = ins_to_host.encode('utf-8')\nins_to_host *= repeat\nif isinstance(host_to_ins, list):\n    host_to_ins = [(item.encode('utf-8') if isinstance(item, str) else item\n        ) for item in host_to_ins]\n    host_to_ins = sep.encode('utf-8').join(host_to_ins) + (sep.encode(\n        'utf-8') if host_to_ins else b'')\nelif isinstance(host_to_ins, str):\n    host_to_ins = host_to_ins.encode('utf-8')\nhost_to_ins *= repeat\nstdin = BytesIO(ins_to_host)\nstdout = BytesIO()\nyield ins_class.open_test(stdin, stdout)\nassert stdout.getvalue() == host_to_ins, \"\"\"Expected:\n\n{}\n\nGot:\n\n{}\"\"\".format(\n    repr(host_to_ins), repr(stdout.getvalue()))\ncontextlib.contextmanager"
}
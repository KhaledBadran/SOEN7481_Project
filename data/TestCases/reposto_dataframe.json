{
    "functionName": "to_dataframe",
    "className": "Pandas",
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_io_&_Pandas.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n        Convert the Network (and optionally Phase) data to Pandas DataFrames.\n\n        Parameters\n        ----------\n        network: OpenPNM Network Object\n            The network containing the data to be stored\n\n        phases : list of OpenPNM Phase Objects\n            The data on each supplied phase will be added to DataFrame\n\n        join : boolean\n            If ``False`` (default), two DataFrames are returned with *pore*\n            data in one, and *throat* data in the other.  If ``True`` the pore\n            and throat data are combined into a single DataFrame.  This can be\n            problematic as it will put NaNs into all the *pore* columns which\n            are shorter than the *throat* columns.\n\n        Returns\n        -------\n        Pandas ``DataFrame`` object containing property and label data in each\n        column.  If ``join`` was False (default) the two DataFrames are\n        returned i a named tuple, or else a single DataFrame with pore and\n        throat data in the same file, despite the column length being\n        different.\n\n        \"\"\"\nfrom pandas import DataFrame\nproject, network, phases = cls._parse_args(network=network, phases=phases)\npdata = Dict.to_dict(network=network, phases=phases, element='pore',\n    interleave=True, flatten=True, categorize_by=['object'])\ntdata = Dict.to_dict(network=network, phases=phases, element='throat',\n    interleave=True, flatten=True, categorize_by=['object'])\npdata = FlatDict(pdata, delimiter=delim)\ntdata = FlatDict(tdata, delimiter=delim)\nfor key in list(pdata.keys()):\n    if np.shape(pdata[key]) != (network[0].Np,):\n        arr = pdata.pop(key)\n        tmp = np.split(arr, arr.shape[1], axis=1)\n        cols = range(len(tmp))\n        pdata.update({(key + '[' + str(i) + ']'): tmp[i].squeeze() for i in\n            cols})\nfor key in list(tdata.keys()):\n    if np.shape(tdata[key]) != (network[0].Nt,):\n        arr = tdata.pop(key)\n        tmp = np.split(arr, arr.shape[1], axis=1)\n        cols = range(len(tmp))\n        tdata.update({(key + '[' + str(i) + ']'): tmp[i].squeeze() for i in\n            cols})\npdata = DataFrame(sanitize_dict(pdata))\ntdata = DataFrame(sanitize_dict(tdata))\nif join:\n    data = tdata.join(other=pdata, how='left')\nelse:\n    nt = namedtuple('dataframes', ('pore', 'throat'))\n    data = nt(pore=pdata, throat=tdata)\nreturn data\nclassmethod"
}
{
    "functionName": "cutQE",
    "className": "DataSet",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Wrapper for cut data into maps of q and intensity between two q points and given energies. This is performed by doing consecutive constant energy planes.\n\n        Args:\n\n            - q1 (3D or 2D array): Start position of cut in format (h,k,l) or (qx,qy) depending on rlu flag.\n            \n            - q2 (3D or 2D array): End position of cut in format (h,k,l) or (qx,qy) depending on rlu flag.\n            \n            - width (float): Full width of cut in q-plane.\n            \n            - minPixel (float): Minimal size of binning along the cutting direction. Points will be binned if they are closer than minPixel.\n\n            - EnergyBins (list): Bin edges between which the 1D constant energy cuts are performed.\n\n        Kwargs:\n\n            - rlu (bool): If True, coordinates given are interpreted as (h,k,l) otherwise as (qx,qy)\n\n            - extend (bool): If True, cut is extended to edge of measured area instead of only between provided points.\n\n            - dataFiles (list): List of dataFiles to cut (default None). If none, the ones in the object will be used.\n    \n            - constantBins (bool): If True only bins of size minPixel is used (default False)\n\n\n        Returns:\n            \n            - Data list (pandas DataFrame): DataFrame containing qx,qy,H,K,L,Intensity,Normalization,Monitor,BinCount,Int,binDistance for 2D cut.\n            \n            - Bin list (n * 3 arrays): n instances of bin edge positions in plane of size (m+1,3), orthogonal positions of bin edges in plane of size (2,2), and energy edges of size (2).\n            \n            - center position (n * 3D arrays): n instances of center positions for the bins.\n\n            - binDistance (n arrays): n instances of arrays holding the distance in q to q1.\n\n\n        \"\"\"\nif dataFiles is None:\n    if len(self.convertedFiles) == 0:\n        raise AttributeError(\n            'No data file to be binned provided in either input or DataSet object.'\n            )\n    else:\n        I = self.I.extractData()\n        qx = self.qx.extractData()\n        qy = self.qy.extractData()\n        energy = self.energy.extractData()\n        Norm = self.Norm.extractData()\n        Monitor = self.Monitor.extractData()\n        samples = self.sample\n        maskIndices = self.maskIndices\nelse:\n    DS = DataSet(convertedFiles=dataFiles)\n    I, qx, qy, energy, Norm, Monitor, samples, maskIndices = DS.I.extractData(\n        ), DS.qx.extractData(), DS.qy.extractData(), DS.energy.extractData(\n        ), DS.Norm.extractData(), DS.Monitor.extractData(\n        ), DS.sample, DS.maskIndices\nif rlu == True:\n    q1, q2 = self.convertToQxQy([q1, q2])\n    rotationMatrices = [np.dot(samples[0].RotMat.T, s.RotMat) for s in samples]\n    Q = [[QX, QY] for QX, QY in zip(np.split(qx, maskIndices), np.split(qy,\n        maskIndices))]\n    qx, qy = np.concatenate([np.einsum('ij,j...->i...', rot, q) for rot, q in\n        zip(rotationMatrices, Q)], axis=1)\n    positions = np.array([qx, qy, energy])\nelse:\n    positions = np.array([qx, qy, energy])\nintensityArray = []\nmonitorArray = []\nnormalizationArray = []\nnormcountArray = []\ncenterPos = []\nreturnpositions = []\nbinDistance = []\ndirvec = (np.array(q2) - np.array(q1)).astype(float)\ndirvec /= np.linalg.norm(dirvec)\ndataFrame = []\nfor i in np.arange(len(EnergyBins) - 1):\n    _local, position = self.cut1D(positions=positions, I=I, Norm=Norm,\n        Monitor=Monitor, q1=q1, q2=q2, width=width, minPixel=minPixel, Emin\n        =EnergyBins[i], Emax=EnergyBins[i + 1], plotCoverage=False, extend=\n        extend, constantBins=constantBins, dataFiles=dataFiles, rlu=False)\n    _local['energyCut'] = i\n    dataFrame.append(_local)\n    if len(_local) == 0:\n        continue\n    returnpositions.append(position)\n    thisCenterPos = 0.5 * (position[0][:-1] + position[0][1:])\n    centerPos.append(thisCenterPos)\n    thisBinDistance = np.dot(thisCenterPos[:, :len(q1)] - q1, dirvec)\n    binDistance.append(thisBinDistance)\nif len(dataFrame) > 1:\n    dataFrame = pd.concat(dataFrame)\nelif len(dataFrame) == 1:\n    dataFrame = dataFrame[0]\nfor col in ['Intensity', 'Monitor', 'Normalization', 'BinCount']:\n    dataFrame[col] = dataFrame[col].astype(int)\nreturn dataFrame, returnpositions, centerPos, binDistance\n_tools.KwargChecker()"
}
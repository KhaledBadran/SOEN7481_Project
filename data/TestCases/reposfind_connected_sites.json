{
    "functionName": "find_connected_sites",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_topotools_&_topotools.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Given an adjacency matrix, finds which sites are connected to the input\n    bonds.\n\n    Parameters\n    ----------\n    am : scipy.sparse matrix\n        The adjacency matrix of the network.  Must be symmetrical such that if\n        sites *i* and *j* are connected, the matrix contains non-zero values\n        at locations (i, j) and (j, i).\n\n    flatten : boolean (default is ``True``)\n        Indicates whether the returned result is a compressed array of all\n        neighbors, or a list of lists with each sub-list containing the\n        neighbors for each input site.  Note that an *unflattened* list might\n        be slow to generate since it is a Python ``list`` rather than a Numpy\n        array.\n\n    logic : string\n        Specifies logic to filter the resulting list.  Options are:\n\n        **'or'** : (default) All neighbors of the input bonds.  This is also\n        known as the 'union' in set theory or (sometimes) 'any' in boolean\n        logic.  Both keywords are accepted and treated as 'or'.\n\n        **'xor'** : Only neighbors of one and only one input bond.  This is\n        useful for finding the sites that are not shared by any of the input\n        bonds.  'exclusive_or' is also accepted.\n\n        **'xnor'** : Neighbors that are shared by two or more input bonds. This\n        is equivalent to finding all neighbors with 'or', minus those found\n        with 'xor', and is useful for finding neighbors that the inputs have\n        in common.  'nxor' is also accepted.\n\n        **'and'** : Only neighbors shared by all input bonds.  This is also\n        known as 'intersection' in set theory and (somtimes) as 'all' in\n        boolean logic.  Both keywords are accepted and treated as 'and'.\n\n    Returns\n    -------\n    An array containing the connected sites, filtered by the given logic.  If\n    ``flatten`` is ``False`` then the result is a list of lists containing the\n    neighbors of each given input bond.  In this latter case, sites that\n    have been removed by the given logic are indicated by ``nans``, thus the\n    array is of type ``float`` and is not suitable for indexing.\n\n    See Also\n    --------\n    find_complement\n\n    \"\"\"\nif am.format != 'coo':\n    raise Exception('Adjacency matrix must be in COO format')\nbonds = np.array(bonds, ndmin=1)\nif len(bonds) == 0:\n    return []\nif not istriu(am):\n    am = sp.sparse.triu(am, k=1)\nneighbors = np.hstack((am.row[bonds], am.col[bonds])).astype(np.int64)\nif neighbors.size:\n    n_sites = np.amax(neighbors)\nif logic in ['or', 'union', 'any']:\n    neighbors = np.unique(neighbors)\nelif logic in ['xor', 'exclusive_or']:\n    neighbors = np.unique(np.where(np.bincount(neighbors) == 1)[0])\nelif logic in ['xnor']:\n    neighbors = np.unique(np.where(np.bincount(neighbors) > 1)[0])\nelif logic in ['and', 'all', 'intersection']:\n    temp = np.vstack((am.row[bonds], am.col[bonds])).T.tolist()\n    temp = [set(pair) for pair in temp]\n    neighbors = temp[0]\n    [neighbors.intersection_update(pair) for pair in temp[1:]]\n    neighbors = np.array(list(neighbors), dtype=np.int64, ndmin=1)\nelse:\n    raise Exception('Specified logic is not implemented')\nif flatten is False:\n    if neighbors.size:\n        mask = np.zeros(shape=n_sites + 1, dtype=bool)\n        mask[neighbors] = True\n        temp = np.hstack((am.row[bonds], am.col[bonds])).astype(np.int64)\n        temp[~mask[temp]] = -1\n        inds = np.where(temp == -1)[0]\n        if len(inds):\n            temp = temp.astype(float)\n            temp[inds] = np.nan\n        temp = np.reshape(a=temp, newshape=[len(bonds), 2], order='F')\n        neighbors = temp\n    else:\n        neighbors = [np.array([], dtype=np.int64) for i in range(len(bonds))]\nreturn neighbors\n"
}
{
    "functionName": "CRF_forward_nobatch",
    "className": null,
    "fileName": "/david-leon_&_Dandelion/test_&_test_ChainCRF.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "\"\"\"\n    Takes as input:\n        [DV]  (T+2, N+2), (N+2, N+2)\n        - observations, sequence of shape (n_steps, n_classes)\n        - transitions, sequence of shape (n_classes, n_classes)\n    Probabilities must be given in the log space.\n    Compute alpha, matrix of size (n_steps, n_classes), such that\n    alpha[i, j] represents one of these 2 values:\n        - the probability that the real path at node i ends in j\n        - the maximum probability of a path finishing in j at node i (Viterbi)\n    Returns one of these 2 values:\n        - alpha\n        - the final probability, which can be:\n            - the sum of the probabilities of all paths\n            - the probability of the best path (Viterbi)\n    \"\"\"\nassert not return_best_sequence or viterbi and not return_alpha\ndef recurrence(obs, previous, transitions):\n    \"\"\"\n\n        :param obs: (N+2,)\n        :param previous: (N+2,)\n        :param transitions: (N+2, N+2)\n        :return:\n        \"\"\"\n    previous = previous.dimshuffle(0, 'x')\n    obs = obs.dimshuffle('x', 0)\n    if viterbi:\n        scores = previous + obs + transitions\n        out = scores.max(axis=0)\n        if return_best_sequence:\n            out2 = scores.argmax(axis=0)\n            return out, out2\n        else:\n            return out\n    else:\n        return log_sum_exp(previous + obs + transitions, axis=0)\ninitial = observations[0]\nalpha, _ = theano.scan(fn=recurrence, outputs_info=(initial, None) if\n    return_best_sequence else initial, sequences=[observations[1:]],\n    non_sequences=transitions)\nif return_alpha:\n    return alpha\nelif return_best_sequence:\n    sequence, _ = theano.scan(fn=lambda beta_i, previous: beta_i[previous],\n        outputs_info=tensor.cast(tensor.argmax(alpha[0][-1]), 'int32'),\n        sequences=tensor.cast(alpha[1][::-1], 'int32'))\n    sequence = tensor.concatenate([sequence[::-1], [tensor.argmax(alpha[0][\n        -1])]])\n    return sequence\nelif viterbi:\n    return alpha[-1].max(axis=0)\nelse:\n    return log_sum_exp(alpha[-1], axis=0)\n"
}
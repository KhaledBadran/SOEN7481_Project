{
    "functionName": "from_networkx",
    "className": "NetworkX",
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_io_&_NetworkX.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n        Add data to an OpenPNM Network from a undirected NetworkX graph object.\n\n        Parameters\n        ----------\n        G : networkx.classes.graph.Graph Object\n            The NetworkX graph. G should be undirected. The numbering of nodes\n            should be numeric (int's), zero-based and should not contain any\n            gaps, i.e. ``G.nodes() = [0,1,3,4,5]`` is not allowed and should be\n            mapped to ``G.nodes() = [0,1,2,3,4]``.\n\n        project : OpenPNM Project object\n            A GenericNetwork is created and added to the specified Project.\n            If no Project is supplied then one will be created and returned.\n\n        Returns\n        -------\n        An OpenPNM Project containing a GenericNetwork with all the data from\n        the NetworkX object.\n\n        \"\"\"\nimport networkx as nx\nnet = {}\nif not isinstance(G, nx.Graph):\n    raise 'Provided object is not a NetworkX graph.'\nif nx.is_directed(G):\n    raise 'Provided graph is directed. Convert to undirected graph.'\nif not all(isinstance(n, int) for n in G.nodes()):\n    raise 'Node numbering is not numeric. Convert to int.'\nif min(G.nodes()) != 0:\n    raise 'Node numbering does not start at zero.'\nif max(G.nodes()) + 1 != len(G.nodes()):\n    raise 'Node numbering contains gaps. Map nodes to remove gaps.'\nNp = len(G)\nnet.update({'pore.all': np.ones((Np,), dtype=bool)})\nfor n, props in G.nodes(data=True):\n    for item in props.keys():\n        val = props[item]\n        dtype = type(val)\n        for b in ['pore.', 'pore_']:\n            item = item.replace(b, '')\n        if 'pore.' + item not in net.keys():\n            if dtype == str:\n                net['pore.' + item] = np.ndarray((Np,), dtype='object')\n            elif dtype is list:\n                dtype = type(val[0])\n                if dtype == str:\n                    dtype = 'object'\n                cols = len(val)\n                net['pore.' + item] = np.ndarray((Np, cols), dtype=dtype)\n            else:\n                net['pore.' + item] = np.ndarray((Np,), dtype=dtype)\n        net['pore.' + item][n] = val\ntry:\n    conns = list(G.edges)\nexcept Exception:\n    conns = G.edges()\nconns.sort()\nNt = len(conns)\nnet.update({'throat.all': np.ones(Nt, dtype=bool)})\nnet.update({'throat.conns': np.array(conns)})\ni = 0\nfor t in conns:\n    props = G[t[0]][t[1]]\n    for item in props:\n        val = props[item]\n        dtype = type(val)\n        for b in ['throat.', 'throat_']:\n            item = item.replace(b, '')\n        if 'throat.' + item not in net.keys():\n            if dtype == str:\n                net['throat.' + item] = np.ndarray((Nt,), dtype='object')\n            if dtype is list:\n                dtype = type(val[0])\n                if dtype == str:\n                    dtype = 'object'\n                cols = len(val)\n                net['throat.' + item] = np.ndarray((Nt, cols), dtype=dtype)\n            else:\n                net['throat.' + item] = np.ndarray((Nt,), dtype=dtype)\n        net['throat.' + item][i] = val\n    i += 1\nnetwork = GenericNetwork(project=project)\nnetwork = cls._update_network(network=network, net=net)\nreturn network.project\nclassmethod"
}
{
    "functionName": "generate_base_points",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_topotools_&_topotools.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Generates a set of base points for passing into the Tessellation-based\n    Network classes.  The points can be distributed in spherical, cylindrical,\n    or rectilinear patterns, as well as 2D and 3D (disks and squares).\n\n    Parameters\n    ----------\n    num_points : scalar\n        The number of base points that lie within the domain.  Note that the\n        actual number of points returned will be larger, with the extra points\n        lying outside the domain.\n\n    domain_size : list or array\n        Controls the size and shape of the domain, as follows:\n\n        **sphere** : If a single value is received, its treated as the radius\n        [r] of a sphere centered on [0, 0, 0].\n\n        **cylinder** : If a two-element list is received it's treated as the\n        radius and height of a cylinder [r, z] positioned at [0, 0, 0] and\n        extending in the positive z-direction.  If the z dimension is 0, a\n        disk of radius r is created.\n\n        **rectangle** : If a three element list is received, it's treated\n        as the outer corner of rectangle [x, y, z] whose opposite corner lies\n        at [0, 0, 0].  If the z dimension is 0, a rectangle of size X-by-Y is\n        created.\n\n    density_map : array, optional\n        A an array that contains fractional values (0 < i < 1) indicating the\n        liklihood that a point in that region should be kept.  The size of this\n        array can be anything, but the shape must match the ``domain_size``;\n        that is for a 3D network the shape of the ``density_map`` can be\n        [10, 10, 10] or [50, 50, 50], depending on how important the resolution\n        of the density distribution is.  For a 2D network the ``density_map``\n        should be [10, 10].\n\n        When specifying a custom probabiliy map is it recommended to also set\n        values outside the given domain to zero.  If not, then the correct\n        shape will still be returned, but with too few points in it.\n\n    reflect : boolean\n        If True, the the base points are generated as specified, the reflected\n        about each face of the domain.  This essentially tricks the\n        tessellation functions into creating smooth flat faces at the\n        boundaries once these excess pores are trimmed.\n\n    Notes\n    -----\n    The reflection approach tends to create larger pores near the surfaces, so\n    it might be necessary to use the ``density_map`` argument to specify a\n    slightly higher density of points near the surfaces.\n\n    The ``Voronoi``, ``Delaunay``, ``Gabriel``, and ``DelunayVoronoiDual``\n    classes can *techncially* handle base points with spherical or cylindrical\n    domains, but the reflection across round surfaces does not create perfect\n    Voronoi cells so the surfaces will not be smooth.\n\n\n    Examples\n    --------\n    The following generates a spherical array with higher values near the core.\n    It uses a distance transform to create a sphere of radius 10, then a\n    second distance transform to create larger values in the center away from\n    the sphere surface.  These distance values could be further skewed by\n    applying a power, with values higher than 1 resulting in higher values in\n    the core, and fractional values smoothinging them out a bit.\n\n    >>> import openpnm as op\n    >>> import scipy as sp\n    >>> import scipy.ndimage as spim\n    >>> im = np.ones([21, 21, 21], dtype=int)\n    >>> im[10, 10, 10] = 0\n    >>> im = spim.distance_transform_edt(im) <= 20  # Create sphere of 1's\n    >>> prob = spim.distance_transform_edt(im)\n    >>> prob = prob / np.amax(prob)  # Normalize between 0 and 1\n    >>> pts = op.topotools.generate_base_points(num_points=50,\n    ...                                         domain_size=[1, 1, 1],\n    ...                                         density_map=prob)\n    >>> net = op.network.DelaunayVoronoiDual(points=pts, shape=[1, 1, 1])\n\n    \"\"\"\ndef _try_points(num_points, prob):\n    prob = np.atleast_3d(prob)\n    prob = np.array(prob) / np.amax(prob)\n    base_pts = []\n    N = 0\n    while N < num_points:\n        pt = np.random.rand(3)\n        [indx, indy, indz] = np.floor(pt * np.shape(prob)).astype(int)\n        if np.random.rand(1) <= prob[indx][indy][indz]:\n            base_pts.append(pt)\n            N += 1\n    base_pts = np.array(base_pts)\n    return base_pts\nif len(domain_size) == 1:\n    domain_size = np.array(domain_size)\n    r = domain_size[0]\n    if density_map is None:\n        density_map = np.ones([41, 41, 41])\n        density_map[20, 20, 20] = 0\n        density_map = spim.distance_transform_edt(density_map) < 20\n    base_pts = _try_points(num_points, density_map)\n    [X, Y, Z] = np.array(base_pts - [0.5, 0.5, 0.5]).T\n    r = 2 * np.sqrt(X ** 2 + Y ** 2 + Z ** 2) * domain_size[0]\n    theta = 2 * np.arctan(Y / X)\n    phi = 2 * np.arctan(np.sqrt(X ** 2 + Y ** 2) / Z)\n    inds = r <= domain_size[0]\n    [r, theta, phi] = [r[inds], theta[inds], phi[inds]]\n    if reflect:\n        r, theta, phi = reflect_base_points(np.vstack((r, theta, phi)),\n            domain_size)\n    X = r * np.cos(theta) * np.sin(phi)\n    Y = r * np.sin(theta) * np.sin(phi)\n    Z = r * np.cos(phi)\n    base_pts = np.vstack([X, Y, Z]).T\nelif len(domain_size) == 2:\n    domain_size = np.array(domain_size)\n    if density_map is None:\n        density_map = np.ones([41, 41, 41])\n        density_map[(20), (20), :] = 0\n        if domain_size[1] == 0:\n            density_map = density_map[:, :, (0)]\n        density_map = spim.distance_transform_edt(density_map) < 20\n    base_pts = _try_points(num_points, density_map)\n    [X, Y, Z] = np.array(base_pts - [0.5, 0.5, 0]).T\n    r = 2 * np.sqrt(X ** 2 + Y ** 2) * domain_size[0]\n    theta = 2 * np.arctan(Y / X)\n    z = Z * domain_size[1]\n    inds = r <= domain_size[0]\n    [r, theta, z] = [r[inds], theta[inds], z[inds]]\n    inds = ~((z > domain_size[1]) + (z < 0))\n    [r, theta, z] = [r[inds], theta[inds], z[inds]]\n    if reflect:\n        r, theta, z = reflect_base_points(np.vstack([r, theta, z]), domain_size\n            )\n    X = r * np.cos(theta)\n    Y = r * np.sin(theta)\n    Z = z\n    base_pts = np.vstack([X, Y, Z]).T\nelif len(domain_size) == 3:\n    if density_map is None:\n        density_map = np.ones([41, 41, 41])\n        if domain_size[2] == 0:\n            density_map = density_map[:, :, (0)]\n    base_pts = _try_points(num_points, density_map)\n    base_pts = base_pts * domain_size\n    if reflect:\n        base_pts = reflect_base_points(base_pts, domain_size)\nreturn base_pts\n"
}
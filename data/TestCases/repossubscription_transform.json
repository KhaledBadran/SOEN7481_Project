{
    "functionName": "subscription_transform",
    "className": null,
    "fileName": "/PRIArobotics_&_HedgehogServer/hedgehog_&_server_&_subscription.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"    Implements the stream transformation described in `subscription.proto`.\n    The identity transform would be `subscription_transform(stream, granularity=lambda a, b: True)`:\n    no timing behavior is added, and all values are treated as distinct, and thus emitted.\n\n    If `granularity` is not given, values are compared for equality, thus from `[0, 0, 2, 1, 1, 0, 0, 1]`,\n    elements 1, 4, and 6 would be discarded as being duplicates of their previous values.\n    A typical example granularity measure for numbers is a lower bound on value difference,\n    e.g. `lambda a, b: abs(a-b) > THRESHOLD`.\n\n    The `timeout` parameter specifies a minimum time to pass between subsequent emitted values.\n    After the timeout has passed, the most recently received value (if any) will be considered\n    as if it had just arrived on the input stream,\n    and then all subsequent values are considered until the next emission.\n    Suppose the input is [0, 1, 0, 1, 0] and the timeout is just enough to skip one value completely.\n    After emitting `0`, the first `1` is skipped, and the second `0` is not emitted because it's not a new value.\n    The second `1` is emitted; because at that time no timeout is active (the last emission was too long ago).\n    Immediately after the emission the timeout starts again, the last `0` arrives and the input stream ends.\n    Because the `0` should be emitted, the stream awaits the timeout a final time, emits the value, and then terminates.\n    Had the last value been a `1`, the output stream would have terminated immediately,\n    as the value would not be emitted.\n\n    The `granularity_timeout` parameter specifies a maximum time to pass between subsequent emitted values,\n    as long as there were input values at all.\n    The `granularity` may discard values of the input stream,\n    leading in the most extreme case to no emitted values at all.\n    If a `granularity_timeout` is given, then the most recent input value is emitted after that time,\n    restarting both the ordinary and granularity timeout in the process.\n    Suppose the input is [0, 0, 0, 1, 1, 0, 0] and the granularity timeout is just enough to skip one value completely.\n    After emitting `0` and skipping the next one, another `0` is emitted:\n    although the default granularity discarded the unchanged value, the granularity timeout forces its emission.\n    Then, the first `1` and next `0` are emitted as normal, as changed values appeared before the timeout ran out.\n    After the last `0`, the input ends.\n    The stream waits a final time for the granularity timeout, outputs the value, and then terminates.\n\n    Suppose the input is [0, 0] and the granularity timeout is so low that it runs out before the second zero.\n    The first zero is the last value seen before the granularity timeout ran out,\n    but once emitted it is out of the picture. The second zero is simply emitted as soon as it arrives.\n    \"\"\"\nif timeout is None:\n    timeout = -math.inf\nif granularity is None:\n    granularity = lambda a, b: a != b\nif granularity_timeout is None:\n    granularity_timeout = math.inf\nasync with _skipping_stream(stream) as anext:\n    value, eof = await anext()\n    if eof:\n        return\n    while True:\n        last_emit_at = trio.current_time()\n        yield value\n        if eof:\n            return\n        last_value = value\n        has_value = False\n        with trio.move_on_at(last_emit_at + granularity_timeout):\n            with trio.move_on_at(last_emit_at + timeout):\n                while not eof:\n                    _value, eof = await anext()\n                    if not eof:\n                        value = _value\n                        has_value = True\n            if eof:\n                if not has_value:\n                    return\n                elif granularity(last_value, value):\n                    await trio.sleep_until(last_emit_at + timeout)\n                    continue\n                elif granularity_timeout < math.inf:\n                    await trio.sleep_forever()\n                else:\n                    return\n            while not eof and (not has_value or not granularity(last_value,\n                value)):\n                _value, eof = await anext()\n                if not eof:\n                    value = _value\n                    has_value = True\n            if eof:\n                if not has_value:\n                    return\n                elif granularity_timeout < math.inf:\n                    await trio.sleep_forever()\n                else:\n                    return\n        if has_value:\n            continue\n        value, eof = await anext()\n        if eof:\n            return\n"
}
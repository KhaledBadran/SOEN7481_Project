{
    "functionName": "RoundBinning",
    "className": null,
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&__tools.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\" Bin points to nearest delta value in D dimensions and reorder Data.\n    \n    Args:\n        \n         - X (np.array): Input points in shape (D,N) for D dimensions.\n        \n         - deltas (float or list): binning size(s)\n        \n    Kwargs:\n        \n         - Data (list/array): List of data or data list of shape (N) to be binned like X (default None).\n        \n    Returns:\n        \n         - BinnedPoints (list): ND list of binned unique positions of points\n        \n         - indices (list): Inverse indices from which points-array can be created from unique points\n        \n         - count (list): Number of points going into each bin\n        \n        (- returnData: Rebinned data as according to points being binned) \n        \n    Algorithm takes the data points and rebins them into points closest to delta in N dimensions. If deltas=[0.05,0.05] and 2D points are given, points will be binned to closest 0.05 (...-0.1,-0.05,0.0,0.05,0.1...) in both directions. Data lists are also reshuffeled to match.\n    \n    \n    \"\"\"\npoints = np.array(X)\ndeltas = np.array([deltas]).squeeze()\nif len(deltas.shape) == 0 and points.shape[0] != 1:\n    binning = np.ones([points.shape[0], 1]) * deltas\nelse:\n    binning = np.array([deltas]).reshape(-1, 1)\n    if not points.shape[0] == binning.shape[0]:\n        raise AttributeError(\n            'Shape mismatch between X and deltas. Expected {} deltas for X with shape {}, recieved {}'\n            .format(points.shape[0], points.shape, deltas))\nbinningLog = np.log10(binning)\nbinningOrder = np.floor(binningLog)\nbinningScale = np.power(10, binningOrder - binningLog).reshape(-1, 1)\nScale = np.multiply(points, binningScale)\nbinPoints, indices, count = np.unique(np.round(Scale * np.power(10, -\n    binningOrder)), axis=1, return_inverse=True, return_counts=True)\nBinnedPoints = binPoints * np.power(10, binningOrder) / binningScale\nif not Data is None:\n    if isinstance(Data, list):\n        returnData = [np.histogram(indices, bins=BinnedPoints.shape[1],\n            weights=x)[0] for x in Data]\n    else:\n        returnData = np.histogram(indices, bins=BinnedPoints.shape[1],\n            weights=Data)[0]\n    return BinnedPoints, indices, count, returnData\nreturn BinnedPoints, indices, count\n"
}
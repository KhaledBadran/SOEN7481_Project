{
    "functionName": "vertex_dimension",
    "className": "DelaunayGeometry",
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_materials_&_VoronoiFibers.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n        Return the domain extent based on the vertices\n\n        This function is better than using the pore coords as they may be far\n        away from the original domain size.  And will alter the effective\n        properties which should be based on the original domain sizes. Takes\n        one or two sets of pores and works out different geometric properties\n        if \"length\" is specified and two lists are given the planarity is\n        determined and the appropriate length (x,y,z) is returned.\n\n        Parameters\n        ----------\n        face1 : list or array containing pore indices for a face to include in\n            calculations.\n\n        parm : string\n            Determines what information is returned:\n                volume, area (_xy, _xz, _yz), length (_x, _y, _z), minmax.\n            Default volume.\n\n        \"\"\"\nprj = self.project\nnetwork = prj.network\npores = np.array([], dtype=int)\nif 0 < len(face1):\n    pores = np.hstack((pores, face1))\nif 0 < len(face2):\n    pores = np.hstack((pores, face2))\nface1_coords = np.around(network['pore.coords'][face1], 12)\nface2_coords = np.around(network['pore.coords'][face2], 12)\nface1_planar = np.zeros(3)\nface2_planar = np.zeros(3)\nplanar = np.zeros(3)\nfor i in range(3):\n    if len(np.unique(face1_coords[:, (i)])) == 1:\n        face1_planar[i] = 1\n    if len(np.unique(face2_coords[:, (i)])) == 1:\n        face2_planar[i] = 1\nif 0 < len(face1) and 0 < len(face2):\n    planar = face1_planar * face2_planar\nelif 0 < len(face1):\n    planar = face1_planar\nelif 0 < len(face2):\n    planar = face2_planar\nelse:\n    return 0\nverts = []\nfor pore in pores:\n    for vert in np.asarray(list(self['pore.vertices'][pore])):\n        verts.append(vert)\nverts = np.asarray(verts)\nvx_min = verts[:, (0)].min()\nvx_max = verts[:, (0)].max()\nvy_min = verts[:, (1)].min()\nvy_max = verts[:, (1)].max()\nvz_min = verts[:, (2)].min()\nvz_max = verts[:, (2)].max()\noutput = 0\nwidth = np.around(vx_max - vx_min, 10)\ndepth = np.around(vy_max - vy_min, 10)\nheight = np.around(vz_max - vz_min, 10)\nif parm == 'volume':\n    output = width * depth * height\nelif parm == 'area_xy' or parm == 'area' and planar[2] == 1:\n    output = width * depth\nelif parm == 'area_xz' or parm == 'area' and planar[1] == 1:\n    output = width * height\nelif parm == 'area_yz' or parm == 'area' and planar[0] == 1:\n    output = depth * height\nelif parm == 'length_x' or parm == 'length' and planar[0] == 1:\n    output = width\nelif parm == 'length_y' or parm == 'length' and planar[1] == 1:\n    output = depth\nelif parm == 'length_z' or parm == 'length' and planar[2] == 1:\n    output = height\nelif parm == 'minmax':\n    output = [vx_min, vx_max, vy_min, vy_max, vz_min, vz_max]\nreturn output\n"
}
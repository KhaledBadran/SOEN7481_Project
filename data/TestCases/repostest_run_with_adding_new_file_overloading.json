{
    "functionName": "test_run_with_adding_new_file_overloading",
    "className": "TestPolicyDirectoryMonitor",
    "fileName": "/OpenKMIP_&_PyKMIP/kmip_&_tests_&_unit_&_services_&_server_&_test_monitor.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "\"\"\"\n        Test that the PolicyDirectoryMonitor can load policy files and track\n        them properly, even when new policy files are added overwritting\n        existing policies while tracking is active.\n        \"\"\"\nm = monitor.PolicyDirectoryMonitor(self.tmp_dir, multiprocessing.Manager().\n    dict())\nm.logger = mock.MagicMock(logging.Logger)\nm.halt_trigger = mock.MagicMock(multiprocessing.synchronize.Event)\nm.halt_trigger.is_set.side_effect = side_effects([False, build_write_effect\n    (self.tmp_dir, 'policy_3.json', POLICY_2), build_write_effect(self.\n    tmp_dir, 'policy_4.json', POLICY_3), True])\nwrite_file(self.tmp_dir, 'policy_1.json', POLICY_1)\nwrite_file(self.tmp_dir, 'policy_2.json', POLICY_2)\nself.assertEqual({}, m.file_timestamps)\nself.assertEqual({}, m.policy_cache)\nself.assertEqual([], m.policy_files)\nself.assertEqual({}, m.policy_map)\nself.assertEqual([], m.policy_store.keys())\nm.run()\nm.logger.info.assert_any_call('Starting up the operation policy file monitor.')\nm.logger.info.assert_any_call('Loading policies for file: {}'.format(os.\n    path.join(self.tmp_dir, 'policy_1.json')))\nm.logger.info.assert_any_call('Loading policy: policy_A')\nm.logger.info.assert_any_call('Loading policies for file: {}'.format(os.\n    path.join(self.tmp_dir, 'policy_2.json')))\nm.logger.info.assert_any_call('Loading policy: policy_B')\nm.logger.info.assert_any_call('Loading policy: policy_C')\nm.logger.info.assert_any_call('Loading policies for file: {}'.format(os.\n    path.join(self.tmp_dir, 'policy_3.json')))\nm.logger.info.assert_any_call('Loading policy: policy_B')\nm.logger.debug.assert_any_call(\n    \"Policy 'policy_B' overwrites an existing policy.\")\nm.logger.info.assert_any_call('Loading policy: policy_C')\nm.logger.debug.assert_any_call(\n    \"Policy 'policy_C' overwrites an existing policy.\")\nm.logger.info.assert_any_call('Loading policies for file: {}'.format(os.\n    path.join(self.tmp_dir, 'policy_4.json')))\nm.logger.info.assert_any_call('Loading policy: policy_B')\nm.logger.debug.assert_any_call(\n    \"Policy 'policy_B' overwrites an existing policy.\")\nm.logger.info.assert_any_call('Stopping the operation policy file monitor.')\nself.assertEqual(4, len(m.policy_files))\npath = os.path.join(self.tmp_dir, 'policy_1.json')\nself.assertEqual(os.path.getmtime(path), m.file_timestamps.get(path, None))\nself.assertIn(path, m.policy_files)\nself.assertEqual(path, m.policy_map.get('policy_A', None))\npath = os.path.join(self.tmp_dir, 'policy_2.json')\nself.assertEqual(os.path.getmtime(path), m.file_timestamps.get(path, None))\nself.assertIn(path, m.policy_files)\npath = os.path.join(self.tmp_dir, 'policy_3.json')\nself.assertEqual(os.path.getmtime(path), m.file_timestamps.get(path, None))\nself.assertIn(path, m.policy_files)\nself.assertEqual(path, m.policy_map.get('policy_C', None))\npath = os.path.join(self.tmp_dir, 'policy_4.json')\nself.assertEqual(os.path.getmtime(path), m.file_timestamps.get(path, None))\nself.assertIn(path, m.policy_files)\nself.assertEqual(path, m.policy_map.get('policy_B', None))\nself.assertEqual([], m.policy_cache.get('policy_A'))\ncache = m.policy_cache.get('policy_B')\nself.assertEqual(2, len(cache))\nself.assertEqual(os.path.join(self.tmp_dir, 'policy_2.json'), cache[0][1])\nself.assertEqual({'groups': {'group_B': {enums.ObjectType.SYMMETRIC_KEY: {\n    enums.Operation.GET: enums.Policy.ALLOW_ALL, enums.Operation.LOCATE:\n    enums.Policy.ALLOW_ALL, enums.Operation.DESTROY: enums.Policy.ALLOW_ALL\n    }}}}, cache[0][2])\nself.assertEqual(os.path.join(self.tmp_dir, 'policy_3.json'), cache[1][1])\nself.assertEqual({'groups': {'group_B': {enums.ObjectType.SYMMETRIC_KEY: {\n    enums.Operation.GET: enums.Policy.ALLOW_ALL, enums.Operation.LOCATE:\n    enums.Policy.ALLOW_ALL, enums.Operation.DESTROY: enums.Policy.ALLOW_ALL\n    }}}}, cache[1][2])\ncache = m.policy_cache.get('policy_C')\nself.assertEqual(1, len(cache))\nself.assertEqual(os.path.join(self.tmp_dir, 'policy_2.json'), cache[0][1])\nself.assertEqual({'groups': {'group_C': {enums.ObjectType.SYMMETRIC_KEY: {\n    enums.Operation.GET: enums.Policy.ALLOW_ALL, enums.Operation.DESTROY:\n    enums.Policy.DISALLOW_ALL}}}}, cache[0][2])\nself.assertEqual(3, len(m.policy_store.keys()))\nself.assertEqual({'groups': {'group_A': {enums.ObjectType.SYMMETRIC_KEY: {\n    enums.Operation.GET: enums.Policy.ALLOW_ALL, enums.Operation.DESTROY:\n    enums.Policy.ALLOW_ALL}}}}, m.policy_store.get('policy_A', None))\nself.assertEqual({'groups': {'group_B': {enums.ObjectType.SYMMETRIC_KEY: {\n    enums.Operation.GET: enums.Policy.DISALLOW_ALL, enums.Operation.LOCATE:\n    enums.Policy.DISALLOW_ALL, enums.Operation.DESTROY: enums.Policy.\n    DISALLOW_ALL}}}}, m.policy_store.get('policy_B', None))\nself.assertEqual({'groups': {'group_C': {enums.ObjectType.SYMMETRIC_KEY: {\n    enums.Operation.GET: enums.Policy.ALLOW_ALL, enums.Operation.DESTROY:\n    enums.Policy.DISALLOW_ALL}}}}, m.policy_store.get('policy_C', None))\n"
}
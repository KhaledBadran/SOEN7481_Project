{
    "functionName": "test_sequential_backward_selection",
    "className": null,
    "fileName": "/gelijergensen_&_PermutationImportance/test_&_test_sequential_selection.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "A = [1, 2]\nB = [2, 4]\nC = [3, 6]\nD = [1, 0]\ninputs = pd.DataFrame({'A': A, 'B': B, 'C': C})\noutputs = pd.DataFrame({'D': D})\ntraining_data = inputs, outputs\nscoring_data = inputs, outputs\ndef scoring_fn(training_data, scoring_data):\n    if len(training_data[0].columns) == 0:\n        return 0\n    elif 'A' not in training_data[0].columns:\n        return scoring_data[0].iloc[1, 0]\n    else:\n        return scoring_data[0].iloc[1, 0] / 2\nexpected = ImportanceResult('Sequential Backward Selection', ['A', 'B', 'C'], 1\n    )\nexpected.add_new_results({'A': (2, 4), 'B': (0, 1), 'C': (1, 1)})\nexpected.add_new_results({'A': (1, 6), 'C': (0, 1)})\nexpected.add_new_results({'A': (0, 0)})\nresult = sequential_backward_selection(training_data, scoring_data,\n    scoring_fn, 'argmin', njobs=2)\nassert expected.method == result.method\nassert expected.original_score == result.original_score\nassert (expected.variable_names == result.variable_names).all()\nassert expected.retrieve_singlepass() == result.retrieve_singlepass()\nassert expected.retrieve_multipass() == result.retrieve_multipass()\nfor (exp_context, exp_result), (true_context, true_result) in zip(expected,\n    result):\n    assert exp_context == true_context\n    assert exp_result == true_result\n"
}
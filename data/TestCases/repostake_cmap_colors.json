{
    "functionName": "take_cmap_colors",
    "className": null,
    "fileName": "/1313e_&_CMasher/cmasher_&_utils.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Takes `N` equally spaced colors from the provided colormap `cmap` and\n    returns them.\n\n    .. versionadded:: 1.3.2\n\n    Parameters\n    ----------\n    cmap : str or :obj:`~matplotlib.colors.Colormap` object\n        The registered name of the colormap in :mod:`matplotlib.cm` or its\n        corresponding :obj:`~matplotlib.colors.Colormap` object.\n    N : int or None\n        The number of colors to take from the provided `cmap`.\n        If *None*, take all colors in `cmap` within the provided `cmap_range`.\n\n    Optional\n    --------\n    cmap_range : tuple of float. Default: (0, 1)\n        The normalized value range in the colormap from which colors should be\n        taken.\n        By default, colors are taken from the entire colormap.\n    return_fmt : {'float'/'norm'; 'str'/'hex'; 'int'/'8bit'}. Default: 'float'\n        The format of the requested colors.\n        If 'float'/'norm', the colors are returned as normalized RGB tuples.\n        If 'str'/'hex', the colors are returned using their hexadecimal string\n        representations.\n        If 'int'/'8bit', the colors are returned as 8-bit RGB tuples.\n\n    Returns\n    -------\n    colors : list of tuple, str\n        The colors that were taken from the provided `cmap`.\n\n    Examples\n    --------\n    Taking five equally spaced colors from the 'rainforest' colormap::\n\n        >>> take_cmap_colors('cmr.rainforest', 5)\n        [(0.0, 0.0, 0.0),\n         (0.226123592, 0.124584033, 0.562997277),\n         (0.0548210513, 0.515835251, 0.45667819),\n         (0.709615979, 0.722863985, 0.0834727592),\n         (1.0, 1.0, 1.0)]\n\n    Requesting their 8-bit RGB values instead::\n\n        >>> take_cmap_colors('cmr.rainforest', 5, return_fmt='int')\n        [(0, 0, 0),\n         (58, 32, 144),\n         (14, 132, 116),\n         (181, 184, 21),\n         (255, 255, 255)]\n\n    Requesting HEX-code values instead::\n\n        >>> take_cmap_colors('cmr.rainforest', 5, return_fmt='hex')\n        ['#000000', '#3A2090', '#0E8474', '#B5B815', '#FFFFFF']\n\n    Requesting colors in a specific range::\n\n        >>> take_cmap_colors('cmr.rainforest', 5, cmap_range=(0.2, 0.8),\n                             return_fmt='hex')\n        ['#3E0374', '#10528A', '#0E8474', '#5CAD3C', '#D6BF4A']\n\n    Note\n    ----\n    Using this function on a perceptually uniform sequential colormap, like\n    those in *CMasher*, allows one to pick a number of line colors that are\n    different but still sequential. This is useful when plotting a set of lines\n    that describe the same property, but have a different initial state.\n\n    \"\"\"\nreturn_fmt = return_fmt.lower()\ncmap = mplcm.get_cmap(cmap)\nif not (0 <= cmap_range[0] <= 1 and 0 <= cmap_range[1] <= 1):\n    raise ValueError(\n        \"Input argument 'cmap_range' does not contain normalized values!\")\nstart = int(np.floor(cmap_range[0] * cmap.N))\nstop = int(np.ceil(cmap_range[1] * cmap.N)) - 1\nif N is None:\n    index = np.arange(start, stop + 1, dtype=int)\nelse:\n    index = np.array(np.rint(np.linspace(start, stop, num=N)), dtype=int)\ncolors = cmap(index)\nif return_fmt in ('float', 'norm', 'int', '8bit'):\n    colors = np.apply_along_axis(to_rgb, 1, colors)\n    if return_fmt in ('int', '8bit'):\n        colors = np.array(np.rint(colors * 255), dtype=int)\n    colors = list(map(tuple, colors))\nelse:\n    colors = list(map(lambda x: to_hex(x).upper(), colors))\nreturn colors\n"
}
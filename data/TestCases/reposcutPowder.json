{
    "functionName": "cutPowder",
    "className": null,
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Cut data powder map with intensity as function of the length of q and energy. \n\n    Args:\n\n        - positions (3 arrays): position in Qx, Qy, and E in flattend arrays.\n\n        - I (array): Flatten intensity array\n        \n        - Norm (array): Flatten normalization array\n        \n        - Monitor (array): Flatten monitor array\n        \n        - EBinEdges (list): Bin edges between which the cuts are performed.\n\n    Kwargs:\n\n        - qMinBin (float): Minimal size of binning along q (default 0.01). Points will be binned if they are closer than qMinBin.\n\n        - constantBins (bool): If True only bins of size minPixel is used (default False)\n\n    Returns:\n        \n        - Data list (pandas DataFrame): DataFrame containing qx,qy,H,K,L,Intensity,Normalization,Monitor,BinCount,Int,binDistance for powder cut.\n        \n        - qbins (n arrays): n arrays holding the bin edges along the length of q\n\n    \"\"\"\nqx, qy, energy = positions\nq = np.linalg.norm([qx, qy], axis=0)\nqbins = []\ndata = []\nfor energyBin, [binStart, binEnd] in enumerate(zip(EBinEdges, EBinEdges[1:])):\n    e_inside = np.logical_and(energy > binStart, energy <= binEnd)\n    q_inside = q[e_inside]\n    if constantBins == False:\n        qbins.append(np.array(_tools.binEdges(q_inside, tolerance=qMinBin)))\n    else:\n        Min, Max = _tools.minMax(q_inside)\n        qbins.append(np.arange(Min, Max + 0.5 * qMinBin, qMinBin))\n    intensity, bins = np.histogram(q_inside, bins=qbins[-1], weights=I[\n        e_inside].flatten())\n    monitorCount = np.histogram(q_inside, bins=qbins[-1], weights=Monitor[\n        e_inside].flatten())[0].astype(Monitor.dtype)\n    Normalization = np.histogram(q_inside, bins=qbins[-1], weights=Norm[\n        e_inside].flatten())[0].astype(Norm.dtype)\n    NormCount = np.histogram(q_inside, bins=qbins[-1], weights=np.ones_like\n        (I[e_inside]).flatten())[0].astype(I.dtype)\n    _data = pd.DataFrame(np.array([intensity, monitorCount, Normalization,\n        NormCount], dtype=np.int).T, columns=['Intensity', 'Monitor',\n        'Normalization', 'BinCount'], dtype=np.int)\n    _data['q'] = 0.5 * (bins[:-1] + bins[1:])\n    _data['Energy'] = np.ones_like(_data['q']) * 0.5 * (binStart + binEnd)\n    _data['EnergyCut'] = np.ones_like(_data['q'], dtype=np.int) * energyBin\n    data.append(_data)\ndata = pd.concat(data)\ndata['Int'] = data['Intensity'] * data['BinCount'] / (data['Normalization'] *\n    data['Monitor'])\nreturn data, qbins\n_tools.KwargChecker()"
}
{
    "functionName": "test_polynomial_model",
    "className": null,
    "fileName": "/AllenInstitute_&_EM_Aligner_python/integration_tests_&_test_transforms.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "for o in range(4):\n    t = AlignerTransform(name='Polynomial2DTransform', order=o)\n    assert t.__class__ == AlignerPolynomial2DTransform\n    assert t.order == o\nrt = renderapi.transform.AffineModel()\nfor o in range(4):\n    t = AlignerTransform(name='Polynomial2DTransform', order=o, transform=rt)\n    assert t.__class__ == AlignerPolynomial2DTransform\n    assert t.order == o\nfor order in range(4):\n    n = int((order + 1) * (order + 2) / 2)\n    params = np.zeros((2, n))\n    rt = renderapi.transform.Polynomial2DTransform(params=params)\n    t = AlignerTransform(name='Polynomial2DTransform', transform=rt)\n    nmatch = 100\n    match = example_match(nmatch)\n    ncol = 1000\n    icol = 73\n    block, weights, rhs = t.block_from_pts(np.array(match['matches']['p']).\n        transpose(), np.array(match['matches']['w']), icol, ncol)\n    assert np.all(np.isclose(rhs, 0.0))\n    assert block.check_format() is None\n    assert weights.size == nmatch\n    assert block.shape == (nmatch, ncol)\n    assert block.nnz == n * nmatch\nfor order in range(4):\n    n = int((order + 1) * (order + 2) / 2)\n    params = np.random.randn(2, n)\n    rt = renderapi.transform.Polynomial2DTransform(params=params)\n    t = AlignerTransform(name='Polynomial2DTransform', transform=rt)\n    v = t.to_solve_vec()\n    assert np.all(np.isclose(v, np.transpose(params)))\nfor order in range(4):\n    n = int((order + 1) * (order + 2) / 2)\n    v0 = np.random.randn(n, 2)\n    rt0 = renderapi.transform.Polynomial2DTransform(params=np.zeros((2, n)))\n    t = AlignerTransform(name='Polynomial2DTransform', transform=rt0)\n    assert t.order == order\n    vec = np.concatenate((v0, v0, v0, v0))\n    index = 0\n    for i in range(4):\n        index += t.from_solve_vec(vec[index:, :])\n        assert np.all(np.isclose(t.params.transpose(), v0))\nfor order in range(4):\n    n = int((order + 1) * (order + 2) / 2)\n    vec = np.zeros((n, 2))\n    rt0 = renderapi.transform.Polynomial2DTransform(params=vec)\n    t = AlignerTransform(name='Polynomial2DTransform', transform=rt0)\n    rdict = {'default_lambda': 1.0, 'translation_factor': 0.1,\n        'poly_factors': None}\n    r = t.regularization(rdict)\n    assert np.isclose(r[0], 0.1)\n    assert np.all(np.isclose(r[1:], 1.0))\nfor order in range(4):\n    n = int((order + 1) * (order + 2) / 2)\n    vec = np.zeros((n, 2))\n    rt0 = renderapi.transform.Polynomial2DTransform(params=vec)\n    t = AlignerTransform(name='Polynomial2DTransform', transform=rt0)\n    pf = np.random.randn(order + 1)\n    rdict = {'default_lambda': 1.0, 'translation_factor': 0.1,\n        'poly_factors': pf.tolist()}\n    r = t.regularization(rdict)\n    ni = 0\n    for i in range(order + 1):\n        for j in range(i + 1):\n            assert np.all(r[ni::n] == pf[i])\n            ni += 1\n"
}
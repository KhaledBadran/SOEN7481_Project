{
    "functionName": "_apply_sources",
    "className": "ReactiveTransport",
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_algorithms_&_ReactiveTransport.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"r\n        Update ``A`` and ``b`` applying source terms to specified pores\n\n        Notes\n        -----\n        - Applying source terms to ``A`` and ``b`` is performed after (optionally)\n        under-relaxing the source term to improve numerical stability. Physics\n        are also updated before applying source terms to ensure that source\n        terms values are associated with the current value of 'quantity'.\n\n        - For source term under-relaxation, old values of S1 and S2 need to be\n        stored somewhere, we chose to store them on the algorithm object. This is\n        because storing them on phase/physics creates unintended problems, ex.\n        storing them on physics -> IO complains added depth to the NestedDict, and\n        storing them on the phase object results in NaNs in case source term is\n        only added to a subset of nodes, which breaks our _check_for_nans algorithm.\n\n        Warnings\n        --------\n        In the case of a transient simulation, the updates in ``A`` and ``b``\n        also depend on the time scheme. So, ``_correct_apply_sources()`` needs to\n        be run afterwards to correct the already applied relaxed source terms.\n\n        \"\"\"\nphase = self.project.phases()[self.settings['phase']]\nw = self.settings['relaxation_source']\nfor item in self.settings['sources']:\n    element, prop = item.split('.')\n    _item = '.'.join([element, '_' + prop])\n    first_iter = False if _item + '.S1.old' in self.keys() else True\n    Ps = self.pores(item)\n    S1 = phase[item + '.S1'][Ps]\n    S2 = phase[item + '.S2'][Ps]\n    X1 = self[_item + '.S1.old'][Ps] if not first_iter else S1\n    X2 = self[_item + '.S2.old'][Ps] if not first_iter else S2\n    S1 = phase[item + '.S1'][Ps] = w * S1 + (1.0 - w) * X1\n    S2 = phase[item + '.S2'][Ps] = w * S2 + (1.0 - w) * X2\n    datadiag = self._A.diagonal().copy()\n    datadiag[Ps] = datadiag[Ps] - S1\n    self._A.setdiag(datadiag)\n    self._b[Ps] = self._b[Ps] + S2\n    self[_item + '.S1.old'] = phase[item + '.S1']\n    self[_item + '.S2.old'] = phase[item + '.S2']\n"
}
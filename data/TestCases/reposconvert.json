{
    "functionName": "convert",
    "className": "DataFile",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataFile.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "if self.instrument == 'CAMEA':\n    EPrDetector = 8\n    if binning is None:\n        binning = self.binning\nelif self.type in ['MultiFLEXX', 'FlatCone']:\n    EPrDetector = 1\n    if binning is None:\n        binning = self.binning\nelse:\n    raise AttributeError(\n        'Instrument type of data file not understood. {} was given.'.format\n        (self.instrument))\nself.loadBinning(binning)\nEfNormalization = self.instrumentCalibrationEf.copy()\nA4Normalization = self.instrumentCalibrationA4.copy()\nEdgesNormalization = self.instrumentCalibrationEdges.copy()\nData = self.I.copy()\ndetectors = Data.shape[1]\nsteps = Data.shape[0]\nif self.type in ['MultiFLEXX', 'FlatCone']:\n    Data.shape = Data.shape[0], Data.shape[1], -1\nA4Zero = self.A4Off\nif A4Zero is None:\n    A4Zero = 0.0\nelse:\n    A4Zero = np.array(A4Zero)\nA3Zero = self.A3Off\nif A3Zero is None:\n    A3Zero = 0.0\nelse:\n    A3Zero = np.deg2rad(np.array(A3Zero))\nA4 = np.deg2rad(A4Normalization)\nA4 = A4.reshape(detectors, binning * EPrDetector, order='C')\nPixelEdge = EdgesNormalization.reshape(detectors, EPrDetector, binning, 2\n    ).astype(int)\nA4File = self.A4.copy()\nA4File = A4File.reshape((-1, 1, 1))\nA4Mean = A4.reshape((1, detectors, binning * EPrDetector)) + np.deg2rad(\n    A4File - A4Zero)\nIntensity = np.zeros((Data.shape[0], Data.shape[1], EPrDetector * binning),\n    dtype=int)\nfor i in range(detectors):\n    for j in range(EPrDetector):\n        for k in range(binning):\n            Intensity[:, (i), (j * binning + k)] = np.sum(Data[:, (i),\n                PixelEdge[i, j, k, 0]:PixelEdge[i, j, k, 1]], axis=1)\nEfMean = EfNormalization[:, (1)].reshape(1, A4.shape[0], EPrDetector * binning)\nEfNormalization = EfNormalization[:, (0)]\nEfNormalization.shape = 1, A4.shape[0], EPrDetector * binning\nA3 = np.deg2rad(np.array(self.A3).copy()) + A3Zero\nif A3.shape[0] == 1:\n    A3 = A3 * np.ones(steps)\nA3.resize((steps, 1, 1))\nEi = self.Ei.copy().reshape(-1, 1, 1)\nif False:\n    kf = factorsqrtEK * np.sqrt(EfMean)\n    ki = factorsqrtEK * np.sqrt(Ei).reshape(-1, 1, 1)\n    Qx = ki - kf * np.cos(A4Mean)\n    Qy = -kf * np.sin(A4Mean)\n    QX = Qx * np.cos(A3) - Qy * np.sin(A3)\n    QY = Qx * np.sin(A3) + Qy * np.cos(A3)\nelse:\n    UB = self.sample.orientationMatrix\n    UBINV = np.linalg.inv(UB)\n    HKL, QX, QY = TasUBlib.calcTasQH(UBINV, [np.rad2deg(A3), np.rad2deg(\n        A4Mean)], Ei, EfMean)\n    H, K, L = np.swapaxes(np.swapaxes(HKL, 1, 2), 0, 3)\n    self.sample.B = TasUBlib.calculateBMatrix(self.sample.cell)\nDeltaE = Ei - EfMean\nif DeltaE.shape[0] == 1:\n    DeltaE = DeltaE * np.ones((steps, 1, 1))\nMonitor = self.Monitor.copy().reshape((steps, 1, 1))\nMonitor = Monitor * np.ones((1, detectors, EPrDetector * binning))\nNormalization = EfNormalization * np.ones((steps, 1, 1))\nconvFile = DataFile(self)\nupdateDict = {'I': Intensity, 'Monitor': Monitor, 'qx': QX, 'qy': QY,\n    'energy': DeltaE, 'binning': binning, 'Norm': Normalization, 'h': H,\n    'k': K, 'l': L, 'type': 'nxs', 'fileLocation': None, 'original_file':\n    self, 'name': self.name.replace('.hdf', '.nxs')}\nconvFile.updateProperty(updateDict)\nif convFile.type == 'nxs' and convFile.binning == 8:\n    convFile.mask = np.zeros_like(convFile.I, dtype=bool)\n    convFile.mask[:, :, :2] = True\nreturn convFile\n_tools.KwargChecker()"
}
{
    "functionName": "make_montage",
    "className": null,
    "fileName": "/nipy_&_PySurfer/surfer_&_viz.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Save montage of current figure\n\n    Parameters\n    ----------\n    filename : str\n        The name of the file, e.g, 'montage.png'. If None, the image\n        will not be saved.\n    fnames : list of str | list of array\n        The images to make the montage of. Can be a list of filenames\n        or a list of image data arrays.\n    orientation : 'h' | 'v' | list\n        The orientation of the montage: horizontal, vertical, or a nested\n        list of int (indexes into fnames).\n    colorbar : None | list of int\n        If None remove colorbars, else keep the ones whose index\n        is present.\n    border_size : int\n        The size of the border to keep.\n\n    Returns\n    -------\n    out : array\n        The montage image data array.\n    \"\"\"\ntry:\n    import Image\nexcept (ValueError, ImportError):\n    from PIL import Image\nfrom scipy import ndimage\nfnames = [(f if isinstance(f, string_types) else f.copy()) for f in fnames]\nif isinstance(fnames[0], string_types):\n    images = list(map(Image.open, fnames))\nelse:\n    images = list(map(Image.fromarray, fnames))\nboxes = []\nfor ix, im in enumerate(images):\n    gray = np.sum(np.array(im), axis=-1)\n    gray[gray == gray[0, 0]] = 0\n    if np.all(gray == 0):\n        raise ValueError('Empty image (all pixels have the same color).')\n    labels, n_labels = ndimage.label(gray.astype(np.float))\n    slices = ndimage.find_objects(labels, n_labels)\n    if colorbar is not None and ix in colorbar:\n        slices_a = np.array([[[xy.start, xy.stop] for xy in s] for s in slices]\n            )\n        mins = np.min(slices_a[:, :, (0)], axis=0)\n        maxs = np.max(slices_a[:, :, (1)], axis=0)\n        s = slice(mins[0], maxs[0]), slice(mins[1], maxs[1])\n    else:\n        s = slices[0]\n    boxes.append([s[1].start - border_size, s[0].start - border_size, s[1].\n        stop + border_size, s[0].stop + border_size])\nif orientation == 'h':\n    orientation = [range(len(images))]\nelif orientation == 'v':\n    orientation = [[i] for i in range(len(images))]\nn_rows = len(orientation)\nn_cols = max(len(row) for row in orientation)\nif n_rows > 1:\n    min_left = min(box[0] for box in boxes)\n    max_width = max(box[2] for box in boxes)\n    for box in boxes:\n        box[0] = min_left\n        box[2] = max_width\nif n_cols > 1:\n    min_top = min(box[1] for box in boxes)\n    max_height = max(box[3] for box in boxes)\n    for box in boxes:\n        box[1] = min_top\n        box[3] = max_height\ncropped_images = []\nfor im, box in zip(images, boxes):\n    cropped_images.append(im.crop(box))\nimages = cropped_images\nrow_w = [sum(images[i].size[0] for i in row) for row in orientation]\nrow_h = [max(images[i].size[1] for i in row) for row in orientation]\nout_w = max(row_w)\nout_h = sum(row_h)\nnew = Image.new('RGBA', (out_w, out_h))\ny = 0\nfor row, h in zip(orientation, row_h):\n    x = 0\n    for i in row:\n        im = images[i]\n        pos = x, y\n        new.paste(im, pos)\n        x += im.size[0]\n    y += h\nif filename is not None:\n    new.save(filename)\nreturn np.array(new)\n"
}
{
    "functionName": "boundaryQ",
    "className": null,
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Calculate the boundary of a given scan in Q space\n    A4Extend: in degrees\n    A3Extend: in degrees\n    \"\"\"\nenergy = file.energy[:, (0), (0), :, :]\nA3 = file.A3 + file.A3Off\nA4 = file.A4 - file.A4Off\nEi = file.Ei\nInstrumentA4 = file.instrumentCalibrationA4.reshape(energy.shape[1], -1)[:,\n    (plane)]\nfactorsqrtEK = 0.694692\nInstA4 = (InstrumentA4 - A4) * np.pi / 180.0\nA4Min = np.min(InstA4, axis=0)\nA4Max = np.max(InstA4, axis=0)\nInstrumentEnergy = IC[:, (4)].reshape(energy.shape[1], -1)[:, (plane)]\nkf = np.sqrt(InstrumentEnergy) * factorsqrtEK\nkfmin = np.min(kf, axis=0)\nkfmax = np.max(kf, axis=0)\nif not isinstance(kfmin, list):\n    kfmin = np.array([kfmin])\n    kfmax = np.array([kfmax])\n    A4Min = np.array([A4Min])\n    A4Max = np.array([A4Max])\nkfmin.shape = -1\nkfmax.shape = -1\nA4Min.shape = -1\nA4Max.shape = -1\nA4Min -= A4Extend * np.pi / 180.0\nA4Max += A4Extend * np.pi / 180.0\nA3 = np.linspace(np.min(A3) - A3Extend, np.max(A3) + A3Extend, len(A3))\nki = np.sqrt(Ei) * factorsqrtEK\nqxInner = ki - kfmin * np.cos(A4Min)\nqyInner = -kfmin * np.sin(A4Min)\nqxOuter = ki - kfmax * np.cos(A4Max)\nqyOuter = -kfmax * np.sin(A4Max)\nQInner = np.zeros((qxInner.shape[0], 2, len(A3)))\nQOuter = np.zeros_like(QInner)\nfor i in range(len(qxInner)):\n    QInner[i, 0] = qxInner[i] * np.cos(A3 * np.pi / 180.0) - qyInner[i\n        ] * np.sin(A3 * np.pi / 180.0)\n    QInner[i, 1] = qyInner[i] * np.cos(A3 * np.pi / 180.0) + qxInner[i\n        ] * np.sin(A3 * np.pi / 180.0)\n    QOuter[i, 0] = qxOuter[i] * np.cos(A3 * np.pi / 180.0) - qyOuter[i\n        ] * np.sin(A3 * np.pi / 180.0)\n    QOuter[i, 1] = qyOuter[i] * np.cos(A3 * np.pi / 180.0) + qxOuter[i\n        ] * np.sin(A3 * np.pi / 180.0)\nA4Values = np.array([np.linspace(A4Min[i], A4Max[i], 50) for i in range(len\n    (A4Min))])\nkfValues = np.array([np.linspace(kfmin[i], kfmax[i], 50) for i in range(len\n    (kfmin))])\nQStart = np.array([ki - kfValues * np.cos(A4Values), -kfValues * np.sin(\n    A4Values)])\nQxStartA3 = QStart[0] * np.cos(A3[0] * np.pi / 180.0) - QStart[1] * np.sin(\n    A3[0] * np.pi / 180.0)\nQxStopA3 = QStart[0] * np.cos(A3[-1] * np.pi / 180.0) - QStart[1] * np.sin(\n    A3[-1] * np.pi / 180.0)\nQyStartA3 = QStart[1] * np.cos(A3[0] * np.pi / 180.0) + QStart[0] * np.sin(\n    A3[0] * np.pi / 180.0)\nQyStopA3 = QStart[1] * np.cos(A3[-1] * np.pi / 180.0) + QStart[0] * np.sin(\n    A3[-1] * np.pi / 180.0)\nreturn np.array([np.concatenate([np.flip(QInner[:, (0), :], axis=1)[:, :-1],\n    QxStartA3[:, :-1], QOuter[:, (0), :-1], np.flip(QxStopA3, axis=1)[:, :-\n    1]], axis=-1), np.concatenate([np.flip(QInner[:, (1), :], axis=1)[:, :-\n    1], QyStartA3[:, :-1], QOuter[:, (1), :-1], np.flip(QyStopA3, axis=1)[:,\n    :-1]], -1)])\n_tools.KwargChecker()"
}
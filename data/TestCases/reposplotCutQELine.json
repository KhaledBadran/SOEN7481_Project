{
    "functionName": "plotCutQELine",
    "className": "DataSet",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Plotting wrapper for the cutQELine method. Plots the scattering intensity as a function of Q and E for cuts between specified Q-points.\n        \n        Args:\n            \n            - QPoints (list): List of Q points in either RLU (3D) or QxQy (2D).\n            \n            - EnergyBins (list): List of bin edges in the energy direction.\n        \n        Kwargs:\n            \n            - width (float): Width perpendicular to Q-direction for cuts (default 0.1)\n\n            - minPixel (float): Minimum size of pixel for cut (default 0.01)\n            \n            - rlu (bool): If True, provided points are interpreted as (h,k,l) otherwise (qx,qy), (default RLU)\n            \n            - ax (matplotlib axis): Axis into whiht the data is plotted. If None a new will be created (default None).\n            \n            - dataFiles (DataFile(s)): DataFile or list of, from which data is to be taken. If None all datafiles in self is taken (default None).\n            \n            - vmin (float): Lower limit for colorbar (default min(Intensity)).\n            \n            - vmax (float): Upper limit for colorbar (default max(Intensity)).\n            \n            - tickRound (int): Number of decimals ticks are rounded to (default 3).\n            \n            - ticks (int): Number of ticks in plot, minimum equal to number of Q points (default 8).\n            \n            - plotSeperator (bool): If true, vertical lines are plotted at Q points (default True).\n            \n            - seperatorWidth (float): Width of seperator line (default 2).\n            \n            - log (bool): If true the plotted intensity is the logarithm of the intensity (default False)\n\n            - constantBins (bool): If True only bins of size minPixel is used (default False)\n\n        Return:  m = Q points, n = energy bins\n            \n            - ax: matplotlib axis in which the data is plotted\n            \n            - Data list (pandas DataFrame): DataFrame containing qx,qy,H,K,L,Intensity,Normalization,Monitor,BinCount,Int,binDistance for all 2D cuts.\n                \n            - Bin list (m * n * 3 arrays): n instances of bin edge positions in plane of size (m+1,3), orthogonal positions of bin edges in plane of size (2,2), and energy edges of size (2).\n            \n            - center position (m * n * 3D arrays): n instances of center positions for the bins.\n\n            - binDistance (m * n arrays): n instances of arrays holding the distance in q to q1.\n\n        .. note::\n            \n            The ax.set_clim function is created to change the colour scale. It takes inputs vmin,vmax. This function does however not work in 3D....\n\n        \"\"\"\nif not isinstance(EnergyBins, np.ndarray):\n    EnergyBins = np.array(EnergyBins)\nDataList, BinListTotal, centerPositionTotal, binDistanceTotal = self.cutQELine(\n    QPoints=QPoints, EnergyBins=EnergyBins, width=width, minPixel=minPixel,\n    rlu=rlu, dataFiles=dataFiles, constantBins=constantBins)\nif rlu == True:\n    positions = self.convertToQxQy(QPoints)\nelse:\n    positions = QPoints\nif ax is None:\n    plt.figure()\n    ax = plt.gca()\n    _3D = False\nelse:\n    ax = ax\n    if not hasattr(ax, 'name'):\n        _3D = False\n    elif ax.name == '3d':\n        _3D = True\n    else:\n        _3D = False\nif not 'log' in kwargs:\n    log = False\nelse:\n    log = kwargs['log']\n    del kwargs['log']\nif 'vmin' in kwargs:\n    vmin = kwargs['vmin']\nelif hasattr(ax, 'vmin'):\n    vmin = ax.vmin\nelif log == True:\n    vmin = np.log10(DataList['Int'].min() + 1e-20)\nelse:\n    vmin = DataList['Int'].min()\nif 'vmax' in kwargs:\n    vmax = kwargs['vmax']\nelif hasattr(ax, 'vmax'):\n    vmax = ax.vmax\nelif log == True:\n    vmax = np.log10(DataList['Int'].max() + 1e-20)\nelse:\n    vmax = DataList['Int'].max()\nif _3D == False:\n    if len(EnergyBins.shape) == 1 and not isinstance(EnergyBins[0], (list,\n        np.ndarray)):\n        if not len(QPoints) == 2:\n            EnergyBins = np.array([EnergyBins for x in range(len(QPoints) - 1)]\n                )\n        else:\n            EnergyBins = np.array(EnergyBins).reshape(1, -1)\n    emptyCuts = [(len(cut) == 0) for cut in binDistanceTotal]\n    emptyIndex = np.arange(len(binDistanceTotal), dtype=int)[emptyCuts]\n    if len(emptyIndex) != 0:\n        string = [\n            'No data points found between {} and {} with energies between {} and {}.'\n            .format(QPoints[idx], QPoints[idx + 1], EnergyBins[0],\n            EnergyBins[-1]) for idx in emptyIndex]\n        raise AttributeError('\\n'.join([x for x in string]))\n    BinNums = [np.max([np.max(binDistanceTotal[i][j]) for j in range(len(\n        binDistanceTotal[i]))]) for i in range(len(binDistanceTotal))]\n    if not 'ticks' in kwargs:\n        ticks = 8\n    else:\n        ticks = kwargs['ticks']\n        kwargs = _tools.without_keys(dictionary=kwargs, keys='ticks')\n    NumQPointTicks = len(QPoints)\n    if NumQPointTicks > ticks:\n        ticks = NumQPointTicks\n    freeTicks = ticks - NumQPointTicks\n    ticksInSegments = np.ones(len(BinNums), dtype=int)\n    for i in range(freeTicks):\n        TickDistance = BinNums / ticksInSegments\n        arg = np.argmax(TickDistance)\n        ticksInSegments[arg] += 1\n    if not 'tickRound' in kwargs:\n        tickRound = 3\n    else:\n        tickRound = kwargs['tickRound']\n        del kwargs['tickRound']\n    if not 'plotSeperator' in kwargs:\n        plotSeperator = True\n    else:\n        plotSeperator = kwargs['plotSeperator']\n        del kwargs['plotSeperator']\n    if not 'seperatorWidth' in kwargs:\n        seperatorWidth = 2\n    else:\n        seperatorWidth = kwargs['seperatorWidth']\n        del kwargs['seperatorWidth']\n    if not 'colorbar' in kwargs:\n        colorbar = True\n    else:\n        colorbar = kwargs['colorbar']\n        del kwargs['colorbar']\n    pmeshs = []\n    xticks = []\n    xticklabels = []\n    IntTotal = []\n    offset = [0.0]\n    idmax = len(BinListTotal)\n    edgeQDistance = []\n    actualEnergy = []\n    qstart = []\n    qstop = []\n    direction = []\n    distanceChange = []\n    for BLT in BinListTotal:\n        localE = []\n        for BLTSub in BLT:\n            localE.append(BLTSub[2][0])\n        localE.append(BLT[-1][2][1])\n        actualEnergy.append(localE)\n    for segID in range(idmax):\n        BinList = BinListTotal[segID]\n        centerPosition = centerPositionTotal[segID]\n        binDistance = binDistanceTotal[segID]\n        q1 = positions[segID]\n        q2 = positions[segID + 1]\n        if rlu:\n            q1 = np.dot(self.sample[0].convertHKLINV, q1)\n            q2 = np.dot(self.sample[0].convertHKLINV, q2)\n        dirvec = np.array(q2) - np.array(q1)\n        leftEdgeBins = np.array([np.dot(BL[0][(0), :len(q1)], dirvec) for\n            BL in BinList])\n        leftEdgeIndex = np.argmin(leftEdgeBins)\n        binedges = [np.linalg.norm(BL[0][:, :len(q1)] - BinList[\n            leftEdgeIndex][0][(0), :len(q1)], axis=1) for BL in BinList]\n        binenergies = [BL[2] for BL in BinList]\n        edgeQDistanceLocal = []\n        for BL in BinList:\n            p = BL[0][:, :len(q1)] - q1\n            q = np.dot(p, dirvec)\n            if not (np.sort(q) == q).all():\n                raise RuntimeError('edgeQDistance[{}] is not sorted'.format\n                    (segID))\n            edgeQDistanceLocal.append(q)\n        edgeQDistance.append(edgeQDistanceLocal)\n        localDataList = DataList[DataList['qCut'] == segID]\n        for [_, intensity], binEdge, binEnergy in zip(localDataList[['Int',\n            'energyCut']].groupby('energyCut'), binedges, binenergies):\n            if log == True:\n                pmeshs.append(ax.pcolormesh(binEdge + offset[-1], binEnergy,\n                    np.log10(intensity.T + 1e-20), **kwargs))\n            else:\n                pmeshs.append(ax.pcolormesh(binEdge + offset[-1], binEnergy,\n                    intensity.T, **kwargs))\n        if plotSeperator == True:\n            plt.plot([offset[-1], offset[-1]], [np.min(EnergyBins[segID]),\n                np.max(EnergyBins[segID])], 'k', linewidth=seperatorWidth)\n        minimalDistanceIDEnergy = np.argmin([np.min(x) for x in binDistance])\n        minimalDistanceID = np.argmin(binDistance[minimalDistanceIDEnergy])\n        maximalDistanceIDEnergy = np.argmax([np.max(x) for x in binDistance])\n        maximalDistanceID = np.argmax(binDistance[maximalDistanceIDEnergy])\n        qstart.append(centerPosition[minimalDistanceIDEnergy][\n            minimalDistanceID][:len(q1)])\n        qstop.append(centerPosition[maximalDistanceIDEnergy][\n            maximalDistanceID][:len(q1)])\n        direction.append(qstop[segID] - qstart[segID])\n        distanceChange.append(np.max(binDistance[maximalDistanceIDEnergy]) -\n            np.min(binDistance[minimalDistanceIDEnergy]))\n        if rlu:\n            qstartQ, qstopQ = [np.dot(self.sample[0].convertHKL, x) for x in\n                [qstart[segID], qstop[segID]]]\n            dirLen = np.linalg.norm(direction[segID])\n            dirLenQ = np.linalg.norm(qstopQ - qstartQ)\n            distanceChange[-1] *= dirLen / dirLenQ\n        binminmaxList = np.linspace(0, 1, 100)\n        ticksCurrentSeg = ticksInSegments[segID]\n        num = len(binminmaxList)\n        if segID == idmax - 1:\n            xvalues = np.round(np.linspace(0, num - 1, ticksCurrentSeg + 1)\n                ).astype(int)\n        else:\n            xvalues = np.round(np.linspace(0, num - 1 - int(num /\n                ticksCurrentSeg), ticksCurrentSeg)).astype(int)\n        my_xticks = []\n        for i in xvalues:\n            positionValues = binminmaxList[i] * direction[segID] + qstart[segID\n                ]\n            my_xticks.append('\\n'.join([('{:.' + str(tickRound) + 'f}').\n                format(x + 0.0) for x in positionValues]))\n        xticks.append(binminmaxList[xvalues] * distanceChange[segID] +\n            offset[segID])\n        xticklabels.append(my_xticks)\n        offset.append(offset[segID] + np.max([np.max(binedge) for binedge in\n            binedges]))\n\n    def calculateXPosition(x, ID):\n        return np.dot(x - qstart[ID], direction[ID]) / np.linalg.norm(direction\n            [ID]) ** 2 * distanceChange[ID] + offset[ID]\n    ax.converterFunction = calculateXPosition\n    if plotSeperator == True:\n        plt.plot([offset, offset], [np.min(EnergyBins[-1]), np.max(\n            EnergyBins[-1])], 'k', linewidth=seperatorWidth)\n    ax.set_xticks(np.concatenate(xticks))\n    ax.set_xticklabels(np.concatenate(xticklabels), multialignment='center',\n        ha='center')\n    ax.EnergyBins = EnergyBins\n    if rlu == True:\n        ax.set_xlabel('$Q_h$ [RLU]\\n$Q_k$ [RLU]\\n$Q_l$ [RLU]')\n    else:\n        ax.set_xlabel('$Q_x [\\\\AA^{-1}]$' + '\\n' + '$Q_y [\\\\AA^{-1}]$')\n    ax.xaxis.set_label_coords(1.15, -0.025)\n    ax.set_ylabel('E [meV]')\n    if colorbar:\n        ax.colorbar = ax.get_figure().colorbar(pmeshs[0], pad=0.1, format=\n            '%.2E')\n        ax.colorbar.set_label('$I$ [arb.u.]', rotation=270)\n    if 'pmeshs' in ax.__dict__:\n        ax.pmeshs = np.concatenate([ax.pmeshs, pmeshs], axis=0)\n    else:\n        ax.pmeshs = pmeshs\n\n    def format_coord(x, y, edgeQDistance, centerPos, EnergyBins, DataList,\n        rlu, offset, self):\n        val = calculateIndex(x, y, offset, EnergyBins, edgeQDistance,\n            DataList, textReturn=True)\n        if type(val) == str:\n            return val\n        segID, Eindex, index = val\n        dfOffset = DataList['energyCut'][DataList['qCut'] == segID].min()\n        Intensity = DataList['Int'][np.logical_and(DataList['qCut'] ==\n            segID, DataList['energyCut'] == Eindex + dfOffset)][index]\n        if rlu == False:\n            qx, qy, E = centerPos[segID][Eindex][index]\n            return ('qx = {0:.3f}, qy = {1:.3f}, E = {2:.3f}, I = {3:.3e}'.\n                format(qx + 0.0, qy + 0.0, E, Intensity))\n        else:\n            H, K, L, E = centerPos[segID][Eindex][index]\n            return (\n                'h = {0:.3f}, h = {1:.3f}, l = {2:.3f}, E = {3:.3f}, I = {4:.3e}'\n                .format(H + 0.0, K + 0.0, L + 0.0, E, Intensity))\n\n    def calculateIndex(x, y, offset, EnergyBins, edgeQDistance, DataList,\n        textReturn):\n        if x < offset[0] or x >= offset[-1]:\n            if textReturn == True:\n                return 'x out of range: {:.3}'.format(x)\n            else:\n                return -1, -1, -1\n        try:\n            segID = np.arange(len(offset) - 1)[[(x > offStart and x <\n                offStop) for offStart, offStop in zip(offset, offset[1:])]][0]\n        except IndexError:\n            if textReturn == True:\n                return 'x out of range: {:.3}'.format(x)\n            else:\n                return -1, -1, -1\n        Eindex = np.array(EnergyBins[segID]).searchsorted(y) - 1\n        minspan = np.min(np.concatenate(edgeQDistance[segID]))\n        maxspan = np.max(np.concatenate(edgeQDistance[segID]))\n        xInSegment = (x - offset[segID]) / (offset[segID + 1] - offset[segID]\n            ) * (maxspan - minspan) + minspan\n        x = xInSegment\n        if len(EnergyBins[segID]) < 2:\n            if textReturn == True:\n                return 'len(EnergyBins[{}]) < 2'.format(segID)\n            else:\n                return -1, -1, -1\n        if y < EnergyBins[segID][0] or y >= EnergyBins[segID][-1]:\n            if textReturn == True:\n                return 'E out of range {:.3}  {}..{}'.format(y, EnergyBins[\n                    0], EnergyBins[-1])\n            else:\n                return -1, -1, -1\n        if len(edgeQDistance[segID][Eindex]) < 2:\n            raise RuntimeError('len(edgeQDistance[{}][{}]) < 2'.format(\n                segID, Eindex))\n        if x < edgeQDistance[segID][Eindex][0] or x >= edgeQDistance[segID][\n            Eindex][-1]:\n            if textReturn == True:\n                return 'x out of range: {:.3}'.format(x)\n            else:\n                return -1, -1, -1\n        index = edgeQDistance[segID][Eindex].searchsorted(xInSegment) - 1\n        return segID, Eindex, index\n    ax.calculateIndex = lambda x, y: calculateIndex(x, y, offset,\n        actualEnergy, edgeQDistance, DataList, textReturn=False)\n\n    def onclick(event, ax, DataList):\n        if ax.in_axes(event):\n            try:\n                C = ax.get_figure().canvas.cursor().shape()\n            except:\n                pass\n            else:\n                if C != 0:\n                    return\n            x = event.xdata\n            y = event.ydata\n            printString = ax.format_coord(x, y)\n            segID, Eindex, index = ax.calculateIndex(x, y)\n            dfOffset = DataList['energyCut'][DataList['qCut'] == segID].min()\n            Eindex += dfOffset\n            if index < len(DataList[np.logical_and(DataList['qCut'] ==\n                segID, DataList['energyCut'] == Eindex)]) and index >= 0:\n                dataPoint = DataList[np.logical_and(DataList['qCut'] ==\n                    segID, DataList['energyCut'] == Eindex)][index]\n                if not np.any([(x == -1) for x in [segID, Eindex, index]]):\n                    cts = int(dataPoint['Intensity'])\n                    Mon = int(dataPoint['Monitor'])\n                    Norm = float(dataPoint['Normalization'])\n                    NC = int(dataPoint['BinCount'])\n                    printString += (\n                        ', Cts = {:d}, Norm = {:.3f}, Mon = {:d}, NormCount = {:d}'\n                        .format(cts, Norm, int(Mon), NC))\n            print(printString)\n    ax.format_coord = lambda x, y: format_coord(x, y, edgeQDistance,\n        centerPositionTotal, actualEnergy, DataList, rlu, offset, self)\n    ax._button_press_event = ax.figure.canvas.mpl_connect('button_press_event',\n        lambda event: onclick(event, ax, DataList))\n    ax.edgeQDistance = edgeQDistance\n    ax.offset = offset\nelse:\n\n    def set_clim_local(self, vmin, vmax):\n        color = list(ax.cmap(ax.norm(self.value, vmin, vmax)))\n        self.set_facecolor(color)\n        self.set_edgecolor(color)\n\n    def norm(x, vmin, vmax):\n        return np.divide(x - vmin, vmax)\n    ax.norm = norm\n    if not 'cmap' in kwargs:\n        ax.cmap = plt.cm.coolwarm\n    else:\n        ax.cmap = kwargs['cmap']\n        kwargs = _tools.without_keys(dictionary=kwargs, keys='cmap')\n    sfp = []\n    for bins, [_, datlist] in zip(BinListTotal, DataList.groupby('qCut')):\n        energies = len(bins)\n        energyEdges = np.array([bins[idx][2] for idx in range(energies)])\n        ELength = np.array([len(x[0][:, (0)]) for x in bins])\n        ELengthCummu = np.concatenate([[0], np.cumsum(ELength)], axis=0)\n        H = np.concatenate([bins[idx][0][:, (0)] for idx in range(energies)\n            ], axis=0)\n        K = np.concatenate([bins[idx][0][:, (1)] for idx in range(energies)\n            ], axis=0)\n        L = np.concatenate([bins[idx][0][:, (2)] for idx in range(energies)\n            ], axis=0)\n        P0, P1 = self.sample[0].calculateHKLToQxQy(H, K, L)\n        P0, P1 = np.einsum('mj,j...->m...', self.sample[0].RotMat, [P0, P1])\n        IntCommu = np.concatenate([[0], np.cumsum(ELength - 1)], axis=0)\n        E = np.concatenate([bins[idx][0][:, (3)] for idx in range(energies)\n            ], axis=0)\n        EBins = np.array([bins[idx][2] for idx in range(energies)])\n        for E in range(energies):\n            X = P0[ELengthCummu[E]:ELengthCummu[E + 1]].reshape(-1, 1).repeat(\n                2, axis=1)\n            Y = P1[ELengthCummu[E]:ELengthCummu[E + 1]].reshape(-1, 1).repeat(\n                2, axis=1)\n            Z = np.ones_like(X) * EBins[E].reshape(1, 2)\n            if IntCommu[E + 1] - IntCommu[E] == 0:\n                continue\n            normColor = datlist['Int'][IntCommu[E]:IntCommu[E + 1]].values\n            color = list(ax.cmap(ax.norm(normColor, vmin, vmax)))\n            sf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, shade=False)\n            sf.value = normColor\n            sf.set_facecolor(color)\n            sf.set_edgecolor(color)\n            sf.ax = ax\n            sf.name = str(E)\n            sfp.append(sf)\n    ax.set_xlabel('Qx [$\\\\AA^{-1}$]')\n    ax.set_ylabel('Qy [$\\\\AA^{-1}$]')\n    ax.set_zlabel('E [meV]')\n    setattr(sf.__class__, 'set_clim', set_clim_local)\n    pmeshs = np.array(sfp).flatten()\n    if 'pmeshs' in ax.__dict__:\n        ax.pmeshs = np.concatenate([ax.pmeshs, pmeshs], axis=0)\n    else:\n        ax.pmeshs = pmeshs\nax.vmin = vmin\nax.vmax = vmax\ndef set_clim(vmin, vmax, ax):\n    ax.vmin = vmin\n    ax.vmax = vmax\n    for pm in ax.pmeshs:\n        pm.set_clim(vmin, vmax)\nax.get_clim = lambda : (ax.vmin, ax.vmax)\nax.set_clim = lambda vmin, vmax: set_clim(vmin, vmax, ax)\nax.set_clim(*ax.get_clim())\nreturn ax, DataList, BinListTotal, centerPositionTotal, binDistanceTotal\n_tools.KwargChecker(include=np.concatenate([_tools.MPLKwargs, ['vmin',\n    'vmax', 'log', 'ticks', 'seperatorWidth', 'tickRound', 'plotSeperator',\n    'cmap', 'colorbar', 'edgecolors']]))"
}
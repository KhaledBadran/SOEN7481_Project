{
    "functionName": "test_BotorchModel",
    "className": "BotorchModelTest",
    "fileName": "/facebook_&_Ax/ax_&_models_&_tests_&_test_botorch_model.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "Xs1, Ys1, Yvars1, bounds, tfs, fns, mns = _get_torch_test_data(dtype=dtype,\n    cuda=cuda, constant_noise=True)\nXs2, Ys2, Yvars2, _, _, _, _ = _get_torch_test_data(dtype=dtype, cuda=cuda,\n    constant_noise=True)\nmodel = BotorchModel()\nXs2_diff = [Xs2[0] + 0.1]\nwith mock.patch(FIT_MODEL_MO_PATH) as _mock_fit_model:\n    model.fit(Xs=Xs1 + Xs2_diff, Ys=Ys1 + Ys2, Yvars=Yvars1 + Yvars2,\n        bounds=bounds, task_features=tfs, feature_names=fns, metric_names=\n        mns, fidelity_features=[])\n    _mock_fit_model.assert_called_once()\nself.assertTrue(torch.equal(model.Xs[0], Xs1[0]))\nself.assertTrue(torch.equal(model.Xs[1], Xs2_diff[0]))\nself.assertEqual(model.dtype, Xs1[0].dtype)\nself.assertEqual(model.device, Xs1[0].device)\nself.assertIsInstance(model.model, ModelListGP)\nmodel_list = model.model.models\nself.assertTrue(torch.equal(model_list[0].train_inputs[0], Xs1[0]))\nself.assertTrue(torch.equal(model_list[1].train_inputs[0], Xs2_diff[0]))\nself.assertTrue(torch.equal(model_list[0].train_targets, Ys1[0].view(-1)))\nself.assertTrue(torch.equal(model_list[1].train_targets, Ys2[0].view(-1)))\nself.assertIsInstance(model_list[0].likelihood, _GaussianLikelihoodBase)\nself.assertIsInstance(model_list[1].likelihood, _GaussianLikelihoodBase)\nwith mock.patch(FIT_MODEL_MO_PATH) as _mock_fit_model:\n    model.fit(Xs=Xs1 + Xs2, Ys=Ys1 + Ys2, Yvars=Yvars1 + Yvars2, bounds=\n        bounds, task_features=tfs, feature_names=fns, metric_names=mns,\n        fidelity_features=[])\n    _mock_fit_model.assert_called_once()\nself.assertTrue(torch.equal(model.Xs[0], Xs1[0]))\nself.assertTrue(torch.equal(model.Xs[1], Xs2[0]))\nself.assertEqual(model.dtype, Xs1[0].dtype)\nself.assertEqual(model.device, Xs1[0].device)\nself.assertIsInstance(model.model, FixedNoiseGP)\nself.assertTrue(torch.equal(model.model.train_inputs[0], Xs1[0].unsqueeze(0\n    ).expand(torch.Size([2]) + Xs1[0].shape)))\nself.assertTrue(torch.equal(model.model.train_targets, torch.cat(Ys1 + Ys2,\n    dim=-1).permute(1, 0)))\nself.assertIsInstance(model.model.likelihood, _GaussianLikelihoodBase)\ndevice = torch.device('cuda') if cuda else torch.device('cpu')\nobjective_weights = torch.tensor([1.0, 0.0], dtype=dtype, device=device)\nobjective_transform = get_objective_weights_transform(objective_weights)\ninfeasible_cost = torch.tensor(get_infeasible_cost(X=Xs1[0], model=model.\n    model, objective=objective_transform))\nexpected_infeasible_cost = -1 * torch.min(objective_transform(model.model.\n    posterior(Xs1[0]).mean - 6 * model.model.posterior(Xs1[0]).variance.\n    sqrt()).min(), torch.tensor(0.0, dtype=dtype, device=device))\nself.assertTrue(torch.abs(infeasible_cost - expected_infeasible_cost) < 1e-05)\nX = torch.tensor([[6.0, 7.0, 8.0]], dtype=dtype, device=device)\nf_mean, f_cov = model.predict(X)\nself.assertTrue(f_mean.shape == torch.Size([1, 2]))\nself.assertTrue(f_cov.shape == torch.Size([1, 2, 2]))\nobjective_weights = torch.tensor([1.0, 0.0], dtype=dtype, device=device)\noutcome_constraints = torch.tensor([[0.0, 1.0]], dtype=dtype, device=device\n    ), torch.tensor([[5.0]], dtype=dtype, device=device)\nlinear_constraints = torch.tensor([[0.0, 1.0, 1.0]]), torch.tensor([[100.0]])\nfixed_features = None\npending_observations = [torch.tensor([[1.0, 3.0, 4.0]], dtype=dtype, device\n    =device), torch.tensor([[2.0, 6.0, 8.0]], dtype=dtype, device=device)]\nn = 3\nX_dummy = torch.tensor([[[1.0, 2.0, 3.0]]], dtype=dtype, device=device)\nacqfv_dummy = torch.tensor([[[1.0, 2.0, 3.0]]], dtype=dtype, device=device)\nmodel_gen_options = {}\nwith mock.patch('ax.models.torch.botorch_defaults.optimize_acqf',\n    return_value=(X_dummy, acqfv_dummy)) as mock_optimize_acqf:\n    Xgen, wgen, gen_metadata, cand_metadata = model.gen(n=n, bounds=bounds,\n        objective_weights=objective_weights, outcome_constraints=\n        outcome_constraints, linear_constraints=linear_constraints,\n        fixed_features=fixed_features, pending_observations=\n        pending_observations, model_gen_options=model_gen_options,\n        rounding_func=dummy_func)\n    self.assertTrue(torch.equal(Xgen, X_dummy.cpu()))\n    self.assertTrue(torch.equal(wgen, torch.ones(n, dtype=dtype)))\nwith mock.patch('ax.models.torch.botorch_defaults.optimize_acqf',\n    return_value=(X_dummy, acqfv_dummy)) as mock_optimize_acqf:\n    Xgen, wgen, gen_metadata, cand_metadata = model.gen(n=n, bounds=bounds,\n        objective_weights=objective_weights, outcome_constraints=None,\n        linear_constraints=None, fixed_features=fixed_features,\n        pending_observations=pending_observations, model_gen_options={\n        'optimizer_kwargs': {'joint_optimization': True}})\n    self.assertTrue(torch.equal(Xgen, X_dummy.cpu()))\n    self.assertTrue(torch.equal(wgen, torch.ones(n, dtype=dtype)))\n    mock_optimize_acqf.assert_called_once()\nwith self.assertRaises(NotImplementedError):\n    Xgen, wgen = model.gen(n=n, bounds=bounds, objective_weights=\n        objective_weights, outcome_constraints=None, linear_constraints=\n        None, fixed_features=fixed_features, pending_observations=\n        pending_observations, model_gen_options={'optimizer_kwargs': {\n        'joint_optimization': True}}, target_fidelities={(0): 3.0})\ndummy_rounding = get_rounding_func(rounding_func=dummy_func)\nX_temp = torch.rand(1, 2, 3, 4)\nself.assertTrue(torch.equal(X_temp, dummy_rounding(X_temp)))\nxbest = model.best_point(bounds=bounds, objective_weights=objective_weights)\nxbest = model.best_point(bounds=bounds, objective_weights=objective_weights,\n    fixed_features={(0): 100.0})\nself.assertIsNone(xbest)\nwith self.assertRaises(NotImplementedError):\n    xbest = model.best_point(bounds=bounds, objective_weights=\n        objective_weights, fixed_features={(0): 100.0}, target_fidelities={\n        (0): 3.0})\nmean, variance = model.cross_validate(Xs_train=Xs1 + Xs2, Ys_train=Ys1 +\n    Ys2, Yvars_train=Yvars1 + Yvars2, X_test=torch.tensor([[1.2, 3.2, 4.2],\n    [2.4, 5.2, 3.2]], dtype=dtype, device=device))\nself.assertTrue(mean.shape == torch.Size([2, 2]))\nself.assertTrue(variance.shape == torch.Size([2, 2, 2]))\nmodel.refit_on_cv = True\nmean, variance = model.cross_validate(Xs_train=Xs1 + Xs2, Ys_train=Ys1 +\n    Ys2, Yvars_train=Yvars1 + Yvars2, X_test=torch.tensor([[1.2, 3.2, 4.2],\n    [2.4, 5.2, 3.2]], dtype=dtype, device=device))\nself.assertTrue(mean.shape == torch.Size([2, 2]))\nself.assertTrue(variance.shape == torch.Size([2, 2, 2]))\nmodel.refit_on_update = False\nmodel.update(Xs=Xs2 + Xs2, Ys=Ys2 + Ys2, Yvars=Yvars2 + Yvars2)\nimportances = model.feature_importances()\nself.assertEqual(importances.shape, torch.Size([2, 1, 3]))\nself.assertTrue(torch.equal(model.Xs[0], Xs2[0]))\nself.assertTrue(torch.equal(model.Xs[1], Xs2[0]))\nself.assertTrue(torch.equal(model.Ys[0], Ys2[0]))\nself.assertTrue(torch.equal(model.Yvars[0], Yvars2[0]))\nmodel.refit_on_update = True\nwith mock.patch(FIT_MODEL_MO_PATH) as _mock_fit_model:\n    model.update(Xs=Xs2 + Xs2, Ys=Ys2 + Ys2, Yvars=Yvars2 + Yvars2)\nunfit_model = BotorchModel()\nwith self.assertRaises(RuntimeError):\n    unfit_model.cross_validate(Xs_train=Xs1 + Xs2, Ys_train=Ys1 + Ys2,\n        Yvars_train=Yvars1 + Yvars2, X_test=Xs1[0])\nwith self.assertRaises(RuntimeError):\n    unfit_model.update(Xs=Xs1 + Xs2, Ys=Ys1 + Ys2, Yvars=Yvars1 + Yvars2)\nwith self.assertRaises(RuntimeError):\n    unfit_model.feature_importances()\ntkwargs = {'device': device, 'dtype': dtype}\ntrue_state_dict = {'mean_module.constant': [3.5004],\n    'covar_module.raw_outputscale': 2.2438,\n    'covar_module.base_kernel.raw_lengthscale': [[-0.9274, -0.9274, -0.9274\n    ]], 'covar_module.base_kernel.lengthscale_prior.concentration': 3.0,\n    'covar_module.base_kernel.lengthscale_prior.rate': 6.0,\n    'covar_module.outputscale_prior.concentration': 2.0,\n    'covar_module.outputscale_prior.rate': 0.15}\ntrue_state_dict = {key: torch.tensor(val, **tkwargs) for key, val in\n    true_state_dict.items()}\nmodel = get_and_fit_model(Xs=Xs1, Ys=Ys1, Yvars=Yvars1, task_features=[],\n    fidelity_features=[], metric_names=mns[0], state_dict=true_state_dict,\n    refit_model=False)\nfor k, v in chain(model.named_parameters(), model.named_buffers()):\n    self.assertTrue(torch.equal(true_state_dict[k], v))\ntrue_state_dict['mean_module.constant'] += 0.1\ntrue_state_dict['covar_module.raw_outputscale'] += 0.1\ntrue_state_dict['covar_module.base_kernel.raw_lengthscale'] += 0.1\nmodel = get_and_fit_model(Xs=Xs1, Ys=Ys1, Yvars=Yvars1, task_features=[],\n    fidelity_features=[], metric_names=mns[0], state_dict=true_state_dict,\n    refit_model=True)\nself.assertTrue(any(not torch.equal(true_state_dict[k], v) for k, v in\n    chain(model.named_parameters(), model.named_buffers())))\nmodel = BotorchModel(best_point_recommender=recommend_best_out_of_sample_point)\nwith mock.patch(FIT_MODEL_MO_PATH) as _mock_fit_model:\n    model.fit(Xs=Xs1 + Xs2_diff, Ys=Ys1 + Ys2, Yvars=Yvars1 + Yvars2,\n        bounds=bounds, task_features=tfs, feature_names=fns, metric_names=\n        mns, fidelity_features=[])\nwith self.assertRaises(RuntimeError):\n    xbest = model.best_point(bounds=bounds, objective_weights=objective_weights\n        )\n"
}
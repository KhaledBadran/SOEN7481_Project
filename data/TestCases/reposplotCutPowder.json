{
    "functionName": "plotCutPowder",
    "className": "DataSet",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Plotting wrapper for the cutPowder method. Generates a 2D plot of powder map with intensity as function of the length of q and energy.  \n        \n        .. note::\n            Can only perform cuts for a constant energy plane of definable width.\n        \n        Args:\n\n            - EBinEdges (list): Bin edges between which the cuts are performed.\n\n        Kwargs:\n            \n            - qMinBin (float): Minimal size of binning along q (default 0.01). Points will be binned if they are closer than qMinBin.\n            \n            - ax (matplotlib axis): Figure axis into which the plots should be done (default None). If not provided, a new figure will be generated.\n            \n            - dataFiles (list): List of dataFiles to cut (default None). If none, the ones in the object will be used.\n\n            - constantBins (bool): If True only bins of size minPixel is used (default False)\n\n            - log (bool): If true, logarithm to intensity is plotted (default False)\n\n            - colorbar (bool): If True a colorbar is added to the figure (default True)\n\n            - kwargs: All other keywords will be passed on to the ax.pcolormesh method.\n        \n        Returns:\n            \n            - ax (matplotlib axis): Matplotlib axis into which the plot was put.\n            \n            - Data list (pandas DataFrame): DataFrame containing qx,qy,H,K,L,Intensity,Normalization,Monitor,BinCount,Int,binDistance for poweder cut.\n            \n            - Bin list (3 arrays): Bin edge positions in plane of size (n+1,3), orthogonal positions of bin edges in plane of size (2,2), and energy edges of size (2).\n\n        \"\"\"\nData, qbins = self.cutPowder(EBinEdges=EBinEdges, qMinBin=qMinBin,\n    dataFiles=dataFiles, constantBins=constantBins)\nif ax is None:\n    plt.figure()\n    ax = plt.gca()\npmeshs = []\neMean = 0.5 * (EBinEdges[:-1] + EBinEdges[1:])\nfor i, dat in Data[['Int', 'EnergyCut']].groupby('EnergyCut'):\n    if len(dat) == 0:\n        continue\n    if log:\n        ints = np.log10(dat['Int'] + 1e-20).values.reshape((len(qbins[i]) -\n            1, 1)).T\n    else:\n        ints = dat['Int'].values.reshape((len(qbins[i]) - 1, 1)).T\n    pmeshs.append(ax.pcolormesh(qbins[i], [EBinEdges[i], EBinEdges[i + 1]],\n        ints, **kwargs))\ndef calculateIndex(x, y, eMean, qBin, EBinEdges):\n    if y > EBinEdges[-1] or y < EBinEdges[0]:\n        return -1, -1\n    EIndex = np.argmin(np.abs(y - eMean))\n    if x > qBin[EIndex][-1] or x < qBin[EIndex][0]:\n        return EIndex, -1\n    qIndex = np.argmin(np.abs(x - 0.5 * (qBin[EIndex][:-1] + qBin[EIndex][1:]))\n        )\n    return EIndex, qIndex\nax.calculateIndex = lambda x, y: calculateIndex(x, y, eMean, qbins, EBinEdges)\ndef format_coord(x, y, ax, dat, qbins):\n    EIndex, qIndex = ax.calculateIndex(x, y)\n    if EIndex == -1 or qIndex == -1:\n        return 'outside range'\n    Intensity = dat[dat['EnergyCut'] == EIndex]['Int'][qIndex]\n    return '|q| = {0:.3f}, E = {1:.3f}, I = {2:0.4e}'.format(qbins[EIndex][\n        qIndex], eMean[EIndex], Intensity)\nax.format_coord = lambda x, y: format_coord(x, y, ax, Data[['Int',\n    'EnergyCut']], qbins)\nax.set_xlabel('$|q| [\\\\AA^{-1}]$')\nax.set_ylabel('E [meV]')\ndef set_clim(VMin, VMax, pmesh):\n    for pm in pmeshs:\n        pm.set_clim(VMin, VMax)\nax.set_clim = lambda VMin, VMax: set_clim(VMin, VMax, pmeshs)\ndef onclick(event, ax, dat):\n    if ax.in_axes(event):\n        try:\n            c = ax.get_figure().canvas.cursor().shape()\n        except:\n            pass\n        else:\n            if c != 0:\n                return\n        x = event.xdata\n        y = event.ydata\n        printString = ax.format_coord(x, y)\n        EIndex, index = ax.calculateIndex(x, y)\n        if EIndex == -1 or index == -1:\n            return\n        _local = dat[dat['EnergyCut'] == EIndex]\n        cts = _local['Intensity'][index]\n        Mon = _local['Monitor'][index]\n        Norm = _local['Normalization'][index]\n        NC = _local['BinCount'][index]\n        printString += (\n            ', Cts = {:d}, Norm = {:.3f}, Mon = {:d}, NormCount = {:d}'.\n            format(cts, Norm, int(Mon), NC))\n        print(printString)\nif not 'vmin' in kwargs or not 'vmax' in kwargs:\n    if log:\n        minVal = np.log10(Data['Int'].min() + 1e-20)\n        maxVal = np.log10(Data['Int'].max() + 1e-20)\n    else:\n        minVal = Data['Int'].min()\n        maxVal = Data['Int'].max()\n    ax.set_clim(minVal, maxVal)\nax.pmeshs = pmeshs\nax._button_press_event = ax.figure.canvas.mpl_connect('button_press_event',\n    lambda event: onclick(event, ax, Data))\nif colorbar:\n    ax.colorbar = ax.get_figure().colorbar(ax.pmeshs[0], pad=0.1)\nreturn ax, Data, qbins\n_tools.KwargChecker(function=plt.pcolormesh, include=np.concatenate([_tools\n    .MPLKwargs, ['vmin', 'vmax', 'edgecolors']]))"
}
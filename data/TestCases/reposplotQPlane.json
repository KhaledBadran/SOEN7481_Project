{
    "functionName": "plotQPlane",
    "className": "DataSet",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Wrapper for plotting tool to show binned intensities in the Q plane between provided energies.\n            \n        Kwargs:\n            \n            - EMin (float): Lower energy limit (Default None).\n            \n            - EMax (float): Upper energy limit (Default None).\n\n            - EBins (list): List of energy bins (Default None).\n\n            - binning (str): Binning scheme, either 'xy' or 'polar' (default 'xy').\n            \n            - xBinTolerance (float): bin sizes along x direction (default 0.05). If enlargen is true, this is the minimum bin size.\n\n            - yBinTolerance (float): bin sizes along y direction (default 0.05). If enlargen is true, this is the minimum bin size.\n            \n            - enlargen (bool): If the bin sizes should be adaptive (default False). If set true, bin tolerances are used as minimum bin sizes.\n\n            - log (bool): Plot intensities as the logarithm (default False).\n            \n            - ax (matplotlib axes): Axes in which the data is plotted (default None). If None, the function creates a new axes object.\n\n            - rlu (bool): If true and axis is None, a new reciprocal lattice axis is created and used for plotting (default True).\n\n            - dataFiles (DataFile): If set, method uses these converted data files instead of the ones in self (default None)\n\n            - vmin (float): Lower limit for colorbar (default min(Intensity)).\n            \n            - vmax (float): Upper limit for colorbar (default max(Intensity)).\n\n            - colorbar (bool): If True, a colorbar is created in figure (default False)\n\n            - zorder (int): If provided decides the z ordering of plot (default 10)\n            \n            - other: Other key word arguments are passed to the pcolormesh plotting algorithm.\n            \n        Returns:\n            \n            - dataList (list): List of all data points in format [Intensity, Monitor, Normalization, Normcount]\n\n            - bins (list): List of bin edges as function of plane in format [xBins,yBins].\n\n            - ax (matplotlib axes): Returns provided matplotlib axis\n            \n        .. note::\n            The axes object has a new method denoted 'set_clim' taking two parameters (VMin and VMax) used to change axes colouring.\n            \n        .. note::\n            If a 3D matplotlib axis is provided, the planes are plotted in 3D with the provided energy bins. As the method \n            contourf is used and it needs X,Y, and Z to have same shape, x and y are found as middle of bins. \n            \n        \"\"\"\nif EMax is None or EMin is None:\n    if EBins is None:\n        raise AttributeError(\n            'Either minimal/maximal energy or the energy bins is to be given.')\n    else:\n        if len(EBins) <= 1:\n            raise AttributeError(\n                'Length of provided energy bins is {}, while at least 2 is needed! Received \"{}\"'\n                .format(len(EBins), EBins))\n        EBins = np.asarray(EBins)\nelse:\n    if EMin >= EMax:\n        raise AttributeError(\n            'Provided limits are either wrong or the same. Received EMin={} and EMax={}, expects EMin<EMax.'\n            .format(EMin, EMax))\n    EBins = np.array([EMin, EMax])\nif dataFiles is None:\n    if len(self.convertedFiles) == 0:\n        raise AttributeError(\n            'No data file to be binned provided in either input or DataSet object.'\n            )\n    else:\n        I = self.I.extractData()\n        qx = self.qx.extractData()\n        qy = self.qy.extractData()\n        energy = self.energy.extractData()\n        Norm = self.Norm.extractData()\n        Monitor = self.Monitor.extractData()\n        samples = self.sample\n        maskIndices = self.maskIndices\nelse:\n    DS = DataSet(convertedFiles=dataFiles)\n    I, qx, qy, energy, Norm, Monitor, samples, maskIndices = (DS.I, DS.qx,\n        DS.qy, DS.energy, DS.Norm, DS.Monitor, DS.sample, DS.maskIndices)\nif ax is None:\n    if rlu is True:\n        ax = self.createRLUAxes()\n    else:\n        fig, ax = plt.subplots()\n    _3D = False\nelif ax.name == '3d':\n    _3D = True\nelse:\n    _3D = False\nif rlu == True:\n    Q = [[QX, QY] for QX, QY in zip(np.split(qx, maskIndices), np.split(qy,\n        maskIndices))]\n    qx, qy = np.concatenate([np.einsum('ij,j...->i...', s.RotMat, q) for s,\n        q in zip(samples, Q)], axis=1)\nif 'zorder' in kwargs:\n    zorder = kwargs['zorder']\n    kwargs = _tools.without_keys(dictionary=kwargs, keys='zorder')\nelse:\n    zorder = 10\nif 'cmap' in kwargs:\n    cmap = kwargs['cmap']\n    kwargs = _tools.without_keys(dictionary=kwargs, keys='cmap')\nelse:\n    cmap = None\nintensity = []\nmonitorCount = []\nNormalization = []\nNormCount = []\nInt = []\nxBins = []\nyBins = []\noffset = []\npmeshs = []\nbinnings = ['xy', 'polar']\nif not binning in binnings:\n    raise AttributeError('The provided binning is not understood, should be {}'\n        .format(', '.join(binnings)))\nfor i in range(len(EBins) - 1):\n    EBinEdges = [EBins[i], EBins[i + 1]]\n    e_inside = np.logical_and(energy > EBinEdges[0], energy <= EBinEdges[1])\n    if np.sum(e_inside) == 0:\n        continue\n    if binning == 'polar':\n        x = np.arctan2(qy[e_inside], qx[e_inside])\n        bins = 20\n        if np.max(x.flatten()) + xBinTolerance > np.pi and np.min(x.flatten()\n            ) - xBinTolerance < -np.pi:\n            h = np.histogram(x.flatten(), bins=bins)\n            while np.max(h[0] == 0) == False:\n                bins *= 2\n                h = np.histogram(x.flatten(), bins=bins)\n                if bins > 200:\n                    break\n            if bins > 200:\n                offset.append(0.0)\n            else:\n                offset.append(2 * np.pi - h[1][np.argmax(h[0] == 0)])\n                x = np.mod(x + offset[-1], 2 * np.pi) - np.pi\n                offset[-1] -= np.pi\n        else:\n            offset.append(0.0)\n        y = np.linalg.norm([qx[e_inside], qy[e_inside]], axis=0)\n        if not enlargen:\n            xBins.append(np.arange(-np.pi, np.pi + xBinTolerance * 0.999,\n                xBinTolerance))\n            yBins.append(np.arange(0, np.max(y) + yBinTolerance * 0.999,\n                yBinTolerance))\n        else:\n            xBins.append(_tools.binEdges(x, tolrance=xBinTolerance))\n            yBins.append(_tools.binEdges(y, tolerance=yBinTolerance))\n    elif binning == 'xy':\n        x = qx[e_inside]\n        y = qy[e_inside]\n        if not enlargen:\n            xBins.append(np.arange(np.min(x), np.max(x) + 0.999 *\n                xBinTolerance, xBinTolerance))\n            yBins.append(np.arange(np.min(y), np.max(y) + 0.999 *\n                yBinTolerance, yBinTolerance))\n        else:\n            xBins.append(_tools.binEdges(x, tolerance=xBinTolerance))\n            yBins.append(_tools.binEdges(y, tolerance=yBinTolerance))\n    X = x.flatten()\n    Y = y.flatten()\n    intensity.append(np.histogram2d(X, Y, bins=(xBins[i], yBins[i]),\n        weights=I[e_inside])[0].astype(I.dtype))\n    monitorCount.append(np.histogram2d(X, Y, bins=(xBins[i], yBins[i]),\n        weights=Monitor[e_inside])[0].astype(Monitor.dtype))\n    Normalization.append(np.histogram2d(X, Y, bins=(xBins[i], yBins[i]),\n        weights=Norm[e_inside])[0].astype(Norm.dtype))\n    NormCount.append(np.histogram2d(X, Y, bins=(xBins[i], yBins[i]),\n        weights=np.ones_like(I[e_inside]))[0].astype(I.dtype))\n    warnings.simplefilter('ignore')\n    Int.append(np.divide(intensity[-1] * NormCount[-1], monitorCount[-1] *\n        Normalization[-1]))\n    warnings.simplefilter('once')\nif binning == 'polar':\n    Qx = [np.outer(np.cos(xBins[i] - offset[i]), yBins[i]) for i in range(\n        len(intensity))]\n    Qy = [np.outer(np.sin(xBins[i] - offset[i]), yBins[i]) for i in range(\n        len(intensity))]\nelif binning == 'xy':\n    Qx = [np.outer(xBins[i], np.ones_like(yBins[i])) for i in range(len(\n        intensity))]\n    Qy = [np.outer(np.ones_like(xBins[i]), yBins[i]) for i in range(len(\n        intensity))]\nif 'vmin' in kwargs:\n    vmin = kwargs['vmin']\n    kwargs = _tools.without_keys(dictionary=kwargs, keys='vmin')\nelse:\n    vmin = np.min([np.nanmin(intens) for intens in Int])\nif 'vmax' in kwargs:\n    vmax = kwargs['vmax']\n    kwargs = _tools.without_keys(dictionary=kwargs, keys='vmax')\nelse:\n    vmax = np.max([np.nanmax(intens) for intens in Int])\nif 'colorbar' in kwargs:\n    colorbar = kwargs['colorbar']\n    kwargs = _tools.without_keys(dictionary=kwargs, keys='colorbar')\nelse:\n    colorbar = False\npmeshs = []\nif log:\n    Int = [np.log10(1e-20 + np.array(intens)) for intens in Int]\nfor i in range(len(EBins) - 1):\n    if _3D:\n        QX = 0.25 * np.array(np.array(Qx[i])[1:, 1:] + np.array(Qx[i])[:-1,\n            1:] + np.array(Qx[i])[1:, :-1] + np.array(Qx[i])[:-1, :-1]\n            ) / xScale\n        QY = 0.25 * np.array(np.array(Qy[i])[1:, 1:] + np.array(Qy[i])[:-1,\n            1:] + np.array(Qy[i])[1:, :-1] + np.array(Qy[i])[:-1, :-1]\n            ) / yScale\n        I = np.array(Int[i])\n        levels = np.linspace(vmin, vmax, 50)\n        pmeshs.append(ax.contourf3D(QX, QY, I, zdir='z', offset=np.mean(\n            EBins[i:i + 2]), levels=levels, cmap=cmap, **kwargs))\n    else:\n        pmeshs.append(ax.pcolormesh(Qx[i], Qy[i], Int[i], zorder=zorder,\n            cmap=cmap, **kwargs))\nif not _3D:\n    ax.set_aspect('equal')\n    ax.grid(True, zorder=0)\ndef set_clim(pmeshs, vmin, vmax):\n    for pmesh in pmeshs:\n        pmesh.set_clim(vmin, vmax)\nif 'pmeshs' in ax.__dict__:\n    ax.pmeshs = np.concatenate([ax.pmeshs, np.asarray(pmeshs)], axis=0)\nelse:\n    ax.pmeshs = pmeshs\nax.set_clim = lambda vMin, vMax: set_clim(ax.pmeshs, vMin, vMax)\nif colorbar:\n    ax.colorbar = ax.get_figure().colorbar(ax.pmeshs[0], pad=0.1)\n    ax.colorbar.set_label('$I$ [arb.u.]', rotation=270)\nax.set_clim(vmin, vmax)\nif _3D:\n    minEBins = np.min(EBins)\n    maxEBins = np.max(EBins)\n    if not np.isclose(minEBins, maxEBins):\n        ax.set_zlim(minEBins, maxEBins)\n    else:\n        ax.set_zlim(minEBins - 0.1, maxEBins + 0.1)\nelse:\n\n    def onclick(ax, event, Qx, Qy, data):\n        if event.xdata is not None and ax.in_axes(event):\n            try:\n                C = ax.get_figure().canvas.cursor().shape()\n            except:\n                pass\n            else:\n                if C != 0:\n                    return\n        if not ax.in_axes(event):\n            return\n        printString = ''\n        printString += ax.format_coord(event.xdata, event.ydata) + ', '\n        QX = np.array(Qx[0])\n        QY = np.array(Qy[0])\n        Qx = 0.25 * (QX[1:, 1:] + QX[:-1, :-1] + QX[1:, :-1] + QX[:-1, 1:])\n        Qy = 0.25 * (QY[1:, 1:] + QY[:-1, :-1] + QY[1:, :-1] + QY[:-1, 1:])\n        arg = np.argmin(np.linalg.norm(np.array([Qx, Qy]) - np.array([event\n            .xdata, event.ydata]).reshape(2, 1, 1), axis=0))\n        arg2D = np.unravel_index(arg, Qx.shape)\n        cts = data[0][0][arg2D[0], arg2D[1]]\n        Norm = data[1][0][arg2D[0], arg2D[1]]\n        Mon = data[2][0][arg2D[0], arg2D[1]]\n        NC = data[3][0][arg2D[0], arg2D[1]]\n        warnings.simplefilter('ignore')\n        Intensity = np.divide(cts * NC, Norm * Mon)\n        warnings.simplefilter('once')\n        localSize = np.linalg.norm(np.array([QX[arg2D[0], arg2D[1]] - Qx[\n            arg2D[0], arg2D[1]], QY[arg2D[0], arg2D[1]] - Qy[arg2D[0],\n            arg2D[1]]]))\n        if not np.isfinite(Intensity) or np.linalg.norm(np.array([Qx[arg2D[\n            0], arg2D[1]] - event.xdata, Qy[arg2D[0], arg2D[1]] - event.ydata])\n            ) > localSize:\n            printString += 'I = NaN'\n        else:\n            printString += 'I = {:.4E}'.format(Intensity)\n            printString += (\n                ', Cts = {:d}, Norm = {:.3f}, Mon = {:d}, NormCount = {:d}'\n                .format(cts, Norm, int(Mon), NC))\n        print(printString)\n    ax.cid = ax.figure.canvas.mpl_connect('button_press_event', lambda x:\n        onclick(ax, x, Qx, Qy, [intensity, monitorCount, Normalization,\n        NormCount]))\nif len(Qx) != 0:\n    xmin = np.min([np.min(qx) for qx in Qx])\n    xmax = np.max([np.max(qx) for qx in Qx])\n    ax.set_xlim(xmin, xmax)\nif len(Qy) != 0:\n    ymin = np.min([np.min(qy) for qy in Qy])\n    ymax = np.max([np.max(qy) for qy in Qy])\n    ax.set_ylim(ymin, ymax)\nreturn [intensity, monitorCount, Normalization, NormCount], [Qx, Qy], ax\n"
}
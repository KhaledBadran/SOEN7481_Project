{
    "functionName": "plotA3A4",
    "className": null,
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Plot data files together with pixels created around each point in A3-A4 space. Data is binned in the specified planes through their A3 and A4 values. \n    This can result in distorted binning when binning across large energy regions. Data is plotted using the pixels calculated for average plane value, i.e. \n    binning 7,8,9,10, and 11 patches for plane 9 are used for plotting.\n\n    Args:\n        \n        - files (DataFiles): single file or list of files to be binned together\n\n    Kwargs:\n\n        - ax (matplotlib axis): Axis into which the planes are to be plotted (Default None, i.e. new)\n\n        - planes (list (of lists)): Planes to be plotted and binned (default [])\n\n        - binningDecimals (int): Number of decimal places A3-A4 positions are rounded before binning (default 3)\n        \n        - log (bool): Whether or not to plot intensities as logarithm (default False)\n\n        - returnPatches (bool): If true the method returns the patches otherwise plotted in the given axis (default False)\n\n        - singleFigure (bool): If true, all planes are plotted in same figure (default False)\n\n        - plotTessellation (bool): Plot Tessellation of points (default False)\n\n        - Ei_err (float): Tolerance of E_i for which the values are equal (default = 0.05)\n\n        - temperature_err (float): Tolerance of temperature for which the values are equal (default = 0.2)\n        \n        - magneticField_err (float): Tolerance of magnetic field for which the values are equal (default = 0.2)\n        \n        - electricField_err (float): Tolerance of electric field for which the values are equal (default = 0.2)\n\n    Returns:\n        \n        - ax (matplotlib axis or list of): axis (list of) containing figures for plotted planes.\n\n    Raises:\n\n        - AttributeError\n\n    Examples:\n\n    The following example will combine the two files and plot all of the available planes in different figures.\n\n    >>> DS = DataSet.DataSet(convertedFiles=[--.nxs,---.nxs])\n    >>> plt.figure()\n    >>> ax = plt.gca()\n    >>>\n    >>> DataSet.plotA3A4(DS.convertedFiles,ax=ax)\n\n    If only a subset of planes or different planes are to be combined the following will achieve this:\n\n    >>> DataSet.plotA3A4(DS.convertedFiles,ax=ax,planes=[0,1,2,3,[4,5,6],[8,9]])\n\n    Here planes 0 through 3 are plotted separately while 4,5, and 6 as well as 8 and 9 are binned.\n\n    .. note::\n        Binning planes from different analysers might result in nonsensible binnings.\n\n    \"\"\"\nif not isinstance(ax, (list,)) and ax is not None:\n    ax = np.array([ax])\nif not isinstance(planes, (list,)):\n    planes = np.array([planes])\nif not ax is None:\n    if singleFigure and np.array([ax]).size != 1:\n        raise AttributeError(\n            'Single figure chosen but multiple axes given ({}).'.format(np.\n            array([ax]).size))\n    elif not singleFigure and len(ax) != len(planes) and not len(planes) == 0:\n        raise AttributeError(\n            'Number of axes ({}) provided does not match number of planes ({}).'\n            .format(np.array([ax]).size, len(planes)))\nif not hasattr(files, 'len'):\n    files = [files]\nnumFiles = len(files)\n@_tools.my_timer_N()\ndef testFiles(files, numFiles):\n    if numFiles > 1:\n        comparison = np.array([np.all([np.isclose(files[0].Ei, files[i + 1]\n            .Ei, atol=Ei_err) for i in range(numFiles - 1)]), np.all([\n            compareNones(files[0].temperature, files[i + 1].temperature,\n            temperature_err) for i in range(numFiles - 1)]), np.all([\n            compareNones(files[0].magneticField, files[i + 1].magneticField,\n            magneticField_err) for i in range(numFiles - 1)]), np.all([\n            compareNones(files[0].electricField, files[i + 1].electricField,\n            electricField_err) for i in range(numFiles - 1)]), np.all([(\n            files[0].binning == files[i + 1].binning) for i in range(\n            numFiles - 1)])])\n        tests = np.array(['Ei', 'Temperature', 'Magnetic Field',\n            'Electric Field', 'Binning'])\n        if not np.all(comparison):\n            errors = np.array(1 - comparison, dtype=bool)\n            raise AttributeError(\n                \"\"\"Attributes for the datafiles are not the same! Difference is in :\n\"\"\"\n                 + ','.join([x for x in tests[errors]]) +\n                \"\"\"\nIf the files are to be binned anyway change the tolerence limits.\"\"\"\n                )\ntestFiles(files, numFiles)\nA4All = np.array([files[i].A4 for i in range(numFiles)])\nA3All = np.array([files[i].A3 for i in range(numFiles)])\nIshape = files[0].I.shape\nIAll = np.array([files[i].I for i in range(numFiles)])\nNormAll = np.array([files[i].Norm for i in range(numFiles)])\nMonitorAll = np.array([files[i].Monitor for i in range(numFiles)])\nif not ax is None:\n    if not singleFigure and len(ax) != Ishape[2] and len(planes) == 0:\n        raise AttributeError(\n            'Number of axes ({}) provided does not match number of planes ({}).'\n            .format(np.array([ax]).size, Ishape[2]))\nI = np.concatenate(IAll, axis=0)\nNorm = np.concatenate(NormAll, axis=0)\nMon = np.concatenate(MonitorAll, axis=0)\nA4InstrAll = -np.array([(files[i].instrumentCalibrationA4 + A4All[i]) for i in\n    range(numFiles)])\nbinning = files[0].binning\nif binning == 1:\n    if A4InstrAll.shape[1] == 155:\n        A4InstrAll = np.reshape(A4InstrAll, (numFiles, -1, 5, binning))\n    elif A4InstrAll.shape[1] == 32:\n        A4InstrAll = np.reshape(A4InstrAll, (numFiles, -1, 1, binning))\n    else:\n        A4InstrAll = np.reshape(A4InstrAll, (numFiles, -1, 8, binning))\nelse:\n    A4InstrAll = np.reshape(A4InstrAll, (numFiles, -1, 8, binning))\nA4InstrAll = A4InstrAll.reshape(numFiles, A4InstrAll[0].shape[0], -1)[:, :, (0)\n    ]\npoints = []\nfor i in range(numFiles):\n    X, Y = [x.flatten() for x in np.meshgrid(A3All[i], A4InstrAll[i],\n        indexing='ij')]\n    points.append([X, Y])\nPosAll = np.concatenate(points, axis=1)\nunique, uindex, count = np.unique(PosAll, axis=1, return_index=True,\n    return_counts=True)\nif np.sum(count > 1) > 0:\n    BoundPoly = [convexHullPoints(points[i][0].flatten(), points[i][1].\n        flatten()) for i in range(numFiles)]\n    mask = np.ones(PosAll.shape[1], dtype=bool)\n    mask[uindex] = False\n    doublePoints = PosAll[:, (mask)]\n    kdtree = KDTree(unique.T)\n    doubleIndex = kdtree.query(np.round(doublePoints, binningDecimals).T,\n        distance_upper_bound=np.power(10, -binningDecimals * 1.0) * 1.1)[1]\n    points = unique\n    shape = I.shape[2]\n    IReshape = I.reshape(-1, shape)\n    NormReshape = Norm.reshape(-1, shape)\n    MonReshape = Mon.reshape(-1, shape)\n    doubleI = IReshape[(mask), :]\n    doubleNorm = NormReshape[(mask), :]\n    doubleMon = MonReshape[(mask), :]\n    Isorted = IReshape[(uindex), :]\n    Normsorted = NormReshape[(uindex), :]\n    Monsorted = MonReshape[(uindex), :]\n    Isorted[(doubleIndex), :] += doubleI\n    Normsorted[(doubleIndex), :] = np.nanmean([Normsorted[(doubleIndex), :],\n        doubleNorm], axis=0)\n    Monsorted[(doubleIndex), :] += doubleMon\nelse:\n    BoundPoly = False\n    index = np.lexsort((unique[1], unique[0]))\n    shape = I.shape[2]\n    Isorted = np.concatenate(I, axis=0)[(index), :]\n    Normsorted = np.concatenate(Norm, axis=0)[(index), :]\n    Monsorted = np.concatenate(Mon, axis=0)[(index), :]\nif numFiles == 1:\n    points = [np.array(points).reshape(2, -1)]\n    numGroups = 1\nelse:\n    numGroups = False\npolygons, GoodPolyPoints = voronoiTessellation(points=points, plot=\n    plotTessellation, Boundary=BoundPoly, numGroups=numGroups)\ncentroids = np.array([centeroidnp(x) for x in GoodPolyPoints]).T\nif isinstance(points, list):\n    X = np.concatenate(points, axis=1).T\nelse:\n    X = points.T\nY = centroids.T\nkdtree = KDTree(X)\n_, A = kdtree.query(Y)\n_, SortUindex, SortCount = np.unique(A, return_index=True, return_counts=True)\nif np.sum(SortCount > 1) != 0:\n    raise AttributeError(\n        'The number of points connecting the centroids from Tessellation and points are not equal...'\n        )\ncentInd = SortUindex\nsortedPolyPoints = GoodPolyPoints[centInd]\nfactorsqrtEK = 0.694692\nEi = files[0].Ei\nki = np.sqrt(Ei) * factorsqrtEK\nkf = np.sqrt(Ei - files[0].energy[(0), :, :].mean(axis=0)) * factorsqrtEK\nQX = np.array([(ki - np.outer(np.cos(np.deg2rad(p[:, (1)])), kf)) for p in\n    sortedPolyPoints])\nQY = np.array([(-np.outer(np.sin(np.deg2rad(p[:, (1)])), kf)) for p in\n    sortedPolyPoints])\nTheta = np.array([(p[:, (0)].reshape((-1, 1)) * np.pi / 180.0) for p in\n    sortedPolyPoints])\nQRX = np.array([(QX[i] * np.cos(Theta[i]) - QY[i] * np.sin(Theta[i])) for i in\n    range(QX.shape[0])])\nQRY = np.array([(QY[i] * np.cos(Theta[i]) + QX[i] * np.sin(Theta[i])) for i in\n    range(QX.shape[0])])\nqxmin = np.min([np.min(val) for val in QRX])\nqymin = np.min([np.min(val) for val in QRY])\nqxmax = np.max([np.max(val) for val in QRX])\nqymax = np.max([np.max(val) for val in QRY])\nQXlim = np.max(np.abs([qxmin, qxmax]))\nQYlim = np.max(np.abs([qymin, qymax]))\nE = np.mean(files[0].energy, axis=(0, 1))\nif len(planes) == 0:\n    planes = range(len(E))\nplots = len(planes)\nif not returnPatches:\n    if ax is None:\n        if singleFigure:\n            rows, cols = figureRowColumns(plots)\n            fig, ax = plt.subplots(nrows=rows, ncols=cols)\n            ax = np.array(ax).flatten()\n    if singleFigure:\n        if ax is None:\n            ax = plt.figure().gca()\n    elif ax is None:\n        ax = [plt.figure().gca() for _ in range(plots)]\ncounter = 0\nif returnPatches:\n    ReturnPatches = []\n    Energies = []\nfor plane in planes:\n    subplanes = len(np.array([plane]).flatten())\n    if subplanes == 1:\n        plotPlane = plane\n        IntensityBin = np.divide(Isorted[:, (plane)], Normsorted[:, (plane)\n            ] * Monsorted[:, (plane)]) + 1e-20\n        IntensityBin = np.ma.masked_invalid(IntensityBin)\n    else:\n        plotPlane = int(np.mean(plane))\n        IntensityBin = np.divide(np.nansum(Isorted[:, (plane)], axis=1), np\n            .nanmean(Normsorted[:, (plane)], axis=1) * np.nansum(Monsorted[\n            :, (plane)], axis=1)) + 1e-20\n        IntensityBin = np.ma.masked_invalid(IntensityBin)\n    patches = [Polygon(np.array([qrx[:, (plotPlane)], qry[:, (plotPlane)]])\n        .T) for qrx, qry in zip(QRX, QRY)]\n    pcollection = PatchCollection(patches)\n    currentInt = IntensityBin\n    if log == True:\n        pcollection.set_array(np.log10(currentInt + 1e-20))\n    else:\n        pcollection.set_array(currentInt)\n    if returnPatches:\n        pcollection.set_edgecolor('None')\n        ReturnPatches.append(pcollection)\n        Energies.append(np.mean(E[plane]))\n    else:\n        pcollection.set_edgecolor('face')\n        currIntMin = np.max([np.nanmin(currentInt), 0.0])\n        pcollection.set_clim(currIntMin, np.nanmax(currentInt))\n        ax[counter].add_collection(pcollection)\n        ax[counter].set_xlim(-QXlim, QXlim)\n        ax[counter].set_ylim(-QYlim, QYlim)\n        ax[counter].colorbar = ax[counter].get_figure().colorbar(ax[counter\n            ].collections[0], ax=ax[counter], format=ticker.FuncFormatter(fmt))\n        ax[counter].collections[0].set_clim(currIntMin, np.max(currentInt))\n        if subplanes == 1:\n            ax[counter].set_title('Energy {0:.3f} meV - plane {1}'.format(E\n                [plotPlane], plane))\n        else:\n            ax[counter].set_title('Energy {0:.3f} meV - planes '.format(np.\n                mean(E[plane])) + ','.join([str(x) for x in plane]))\n        counter += 1\nif returnPatches:\n    return ReturnPatches, Energies\nelse:\n    return ax\n_tools.KwargChecker()"
}
{
    "functionName": "calculateDetectorAnalyserPositions",
    "className": "Wedge",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Geometry_&_Wedge.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Find neutron position on analyser and detector. Assuming that the analyser is in the z=0 plane.\"\"\"\nif len(self.detectors) == 0 or len(self.analysers) == 0:\n    raise ValueError('Wedge does not contain detectors and/or analysers.')\ndetectorPixelPositions = []\nanalyserPixelPositions = []\nif self.settings['concept'] == 'OneToOne':\n    if len(self.detectors) != len(self.analysers):\n        raise RuntimeError(\n            'Concept set to OneToOne but number of detectors does not mach analysers ({}!?{}'\n            .format(len(self.detectors), len(self.analysers)))\n    detectorCounter = 0\n    for det in self.detectors:\n        PixelPos = det.getPixelPositions() + self.position\n        if len(PixelPos) != 1:\n            raise ValueError(\n                'OneToOne concept chosen by detector split into multiple parts!'\n                )\n        detectorPixelPositions.append(PixelPos)\n        LDA = PixelPos[0] - self.analysers[detectorCounter].position\n        LAS = self.analysers[detectorCounter].position + self.position\n        vertical = np.array([0, 0, 1])\n        perpVect = np.cross(vertical, LAS)\n        deltaXD = np.dot(PixelPos, perpVect)\n        LD = np.linalg.norm(LDA, axis=1)\n        LA = np.linalg.norm(LAS)\n        deltaXDprime = deltaXD / (LD / LA + 1.0)\n        analyserPixelPositions.append(np.outer(deltaXDprime, perpVect) +\n            self.analysers[detectorCounter].position + self.position)\n        detectorCounter += 1\nelif self.settings['concept'] == 'ManyToMany':\n    for det in self.detectors:\n        PixelPos = [(x + self.position) for x in det.getPixelPositions()]\n        if len(PixelPos) != len(self.analysers):\n            raise ValueError(\n                'ManyToMany concept chosen by detector split into number of parts not matching number of analysers!'\n                )\n        detectorPixelPositions.append(np.concatenate(PixelPos))\n        vertical = np.array([0, 0, 1])\n        LAS = [(self.analysers[i].position + self.position) for i in range(\n            len(PixelPos))]\n        perpVect = [(np.cross(vertical, LAS[i]) / np.linalg.norm(np.cross(\n            vertical, LAS[i]))) for i in range(len(PixelPos))]\n        deltaXD = [np.dot(PixelPos[i], perpVect[i]) for i in range(len(\n            PixelPos))]\n        LDA = [(np.array(PixelPos[i]) - np.array(deltaXD[i]).reshape(-1, 1) *\n            np.array(perpVect[i]).reshape(1, 3) - self.analysers[i].\n            position) for i in range(len(PixelPos))]\n        LD = [np.linalg.norm(LDA[i], axis=1) for i in range(len(PixelPos))]\n        LA = [np.linalg.norm(LAS[i]) for i in range(len(PixelPos))]\n        deltaXDprime = [(deltaXD[i] / (LD[i] / LA[i] + 1.0)) for i in range\n            (len(PixelPos))]\n        analyserPixelPositions.append(np.concatenate([(np.outer(\n            deltaXDprime[i], perpVect[i]) + self.analysers[i].position +\n            self.position) for i in range(len(PixelPos))]))\nelse:\n    raise ValueError(\n        \"Wedge does not contain a Concept setting that is understood. Should be either 'OneToOne' or 'ManyToMany'\"\n        )\nreturn detectorPixelPositions, analyserPixelPositions\n"
}
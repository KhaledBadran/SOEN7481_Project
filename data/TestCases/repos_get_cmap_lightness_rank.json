{
    "functionName": "_get_cmap_lightness_rank",
    "className": null,
    "fileName": "/1313e_&_CMasher/cmasher_&_utils.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Returns a tuple of objects used for sorting the provided `cmap` based\n    on its lightness profile.\n\n    Parameters\n    ----------\n    cmap : str or :obj:`~matplotlib.colors.Colormap` object\n        The registered name of the colormap in :mod:`matplotlib.cm` or its\n        corresponding :obj:`~matplotlib.colors.Colormap` object.\n\n    Returns\n    -------\n    L_type : int\n        The type of lightness profile of `cmap`.\n        This is only used for sequential colormaps.\n    L_start : float\n        The starting lightness value of `cmap`.\n        For diverging colormaps, this is the central lightness value.\n    L_rng : float\n        The lightness range (L_max-L_min) of `cmap`.\n    L_rmse : float\n        The RMSE of the lightness profile of `cmap`.\n        For diverging colormaps, this is the max RMSE of either half.\n    name : str\n        The name of `cmap`.\n        For qualitative and miscellaneous colormaps, this is the only value\n        that is used.\n\n    \"\"\"\ncmap = mplcm.get_cmap(cmap)\nrgb = cmap(np.arange(cmap.N))[:, :3]\nlab = cspace_converter('sRGB1', 'CAM02-UCS')(rgb)\nL = lab[:, (0)]\ndeltas = np.diff(L)\nderivs = (cmap.N - 1) * deltas\nL_type = 0\nif get_cmap_type(cmap) == 'sequential':\n    L_rmse = np.around(np.std(derivs), 1)\n    L_start = np.around(L[0], 1)\n    L_type += ~(np.sum(rgb[0]) == 0) * 2\n    L_type += (np.sum(rgb[0]) == 0) == (np.sum(rgb[-1]) == 3)\nelif get_cmap_type(cmap) in ('diverging', 'cyclic'):\n    central_i = [int(np.floor(cmap.N / 2)), int(np.ceil(cmap.N / 2))]\n    L_rmse = np.max([np.around(np.std(derivs[:central_i[0]]), 1), np.around\n        (np.std(derivs[central_i[1]:]), 1)])\n    L_start = np.around(np.average(L[central_i]), 1)\nif get_cmap_type(cmap) in ('sequential', 'diverging', 'cyclic'):\n    L_min = np.around(np.min(L), 1)\n    L_max = np.around(np.max(L), 1)\n    L_rng = np.around(np.abs(L_max - L_min), 1)\nelse:\n    L_type = L_start = L_rng = L_rmse = 0\nreturn L_type, L_start, L_rng, L_rmse, cmap.name\n"
}
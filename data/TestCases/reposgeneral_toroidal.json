{
    "functionName": "general_toroidal",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_models_&_physics_&_meniscus.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    The general model for meniscus properties inside a toroidal throat\n\n    Parameters\n    ----------\n    target : OpenPNM Object\n        The object for which these values are being calculated.  This\n        controls the length of the calculated array, and also provides\n        access to other necessary thermofluid properties.\n\n    profile_equation : string (Default is 'elliptical')\n        options elliptical, sinusoidal.\n\n    mode : string (Default is 'max')\n        Determines what information to send back. Options are:\n        'max' : the maximum capillary pressure along the throat axis\n        'touch' : the maximum capillary pressure a meniscus can sustain before\n                  touching a solid feature\n        None : return the meniscus info for a target pressure\n\n    target_Pc : float\n        The target capillary pressure to return data for when mode is 'men'\n\n    num_points : float (Default 100)\n        The number of divisions to make along the profile length to assess the\n        meniscus properties in order to find target pressures, touch lengths,\n        minima and maxima.\n\n    throat_scale_a : dict key (string)\n        The dictionary key containing the scale factor for adjusting the\n        profile along the throat axis (x).\n\n    throat_scale_b : dict key (string)\n        The dictionary key containing the scale factor for adjusting the\n        profile perpendicular to the throat axis (y).\n\n    throat_diameter : dict key (string)\n        The dictionary key containing the throat diameter values to be used.\n\n    touch_length : dict key (string)\n        The dictionary key containing the maximum length that a meniscus can\n        protrude into the connecting pore before touching a solid feature and\n        therfore invading\n\n    surface_tension : dict key (string)\n        The dictionary key containing the surface tension values to be used. If\n        a pore property is given, it is interpolated to a throat list.\n\n    contact_angle : dict key (string)\n        The dictionary key containing the contact angle values to be used. If\n        a pore property is given, it is interpolated to a throat list.\n    \"\"\"\nfrom sympy import symbols, lambdify\nfrom sympy import atan as sym_atan\nfrom sympy import cos as sym_cos\nfrom sympy import sin as sym_sin\nfrom sympy import sqrt as sym_sqrt\nfrom sympy import pi as sym_pi\nnetwork = target.project.network\nphase = target.project.find_phase(target)\nelement, surface_tension, contact = _get_key_props(phase=phase, diameter=\n    throat_diameter, surface_tension=surface_tension, contact_angle=\n    contact_angle)\ncontact = np.deg2rad(contact)\nthroatRad = network[throat_diameter] / 2\nfa = target[throat_scale_a]\nfb = target[throat_scale_b]\nx, a, b, rt, sigma, theta = symbols('x, a, b, rt, sigma, theta')\nif profile_equation == 'elliptical':\n    y = sym_sqrt(1 - (x / a) ** 2) * b\nelif profile_equation == 'sinusoidal':\n    y = sym_cos(sym_pi / 2 * (x / a)) * b\nelse:\n    logger.error('Profile equation is not valid, default to elliptical')\n    y = sym_sqrt(1 - (x / a) ** 2) * b\nr = rt + (b - y)\nrprime = r.diff(x)\nalpha = sym_atan(rprime)\neta = sym_pi - alpha - theta\ngamma = sym_pi / 2 - eta\nrm = r / sym_cos(eta)\nd = rm * sym_sin(eta)\np = 2 * sigma / rm\nrx = lambdify((x, a, b, rt), r, 'numpy')\nfill_angle = lambdify((x, a, b, rt), alpha, 'numpy')\nrad_curve = lambdify((x, a, b, rt, theta), rm, 'numpy')\nc2x = lambdify((x, a, b, rt, theta), d, 'numpy')\ncap_angle = lambdify((x, a, b, rt, theta), gamma, 'numpy')\nPc = lambdify((x, a, b, rt, theta, sigma), p, 'numpy')\nhp = int(num_points / 2)\nlog_pos = np.logspace(-4, -1, hp + 1)[:-1]\nlin_pos = np.arange(0.1, 1.0, 1 / hp)\nhalf_pos = np.concatenate((log_pos, lin_pos))\npos = np.concatenate((-half_pos[::-1], half_pos))\nY, X = np.meshgrid(throatRad, pos)\nX *= fa\nt_Pc = Pc(X, fa, fb, Y, contact, surface_tension)\nPc_min = np.min(t_Pc, axis=0)\nPc_max = np.max(t_Pc, axis=0)\na_min = np.argmin(t_Pc, axis=0)\na_max = np.argmax(t_Pc, axis=0)\nif mode == 'max':\n    return Pc_max\nelif mode == 'touch':\n    all_rad = rad_curve(X, fa, fb, Y, contact)\n    all_c2x = c2x(X, fa, fb, Y, contact)\n    all_cen = X - all_c2x\n    dist = all_cen + all_rad\n    dist[all_rad < 0] = 0.0\n    touch_len = network[touch_length]\n    mask = dist > touch_len\n    arg_touch = np.argmax(mask, axis=0)\n    arg_in_range = (arg_touch < a_max) * (arg_touch > a_min)\n    arg_touch[~arg_in_range] = a_max[~arg_in_range]\n    x_touch = pos[arg_touch] * fa\n    Pc_touch = Pc(x_touch, fa, fb, throatRad, contact, surface_tension)\n    return Pc_touch\nelif target_Pc is None:\n    logger.error(msg='Please supply a target capillary pressure' +\n        ' when mode is \"men\", default to 1.0e-6')\n    target_Pc = 1e-06\nif np.abs(target_Pc) < 1e-06:\n    logger.error(msg='Please supply a target capillary pressure' +\n        ' with absolute value greater than 1.0e-6,' + ' default to 1.0e-6')\n    target_Pc = 1e-06\ninds = np.indices(np.shape(t_Pc))\nmask = inds[0] < np.ones(len(pos))[:, (np.newaxis)] * a_min\nt_Pc[mask] = (np.ones(len(pos))[:, (np.newaxis)] * Pc_min)[mask]\nmask = inds[0] > np.ones(len(pos))[:, (np.newaxis)] * a_max\nt_Pc[mask] = (np.ones(len(pos))[:, (np.newaxis)] * Pc_max)[mask]\nmask = t_Pc >= target_Pc\narg_x = np.argmax(mask, axis=0)\narg_x[target_Pc < Pc_min] = a_min[target_Pc < Pc_min]\narg_x[target_Pc > Pc_max] = a_max[target_Pc > Pc_max]\nxpos = pos[arg_x] * fa\nxmin = pos[a_min] * fa\nxmax = pos[a_max] * fa\nmen_data = {}\nmen_data['pos'] = xpos\nmen_data['rx'] = rx(xpos, fa, fb, throatRad)\nmen_data['alpha'] = fill_angle(xpos, fa, fb, throatRad)\nmen_data['alpha_min'] = fill_angle(xmin, fa, fb, throatRad)\nmen_data['alpha_max'] = fill_angle(xmax, fa, fb, throatRad)\nmen_data['c2x'] = c2x(xpos, fa, fb, throatRad, contact)\nmen_data['gamma'] = cap_angle(xpos, fa, fb, throatRad, contact)\nmen_data['radius'] = rad_curve(xpos, fa, fb, throatRad, contact)\nmen_data['center'] = xpos - men_data['c2x']\nmen_data['men_max'] = men_data['center'] - men_data['radius']\nlogger.info(mode + ' calculated for Pc: ' + str(target_Pc))\nreturn men_data\n"
}
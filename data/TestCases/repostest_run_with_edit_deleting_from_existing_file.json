{
    "functionName": "test_run_with_edit_deleting_from_existing_file",
    "className": "TestPolicyDirectoryMonitor",
    "fileName": "/OpenKMIP_&_PyKMIP/kmip_&_tests_&_unit_&_services_&_server_&_test_monitor.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "\"\"\"\n        Test that the PolicyDirectoryMonitor can load policy files and track\n        them properly, even when an existing policy file has content removed\n        while tracking is active.\n        \"\"\"\nm = monitor.PolicyDirectoryMonitor(self.tmp_dir, multiprocessing.Manager().\n    dict())\nm.logger = mock.MagicMock(logging.Logger)\nm.halt_trigger = mock.MagicMock(multiprocessing.synchronize.Event)\nm.halt_trigger.is_set.side_effect = side_effects([False, build_write_effect\n    (self.tmp_dir, 'policy_1.json', POLICY_1), True])\nwrite_file(self.tmp_dir, 'policy_1.json', POLICY_6)\nwrite_file(self.tmp_dir, 'policy_2.json', POLICY_2)\nself.assertEqual({}, m.file_timestamps)\nself.assertEqual({}, m.policy_cache)\nself.assertEqual([], m.policy_files)\nself.assertEqual({}, m.policy_map)\nself.assertEqual([], m.policy_store.keys())\nm.run()\nm.logger.info.assert_any_call('Starting up the operation policy file monitor.')\nm.logger.info.assert_any_call('Loading policies for file: {}'.format(os.\n    path.join(self.tmp_dir, 'policy_1.json')))\nm.logger.info.assert_any_call('Loading policy: policy_A')\nm.logger.info.assert_any_call('Loading policy: policy_E')\nm.logger.info.assert_any_call('Loading policies for file: {}'.format(os.\n    path.join(self.tmp_dir, 'policy_2.json')))\nm.logger.info.assert_any_call('Loading policy: policy_B')\nm.logger.info.assert_any_call('Loading policy: policy_C')\nm.logger.info.assert_any_call('Loading policies for file: {}'.format(os.\n    path.join(self.tmp_dir, 'policy_1.json')))\nm.logger.info.assert_any_call('Loading policy: policy_A')\nm.logger.info.assert_any_call('Removing policy: policy_E')\nm.logger.info.assert_any_call('Stopping the operation policy file monitor.')\nself.assertEqual(2, len(m.policy_files))\npath = os.path.join(self.tmp_dir, 'policy_1.json')\nself.assertEqual(os.path.getmtime(path), m.file_timestamps.get(path, None))\nself.assertIn(path, m.policy_files)\nself.assertEqual(path, m.policy_map.get('policy_A', None))\npath = os.path.join(self.tmp_dir, 'policy_2.json')\nself.assertEqual(os.path.getmtime(path), m.file_timestamps.get(path, None))\nself.assertIn(path, m.policy_files)\nself.assertEqual(path, m.policy_map.get('policy_B', None))\nself.assertEqual(path, m.policy_map.get('policy_C', None))\nself.assertEqual({'policy_A': [], 'policy_B': [], 'policy_C': []}, m.\n    policy_cache)\nself.assertEqual(3, len(m.policy_store.keys()))\nself.assertEqual({'groups': {'group_A': {enums.ObjectType.SYMMETRIC_KEY: {\n    enums.Operation.GET: enums.Policy.ALLOW_ALL, enums.Operation.DESTROY:\n    enums.Policy.ALLOW_ALL}}}}, m.policy_store.get('policy_A', None))\nself.assertEqual({'groups': {'group_B': {enums.ObjectType.SYMMETRIC_KEY: {\n    enums.Operation.GET: enums.Policy.ALLOW_ALL, enums.Operation.LOCATE:\n    enums.Policy.ALLOW_ALL, enums.Operation.DESTROY: enums.Policy.ALLOW_ALL\n    }}}}, m.policy_store.get('policy_B', None))\nself.assertEqual({'groups': {'group_C': {enums.ObjectType.SYMMETRIC_KEY: {\n    enums.Operation.GET: enums.Policy.ALLOW_ALL, enums.Operation.DESTROY:\n    enums.Policy.DISALLOW_ALL}}}}, m.policy_store.get('policy_C', None))\n"
}
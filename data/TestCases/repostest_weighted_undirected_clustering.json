{
    "functionName": "test_weighted_undirected_clustering",
    "className": null,
    "fileName": "/Silmathoron_&_NNGT/testing_&_test_analysis.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "\"\"\"\n    Check relevant properties of weighted clustering:\n\n    * give back the binary definition if all weights are one\n    * corner cases for specific networks, see [Saramaki2007]\n    * equivalence between no edge and zero-weight edge for 'continuous' method\n\n    Note: onnela and barrat are already check against networkx and igraph\n    implementations in libarry_compatibility.py\n    \"\"\"\ng = ng.erdos_renyi(avg_deg=10, nodes=100, directed=False)\nccb = na.local_clustering_binary_undirected(g)\nfor method in methods:\n    ccw = na.local_clustering(g, weights='weight', method=method)\n    assert np.all(np.isclose(ccb, ccw))\neps = 1e-30\nnum_nodes = 3\nedge_list = [(0, 1), (1, 2), (2, 0)]\nweights = [eps, eps, eps]\ng = nngt.Graph(nodes=num_nodes, directed=False)\ng.new_edges(edge_list, attributes={'weight': weights})\nfor method in methods:\n    cc = na.local_clustering(g, weights='weight', method=method)\n    assert np.array_equal(cc, [1, 1, 1])\ng.set_weights(np.array([eps, eps, 1]))\nfor method in methods:\n    cc = na.local_clustering(g, weights='weight', method=method)\n    if method == 'barrat':\n        assert np.all(np.isclose(cc, 1))\n    else:\n        assert np.all(np.isclose(cc, 0))\ng.set_weights(np.array([eps, eps, 1]))\nfor method in methods:\n    cc = na.local_clustering(g, weights='weight', method=method)\n    if method == 'barrat':\n        assert np.all(np.isclose(cc, 1))\n    else:\n        assert np.all(np.isclose(cc, 0))\nnum_nodes = 4\nedge_list = [(0, 1), (1, 2), (2, 0), (2, 3)]\ng = nngt.Graph(nodes=num_nodes, directed=False)\ng.new_edges(edge_list)\ng.set_weights([1, 1, 1, eps])\nfor method in methods:\n    cc = na.local_clustering(g, weights='weight', method=method)\n    if method == 'barrat':\n        assert np.all(np.isclose(cc, [1, 1, 0.5, 0]))\n    elif method == 'continuous':\n        assert np.all(np.isclose(cc, [1, 1, 1, 0]))\n    else:\n        assert np.all(np.isclose(cc, [1, 1, 1 / 3, 0]))\ng.set_weights([eps, eps, eps, 1])\nfor method in methods:\n    cc = na.local_clustering(g, weights='weight', method=method)\n    if method == 'barrat':\n        assert np.all(np.isclose(cc, [1, 1, 0, 0]))\n    else:\n        assert np.all(np.isclose(cc, 0))\ng.set_weights([1, eps, eps, eps])\nfor method in methods:\n    cc = na.local_clustering(g, weights='weight', method=method)\n    if method == 'barrat':\n        assert np.all(np.isclose(cc, [1, 1, 1 / 3, 0]))\n    else:\n        assert np.all(np.isclose(cc, 0))\ng.set_weights([eps, 1, eps, eps])\nfor method in methods:\n    cc = na.local_clustering(g, weights='weight', method=method)\n    if method == 'barrat':\n        assert np.all(np.isclose(cc, [1, 1, 1 / 2, 0]))\n    else:\n        assert np.all(np.isclose(cc, 0))\nnum_nodes = 6\nedge_list = [(0, 1), (1, 2), (2, 0), (2, 3), (4, 5)]\ng = nngt.Graph(nodes=num_nodes, directed=False)\ng.new_edges(edge_list)\ng.set_weights([1 / 64, 1 / 729, 1 / 64, 1 / 729, 1])\nexpected = [1 / 324, 1 / 96, 9 / 1984, 0, 0, 0]\ncc = na.local_clustering(g, weights='weight', method='continuous')\nassert np.all(np.isclose(cc, expected))\ng.set_weights([1 / 64, 1 / 729, 1 / 64, 0, 1])\ncc0 = na.local_clustering(g, weights='weight', method='continuous')\nedge_list = [(0, 1), (1, 2), (2, 0), (4, 5)]\ng = nngt.Graph(nodes=num_nodes, directed=False)\ng.new_edges(edge_list)\ng.set_weights([1 / 64, 1 / 729, 1 / 64, 1])\nexpected = [1 / 324, 1 / 96, 1 / 96, 0, 0, 0]\nccn = na.local_clustering(g, weights='weight', method='continuous')\nassert np.all(np.isclose(cc0, ccn))\nassert np.all(np.isclose(cc0, expected))\npytest.mark.mpi_skip"
}
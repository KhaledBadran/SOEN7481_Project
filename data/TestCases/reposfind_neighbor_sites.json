{
    "functionName": "find_neighbor_sites",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_topotools_&_topotools.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Given a symmetric adjacency matrix, finds all sites that are connected\n    to the input sites.\n\n    Parameters\n    ----------\n    am : scipy.sparse matrix\n        The adjacency matrix of the network.  Must be symmetrical such that if\n        sites *i* and *j* are connected, the matrix contains non-zero values\n        at locations (i, j) and (j, i).\n\n    flatten : boolean\n        If ``True`` (default) the returned result is a compressed array of all\n        neighbors, or a list of lists with each sub-list containing the\n        neighbors for each input site.  Note that an *unflattened* list might\n        be slow to generate since it is a Python ``list`` rather than a Numpy\n        array.\n\n    include_input : boolean\n        If ``False`` (default) the input sites will be removed from the result.\n\n    logic : string\n        Specifies logic to filter the resulting list.  Options are:\n\n        **'or'** : (default) All neighbors of the input sites.  This is also\n        known as the 'union' in set theory or 'any' in boolean logic.  Both\n        keywords are accepted and treated as 'or'.\n\n        **'xor'** : Only neighbors of one and only one input site.  This is\n        useful for finding the sites that are not shared by any of the input\n        sites.  'exclusive_or' is also accepted.\n\n        **'xnor'** : Neighbors that are shared by two or more input sites. This\n        is equivalent to finding all neighbors with 'or', minus those found\n        with 'xor', and is useful for finding neighbors that the inputs have\n        in common.  'nxor' is also accepted.\n\n        **'and'** : Only neighbors shared by all input sites.  This is also\n        known as 'intersection' in set theory and (somtimes) as 'all' in\n        boolean logic.  Both keywords are accepted and treated as 'and'.\n\n    Returns\n    -------\n    An array containing the neighboring sites filtered by the given logic.  If\n    ``flatten`` is ``False`` then the result is a list of lists containing the\n    neighbors of each input site.\n\n    See Also\n    --------\n    find_complement\n\n    Notes\n    -----\n    The ``logic`` options are applied to neighboring sites only, thus it is not\n    possible to obtain sites that are part of the global set but not neighbors.\n    This is because (a) the list global sites might be very large, and (b) it\n    is not possible to return a list of neighbors for each input site if global\n    sites are considered.\n\n    \"\"\"\nif am.format != 'lil':\n    am = am.tolil(copy=False)\nsites = np.array(sites, ndmin=1)\nam_coo = am.tocoo()\nn_sites = am.shape[0]\nrows = am.rows[sites].tolist()\nif len(rows) == 0:\n    return []\nneighbors = am_coo.col[np.in1d(am_coo.row, sites)]\nif logic in ['or', 'union', 'any']:\n    neighbors = np.unique(neighbors)\nelif logic in ['xor', 'exclusive_or']:\n    neighbors = np.unique(np.where(np.bincount(neighbors) == 1)[0])\nelif logic in ['xnor', 'nxor']:\n    neighbors = np.unique(np.where(np.bincount(neighbors) > 1)[0])\nelif logic in ['and', 'all', 'intersection']:\n    neighbors = set(neighbors)\n    [neighbors.intersection_update(i) for i in rows]\n    neighbors = np.array(list(neighbors), dtype=np.int64, ndmin=1)\nelse:\n    raise Exception('Specified logic is not implemented')\nmask = np.zeros(shape=n_sites, dtype=bool)\nmask[neighbors] = True\nif not include_input:\n    mask[sites] = False\nif flatten:\n    neighbors = np.where(mask)[0]\nelif neighbors.size > 0:\n    for i in range(len(rows)):\n        vals = np.array(rows[i], dtype=np.int64)\n        rows[i] = vals[mask[vals]]\n    neighbors = rows\nelse:\n    neighbors = [np.array([], dtype=int) for i in range(len(sites))]\nreturn neighbors\n"
}
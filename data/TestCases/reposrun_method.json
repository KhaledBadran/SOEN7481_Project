{
    "functionName": "run_method",
    "className": null,
    "fileName": "/PyAbel_&_PyAbel/abel_&_tests_&_test_tools_distributions.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Test harmonics and Ibeta for various combinations of origins and weights\n    for default order=2, odd=False.\n\n    method = method name\n    rmax = 'MIN' or 'all'\n    tol... = (atol, rmstol) for ...\n    tolbeta = atol for beta\n    weq = compare symbolic and array weights\n    \"\"\"\nn = 81\nm = 71\nxc = [0, 20, n // 2, 60, n - 1]\nyc = [0, 25, m // 2, 45, m - 1]\nsigma = 2.0\ndef peak(i, r):\n    return np.exp(-(r - i * step) ** 2 / (2 * sigma ** 2))\ndef image():\n    x2 = (np.arange(float(n)) - x0) ** 2\n    y2 = (np.arange(float(m))[:, (None)] - y0) ** 2\n    r2 = x2 + y2\n    r = np.sqrt(r2)\n    c2 = np.divide(y2, r2, out=np.zeros_like(r2), where=r2 != 0)\n    s2 = 1 - c2\n    IM = s2 * peak(1, r) + peak(2, r) + c2 * peak(3, r)\n    return IM, np.sqrt(s2)\ndef ref_distr():\n    r = np.arange(R + 1)\n    P0 = 2 / 3 * peak(1, r) + peak(2, r) + 1 / 3 * peak(3, r)\n    P2 = -2 / 3 * peak(1, r) + 2 / 3 * peak(3, r)\n    I = 4 * np.pi * r ** 2 * P0\n    beta = P2 / P0\n    return r, P0, P2, I, beta\nfor y0, x0 in itertools.product(yc, xc):\n    param = ' @ y0 = {}, x0 = {}, rmax = {}, method = {}'.format(y0, x0,\n        rmax, method)\n    if rmax == 'MIN':\n        R = min(max(x0, n - 1 - x0), max(y0, m - 1 - y0))\n    elif rmax == 'all':\n        R = max([int(np.sqrt((x - x0) ** 2 + (y - y0) ** 2)) for x in (0, n -\n            1) for y in (0, m - 1)])\n    step = (R - 5 * sigma) / 3\n    refr, refP0, refP2, refI, refbeta = ref_distr()\n    f = 1 / (4 * np.pi * (1 + refr ** 2))\n    IM, ws = image()\n    w1 = np.ones_like(IM)\n    IMcopy = IM.copy()\n    w1copy = w1.copy()\n    wscopy = ws.copy()\n    weights = [(False, None, None), (True, None, None), (False, '1', w1), (\n        False, 'sin', ws), (True, '1', w1)]\n    P0, P2, r, I, beta = {}, {}, {}, {}, {}\n    for use_sin, wname, warray in weights:\n        weight_param = param + ', sin = {}, weights = {}'.format(use_sin, wname\n            )\n        key = use_sin, wname\n        distr = Distributions((y0, x0), rmax, use_sin=use_sin, weights=\n            warray, method=method)\n        res = distr(IM)\n        P0[key], P2[key] = res.harmonics()\n        r[key], I[key], beta[key] = res.rIbeta()\n\n        def assert_cmp(msg, a, ref, tol):\n            atol, rmstol = tol\n            assert_allclose(a, ref, atol=atol, err_msg=msg + weight_param)\n            rms = np.sqrt(np.mean((a - ref) ** 2))\n            assert rms < rmstol, '\\n' + msg + weight_param + '\\nRMS error = {} > {}'.format(\n                rms, rmstol)\n        assert_cmp('-> P0', P0[key], refP0, tolP0)\n        assert_cmp('-> P2', P2[key], refP2, tolP2)\n        assert_equal(r[key], refr, err_msg='-> r' + weight_param)\n        assert_cmp('-> I', f * I[key], f * refI, tolI)\n        b = [round(beta[key][int(i * step)], 5) for i in (1, 2, 3)]\n        assert_allclose(b, [-1, 0, 2], atol=tolbeta, err_msg='-> beta' +\n            weight_param)\n        assert_equal(IM, IMcopy, err_msg='-> IM corrupted' + weight_param)\n        assert_equal(w1, w1copy, err_msg='-> weights corrupted' + weight_param)\n        assert_equal(ws, wscopy, err_msg='-> weights corrupted' + weight_param)\n    if not weq:\n        continue\n    for key1, key2 in [((False, '1'), (False, None)), ((False, 'sin'), (\n        True, None)), ((True, '1'), (False, 'sin'))]:\n        pair_param = param + ', sin + weights {} != {}'.format(key1, key2)\n        assert_allclose(P0[key1], P0[key2], err_msg='-> P0' + pair_param)\n        assert_allclose(P2[key1], P2[key2], err_msg='-> P2' + pair_param)\n        assert_allclose(I[key1], I[key2], err_msg='-> I' + pair_param)\n        assert_allclose(beta[key1], beta[key2], err_msg='-> beta' + pair_param)\n"
}
{
    "functionName": "test_tax_func_loop",
    "className": null,
    "fileName": "/open-source-economics_&_OG-USA/ogusa_&_tests_&_test_txfunc.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "\"\"\"\n    Test txfunc.tax_func_loop() function.  The test is that given\n    inputs from previous run, the outputs are unchanged.\n\n    Note that the data for this test is too large for GitHub, so it\n    won't be available there.\n\n    \"\"\"\ninput_tuple = utils.safe_read_pickle(os.path.join(CUR_PATH, 'test_io_data',\n    'tax_func_loop_inputs_large.pkl'))\n(t, micro_data, beg_yr, s_min, s_max, age_specific, analytical_mtrs,\n    desc_data, graph_data, graph_est, output_dir, numparams, tpers\n    ) = input_tuple\ntax_func_type = 'DEP'\nmicro_data['total_labinc'] = micro_data['Wage income'] + micro_data['SE income'\n    ]\nmicro_data['etr'] = micro_data['Total tax liability'] / micro_data[\n    'Adjusted total income']\nmicro_data['total_capinc'] = micro_data['Adjusted total income'] - micro_data[\n    'total_labinc']\nmicro_data['mtr_labinc'] = micro_data['MTR wage income'] * (micro_data[\n    'Wage income'] / (micro_data['Wage income'].abs() + micro_data[\n    'SE income'].abs())) + micro_data['MTR SE income'] * (micro_data[\n    'SE income'].abs() / (micro_data['Wage income'].abs() + micro_data[\n    'SE income'].abs()))\nmicro_data.rename(columns={'Adjusted total income': 'market_income',\n    'MTR capital income': 'mtr_capinc', 'Total tax liability':\n    'total_tax_liab', 'Year': 'year', 'Age': 'age', 'expanded_income':\n    'market_income', 'Weights': 'weight'}, inplace=True)\nmicro_data['payroll_tax_liab'] = 0\ntest_tuple = txfunc.tax_func_loop(t, micro_data, beg_yr, s_min, s_max,\n    age_specific, tax_func_type, analytical_mtrs, desc_data, graph_data,\n    graph_est, output_dir, numparams)\nage_specific = False\nexpected_tuple = utils.safe_read_pickle(os.path.join(CUR_PATH,\n    'test_io_data', 'tax_func_loop_outputs.pkl'))\nfor i, v in enumerate(expected_tuple):\n    assert np.allclose(test_tuple[i], v)\npytest.mark.full_run"
}
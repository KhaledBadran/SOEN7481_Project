{
    "functionName": "plotCut1DE",
    "className": "DataSet",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Perform 1D cut through constant Q point returning binned intensity, monitor, normalization and normcount. The width of the cut is given by \n        the width attribute.\n        \n        \n        Args:\n            \n            - E1 (float): Start energy.\n            \n            - E2 (float): End energy.\n\n            - q (3D or 2D vector): Q point \n        \n        Kwargs:\n            \n            - rlu (bool): If True, provided Q point is interpreted as (h,k,l) otherwise as (qx,qy), (Default true)\n\n            - width (float): Full width of cut in q-plane (default 0.02).\n            \n            - minPixel (float): Minimal size of binning along the cutting direction. Points will be binned if they are closer than minPixel (default 0.1).\n            \n            - dataFiles (list): Data files to be used. If none provided use the ones in self (default None)\n\n            - constantBins (bool): If True only bins of size minPixel is used (default False)\n\n            - ufit (bool): If True a uFit Dataset object is returned in stead of pandas data frame\n\n            - ax (matplotlib.axes): If None, new axis is created in which to plot (default None)\n\n            - **kwargs: Pass on to the ax.errorbar method used to plot\n            \n        Returns:\n            \n            - Data list (pandas DataFrame): DataFrame containing qx,qy,H,K,L,Intensity,Normalization,Monitor,BinCount,Int,binDistance for 1D cut.\n            \n            - Bin list (1 array): Bin edge positions in energy\n\n        \"\"\"\nData, bins = self.cut1DE(E1=E1, E2=E2, q=q, rlu=rlu, width=width, minPixel=\n    minPixel, dataFiles=dataFiles, constantBins=constantBins)\nwith warnings.catch_warnings():\n    warnings.simplefilter('ignore')\n    INT = np.divide(Data['Intensity'] * Data['BinCount'], Data['Monitor'] *\n        Data['Normalization'])\n    INT_err = np.divide(np.sqrt(Data['Intensity']) * Data['BinCount'], Data\n        ['Monitor'] * Data['Normalization'])\nif rlu:\n    variables = ['H', 'K', 'L']\nelse:\n    variables = ['Qx', 'Qy']\nvariables = variables + ['Energy']\nnum = len(Data)\nif not 'ticks' in kwargs:\n    ticks = 5\nelse:\n    ticks = kwargs['ticks']\n    kwargs = _tools.without_keys(dictionary=kwargs, keys='ticks')\nif not 'tickRound' in kwargs:\n    tickRound = 3\nelse:\n    tickRound = kwargs['tickRound']\n    kwargs = _tools.without_keys(dictionary=kwargs, keys='tickRound')\nif not 'fmt' in kwargs:\n    kwargs['fmt'] = '.'\nxvalues = np.round(np.linspace(0, num - 1, ticks)).astype(int)\nmy_xticks = []\nfor i in xvalues:\n    my_xticks.append('\\n'.join(map(lambda x: ('{:.' + str(tickRound) + 'f}'\n        ).format(x), [np.round(Data[var][i], tickRound) for var in variables]))\n        )\nData['binDistance'] = np.linalg.norm(Data[variables] - np.array(Data[\n    variables].iloc[1]), axis=1)\nif ax is None:\n    plt.figure()\n    ax = plt.gca()\nif not 'label' in kwargs:\n    kwargs['label'] = 'Data'\nax.errorbar(Data['binDistance'], INT, yerr=INT_err, **kwargs)\nax.set_xticks(Data['binDistance'].iloc[xvalues])\nax.set_xticklabels(my_xticks, multialignment='center', ha='center')\ndef calculateIndex(binDistance, x):\n    idx = np.argmin(np.abs(binDistance - x))\n    return idx\nax.calculateIndex = lambda x: calculateIndex(Data['binDistance'], x)\nif rlu == False:\n    ax.set_xlabel('$Q_x [\\\\AA^{-1}]$' + '\\n' + '$Q_y [\\\\AA^{-1}]$' + '\\n' +\n        'E/meV')\n\n    def format_coord(x, y, ax, binCenter):\n        index = ax.calculateIndex(x)\n        qx, qy, E = binCenter[index]\n        return 'qx = {0:.3e}, qy = {1:.3e}, E = {2:.3f}, I = {3:0.4e}'.format(\n            qx, qy, E, y)\nelse:\n\n    def format_coord(x, y, ax, binCenter):\n        index = ax.calculateIndex(x)\n        h, k, l, E = binCenter[index]\n        return (\n            'H = {0:.3e}, K = {1:.3e}, L = {2:.3e}, E = {3:.3f}, I = {4:0.4e}'\n            .format(h, k, l, E, y))\n    ax.set_xlabel('$Q_h$ [RLU]\\n$Q_k$ [RLU]\\n$Q_l$ [RLU]\\nE [meV]')\nax.xaxis.set_label_coords(1.15, -0.025)\nax.set_ylabel('$I$ [arb.u.]')\nplt.tight_layout()\nax.format_coord = lambda x, y: format_coord(x, y, ax, np.array(Data[variables])\n    )\nif not ufit:\n    return ax, Data, bins\nmeta = dict()\nmeta['instrument'] = self[0].instrument\nmeta['experiment'] = ', '.join(d.experimentIdentifier for d in self)\nmeta['title'] = self[0].title\nmeta['datafilename'] = ', '.join(d.name for d in self)\ndist, Int = np.array(Data[['Energy', 'Int']]).T\nerr = np.sqrt(Data['Intensity']) * Data['BinCount'] / (Data['Monitor'] *\n    Data['Normalization'])\ndata = np.array([dist, Int, err]).T\nxcol = 'E [meV]'\nycol = 'Intensity'\nname = 'Intensity'\nufitData = Dataset(meta=meta, data=data, xcol=xcol, ycol=ycol, name=name)\nreturn ax, ufitData\n_tools.KwargChecker(function=plt.errorbar, include=np.concatenate([_tools.\n    MPLKwargs, ['ticks', 'tickRound', 'mfc', 'markeredgewidth', 'markersize']])\n    )"
}
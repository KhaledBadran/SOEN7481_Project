{
    "functionName": "reflect_base_points",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_topotools_&_topotools.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Helper function for relecting a set of points about the faces of a\n    given domain.\n\n    Parameters\n    ----------\n    base_pts : array_like\n        The coordinates of the base_pts to be reflected in the coordinate\n        system corresponding to the the domain as follows:\n\n        **spherical** : [r, theta, phi]\n        **cylindrical** or **circular** : [r, theta, z]\n        **rectangular** or **square** : [x, y, z]\n\n    domain_size : list or array\n        Controls the size and shape of the domain, as follows:\n\n        **sphere** : If a single value is received, its treated as the radius\n        [r] of a sphere centered on [0, 0, 0].\n\n        **cylinder** : If a two-element list is received it's treated as the\n        radius and height of a cylinder [r, z] positioned at [0, 0, 0] and\n        extending in the positive z-direction.  If the z dimension is 0, a\n        disk of radius r is created.\n\n        **rectangle** : If a three element list is received, it's treated\n        as the outer corner of rectangle [x, y, z] whose opposite corner lies\n        at [0, 0, 0].  If the z dimension is 0, a rectangle of size X-by-Y is\n        created.\n\n    \"\"\"\ndomain_size = np.array(domain_size)\nif len(domain_size) == 1:\n    r, theta, phi = base_pts\n    new_r = 2 * domain_size[0] - r\n    r = np.hstack([r, new_r])\n    theta = np.hstack([theta, theta])\n    phi = np.hstack([phi, phi])\n    base_pts = np.vstack((r, theta, phi))\nif len(domain_size) == 2:\n    r, theta, z = base_pts\n    new_r = 2 * domain_size[0] - r\n    r = np.hstack([r, new_r])\n    theta = np.hstack([theta, theta])\n    z = np.hstack([z, z])\n    if domain_size[1] != 0:\n        r = np.hstack([r, r, r])\n        theta = np.hstack([theta, theta, theta])\n        z = np.hstack([z, -z, 2 - z])\n    base_pts = np.vstack((r, theta, z))\nelif len(domain_size) == 3:\n    Nx, Ny, Nz = domain_size\n    orig_pts = base_pts\n    base_pts = np.vstack((base_pts, [-1, 1, 1] * orig_pts + [2.0 * Nx, 0, 0]))\n    base_pts = np.vstack((base_pts, [-1, 1, 1] * orig_pts))\n    base_pts = np.vstack((base_pts, [1, -1, 1] * orig_pts + [0, 2.0 * Ny, 0]))\n    base_pts = np.vstack((base_pts, [1, -1, 1] * orig_pts))\n    if domain_size[2] != 0:\n        base_pts = np.vstack((base_pts, [1, 1, -1] * orig_pts + [0, 0, 2.0 *\n            Nz]))\n        base_pts = np.vstack((base_pts, [1, 1, -1] * orig_pts))\nreturn base_pts\n"
}
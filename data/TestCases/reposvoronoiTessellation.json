{
    "functionName": "voronoiTessellation",
    "className": null,
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Generate individual pixels around the given datapoints.\n\n    Args:\n\n        - points (list of list of points): Data points to generate pixels in shape [files,XY,N] i.e. [1,2,N] for one file with N points\n\n    Kwargs:\n\n        - plot (bool): If True, method plots pixels created with green as edge bins and red as internal (default False)\n\n        - Boundary (list of Polygons): List of Shapely polygons constituting the boundaries (Default False)\n\n\n    \"\"\"\nif numGroups == False:\n    numGroups = len(points)\nif Boundary == False:\n    BoundPoly = [convexHullPoints(np.array(points[i][0]).flatten(), np.\n        array(points[i][1]).flatten()) for i in range(numGroups)]\nelse:\n    BoundPoly = Boundary\nif numGroups == 1:\n    combiPoly = BoundPoly[0]\n    pointsX = np.array([points[0][0].flatten()])[0]\n    pointsY = np.array([points[0][1].flatten()])[0]\nelse:\n    combiPoly = BoundPoly[0].union(BoundPoly[1])\n    for i in range(len(BoundPoly) - 2):\n        combiPoly = combiPoly.union(BoundPoly[i + 2])\n    if Boundary == False:\n        pointsX = np.concatenate([points[i][0].flatten() for i in range(\n            numGroups)])\n        pointsY = np.concatenate([points[i][1].flatten() for i in range(\n            numGroups)])\n    else:\n        pointsX = points[0]\n        pointsY = points[1]\ncontainsAllPoints = np.all([combiPoly.contains(PointS(pointsX[i], pointsY[i\n    ])) for i in range(len(pointsX))])\nif not containsAllPoints:\n    plt.figure()\n    plt.scatter(pointsX, pointsY, c='b')\n    boundaryXY = np.array(combiPoly.boundary.coords)\n    plt.plot(boundaryXY[:, (0)], boundaryXY[:, (1)], c='r')\n    raise AttributeError('The provided boundary does not contain all points')\nextraPoints = np.array([[np.mean(pointsX), np.max(pointsY) + 50], [np.mean(\n    pointsX), np.min(pointsY) - 50], [np.min(pointsX) - 50, np.mean(pointsY\n    )], [np.max(pointsX) + 50, np.mean(pointsY)], [np.min(pointsX) - 50, np\n    .max(pointsY) + 50], [np.min(pointsX) - 50, np.min(pointsY) - 50], [np.\n    max(pointsX) + 50, np.max(pointsY) + 50], [np.max(pointsX) + 50, np.min\n    (pointsY) - 50]])\nAllPoints = np.array([np.concatenate([pointsX, extraPoints[:, (0)]]), np.\n    concatenate([pointsY, extraPoints[:, (1)]])])\nvor = Voronoi(AllPoints.T)\nregions = np.array([reg for reg in vor.regions])\nboolval = np.array([(len(x) > 2 and not -1 in x) for x in regions])\nPolyPoints = np.array([vor.vertices[(reg), :] for reg in regions[boolval]])\npolygons = np.array([PolygonS(X) for X in PolyPoints])\ninsidePolygonsBool = np.array([combiPoly.contains(P) for P in polygons])\nedgePolygonsBool = np.logical_not(insidePolygonsBool)\nintersectionPolygon = []\nfor poly in polygons[edgePolygonsBool]:\n    inter = poly.intersection(combiPoly)\n    if not isinstance(inter, PolygonS):\n        inter = inter[np.argmax([x.area for x in inter])]\n    intersectionPolygon.append(inter)\nPolygons = np.concatenate([polygons[np.logical_not(edgePolygonsBool)],\n    intersectionPolygon])\nif plot or len(pointsX) != len(Polygons):\n    plt.figure()\n    insiders = np.logical_not(edgePolygonsBool)\n    [plt.plot(np.array(inter.boundary.coords)[:, (0)], np.array(inter.\n        boundary.coords)[:, (1)], c='r') for inter in polygons[insiders]]\n    [plt.plot(np.array(inter.boundary.coords)[:, (0)], np.array(inter.\n        boundary.coords)[:, (1)], c='g') for inter in intersectionPolygon]\n    [plt.plot(np.array(bound.boundary.coords)[:, (0)], np.array(bound.\n        boundary.coords)[:, (1)], '-.', c='r') for bound in BoundPoly]\n    plt.scatter(extraPoints[:, (0)], extraPoints[:, (1)])\n    from scipy.spatial import voronoi_plot_2d\n    voronoi_plot_2d(vor)\nif not len(pointsX) == len(Polygons):\n    raise AttributeError(\n        \"\"\"The number of points given({}) is not the same as the number of polygons created({}). This can be due to many reasons, mainly:\n - Points overlap exactly\n - Points coinsides with the calculated edge\n - ??\"\"\"\n        .format(len(pointsX), len(Polygons)))\nreturn Polygons, np.array([np.array(P.boundary.coords[:-1]) for P in Polygons])\n_tools.KwargChecker()"
}
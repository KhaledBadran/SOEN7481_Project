{
    "functionName": "MultiscaleEntropy_sample_entropy",
    "className": null,
    "fileName": "/neuropsychology_&_NeuroKit/tests_&_tests_complexity.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"[Sample Entropy, the threshold will be r*sd]\n\n    Arguments:\n        x {[input signal]} -- [an iterator of numbers]\n\n    Keyword Arguments:\n        m {list} -- [m in sample entropy] (default: {[2]})\n        r {list} -- [r in sample entropy] (default: {[0.15]})\n        sd {number} -- [standard derivation of x, if None, will be calculated] (default: {None})\n        return_type {str} -- [can be dict or list] (default: {'dict'})\n        safe_mode {bool} -- [if set True, type checking will be skipped] (default: {False})\n\n    Raises:\n        ValueError -- [some values too big]\n\n    Returns:\n        [dict or list as return_type indicates] -- [if dict, nest as [scale_factor][m][r] for each value of m, r; if list, nest as [i][j] for lengths of m, r]\n    \"\"\"\nif not safe_mode:\n    m = MultiscaleEntropy_check_type(m, int, 'm')\n    r = MultiscaleEntropy_check_type(r, float, 'r')\n    if not sd == None and not (isinstance(sd, float) or isinstance(sd, int)):\n        raise ValueError('sd should be a number')\ntry:\n    x = np.array(x)\nexcept:\n    raise ValueError('x should be a sequence of numbers')\nif len(x) < max(m):\n    raise ValueError(\"the max m is bigger than x's length\")\nif sd == None:\n    sd = np.sqrt(np.var(x))\nans = MultiscaleEntropy_init_return_type(return_type)\nfor i, rr in enumerate(r):\n    threshold = rr * sd\n    if return_type == 'dict':\n        ans[rr] = MultiscaleEntropy_init_return_type(return_type)\n    else:\n        ans.append(MultiscaleEntropy_init_return_type(return_type))\n    count = {}\n    tmp_m = []\n    for mm in m:\n        tmp_m.append(mm)\n        tmp_m.append(mm + 1)\n    tmp_m = list(set(tmp_m))\n    for mm in tmp_m:\n        count[mm] = 0\n    for j in range(1, len(x) - min(m) + 1):\n        cont = 0\n        for inc in range(0, len(x) - j):\n            if abs(x[inc] - x[j + inc]) < threshold:\n                cont += 1\n            elif cont > 0:\n                for mm in tmp_m:\n                    tmp = cont - mm + 1\n                    count[mm] += tmp if tmp > 0 else 0\n                cont = 0\n        if cont > 0:\n            for mm in tmp_m:\n                tmp = cont - mm + 1\n                count[mm] += tmp if tmp > 0 else 0\n    for mm in m:\n        if count[mm + 1] == 0 or count[mm] == 0:\n            t = len(x) - mm + 1\n            tmp = -math.log(1 / (t * (t - 1)))\n        else:\n            tmp = -math.log(count[mm + 1] / count[mm])\n        if return_type == 'dict':\n            ans[rr][mm] = tmp\n        else:\n            ans[i].append(tmp)\nreturn ans\n"
}
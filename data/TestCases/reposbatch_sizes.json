{
    "functionName": "batch_sizes",
    "className": "TestTfCudaResample",
    "fileName": "/tum-pbs_&_PhiFlow/gpu_tests_&_test_tf_cuda_resample.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "with tf.device(device):\n    for n in range(self.N):\n        boundary = rand.choice(self.BOUNDARIES)\n        data = self.generate_data()\n        points = self.generate_points(data.shape)\n        data2 = np.zeros(data.shape)\n        for x in range(data2.size):\n            data2.flat[x] = rand.uniform(self.MIN_VALUE, self.MAX_VALUE)\n        points2 = np.zeros(points.shape)\n        dim = 0\n        dims = len(data.shape) - 2\n        for x in range(points.size):\n            points2.flat[x] = rand.uniform(-self.PERCENTAGE_OUT_OF_BOUNDS /\n                200 * data.shape[dim + 1], data.shape[dim + 1] * (1 + self.\n                PERCENTAGE_OUT_OF_BOUNDS / 200))\n            dim = (dim + 1) % dims\n        data_combined = np.concatenate((data, data2))\n        points_combined = np.concatenate((points, points2))\n        data_placeholder = tf.placeholder(tf.float32, name=\n            'data_placeholder', shape=data.shape)\n        data_combined_placeholder = tf.placeholder(tf.float32, name=\n            'data_combined_placeholder', shape=data_combined.shape)\n        points_placeholder = tf.placeholder(tf.float32, name=\n            'points_placeholder', shape=points.shape)\n        points_combined_placeholder = tf.placeholder(tf.float32, name=\n            'points_combined_placeholder', shape=points_combined.shape)\n        single = resample_cuda(data_placeholder, points_placeholder, boundary)\n        single_data_gradient = tf.gradients(single, data_placeholder)[0]\n        single_points_gradient = tf.gradients(single, points_placeholder)[0]\n        combined = resample_cuda(data_combined_placeholder,\n            points_combined_placeholder, boundary)\n        combined_data_gradient = tf.gradients(combined,\n            data_combined_placeholder)[0]\n        combined_points_gradient = tf.gradients(combined,\n            points_combined_placeholder)[0]\n        with tf.Session() as sess, tf.device(device):\n            reference1 = sess.run([single, single_data_gradient,\n                single_points_gradient], feed_dict={data_placeholder: data,\n                points_placeholder: points})\n            reference2 = sess.run([single, single_data_gradient,\n                single_points_gradient], feed_dict={data_placeholder: data2,\n                points_placeholder: points2})\n            result = sess.run([combined, combined_data_gradient,\n                combined_points_gradient], feed_dict={\n                data_combined_placeholder: data_combined,\n                points_combined_placeholder: points_combined})\n        for i in range(3):\n            reference = np.concatenate((reference1[i], reference2[i]))\n            for j in range(result[i].size):\n                assert abs(reference.flat[j] - result[i].flat[j]\n                    ) < self.MAX_DIFFERENCE\n        combined = resample_cuda(data_combined_placeholder,\n            points_placeholder, boundary)\n        combined_data_gradient = tf.gradients(combined,\n            data_combined_placeholder)[0]\n        combined_points_gradient = tf.gradients(combined, points_placeholder)[0\n            ]\n        with tf.Session() as sess, tf.device(device):\n            reference1 = sess.run([single, single_data_gradient,\n                single_points_gradient], feed_dict={data_placeholder: data,\n                points_placeholder: points})\n            reference2 = sess.run([single, single_data_gradient,\n                single_points_gradient], feed_dict={data_placeholder: data2,\n                points_placeholder: points})\n            result = sess.run([combined, combined_data_gradient,\n                combined_points_gradient], feed_dict={\n                data_combined_placeholder: data_combined,\n                points_placeholder: points})\n        for i in range(3):\n            if i == 2:\n                reference = reference1[i] + reference2[i]\n            else:\n                reference = np.concatenate((reference1[i], reference2[i]))\n            for j in range(result[i].size):\n                assert abs(reference.flat[j] - result[i].flat[j]\n                    ) < self.MAX_DIFFERENCE\n        combined = resample_cuda(data_placeholder,\n            points_combined_placeholder, boundary)\n        combined_data_gradient = tf.gradients(combined, data_placeholder)[0]\n        combined_points_gradient = tf.gradients(combined,\n            points_combined_placeholder)[0]\n        with tf.Session() as sess, tf.device(device):\n            reference1 = sess.run([single, single_data_gradient,\n                single_points_gradient], feed_dict={data_placeholder: data,\n                points_placeholder: points})\n            reference2 = sess.run([single, single_data_gradient,\n                single_points_gradient], feed_dict={data_placeholder: data,\n                points_placeholder: points2})\n            result = sess.run([combined, combined_data_gradient,\n                combined_points_gradient], feed_dict={data_placeholder:\n                data, points_combined_placeholder: points_combined})\n        for i in range(3):\n            if i == 1:\n                reference = reference1[i] + reference2[i]\n            else:\n                reference = np.concatenate((reference1[i], reference2[i]))\n            for j in range(result[i].size):\n                assert abs(reference.flat[j] - result[i].flat[j]\n                    ) < self.MAX_DIFFERENCE\n"
}
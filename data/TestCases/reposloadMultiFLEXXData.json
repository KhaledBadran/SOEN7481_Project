{
    "functionName": "loadMultiFLEXXData",
    "className": "DataFile",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataFile.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\"Dedicated loader for MultiFLEXX data.\n\n        Args:\n\n            - fileLocation (str): Location of file\n\n        Kwargs:\n\n            - calibrationFile (str): Location of calibration file (default None: uses shipped calibration)\n\n        \"\"\"\nself.fileLocation = fileLocation\nself.possibleBinnings = [1]\nself.binning = 1\nwith open(fileLocation) as f:\n    dataString = f.readlines()\ndataString = ''.join(dataString)\nheaderStart = dataString.find('VVVVVVVVVVVVVVVVVVVV')\nheaderEnd = dataString.find('DATA_:')\nheaderString = dataString[headerStart:headerEnd].split('\\n')[1:-1]\ndataPart = dataString[headerEnd:].split('\\n')[1:-1]\nmultiLines = ['param', 'varia', 'zeros', 'posqe']\nstringParameters = ['file_']\nparameters = {}\nfor line in headerString:\n    splitLine = line.split(': ')\n    if isinstance(splitLine, list):\n        description, value = splitLine\n    else:\n        continue\n    description = description.lower()\n    if not description in multiLines:\n        if not description in stringParameters:\n            try:\n                value = float(value)\n            except ValueError:\n                pass\n        description = description.replace('_', '')\n        parameters[description] = value\n    elif description in ['varia', 'param', 'posqe']:\n        keyValuePattern = re.compile('\\\\w*\\\\s*=\\\\s*' + reFloat)\n        KVPairs = keyValuePattern.findall(value)\n        for pair in KVPairs:\n            key, val = pair.split('=')\n            key = key.strip()\n            try:\n                val = np.array(val.strip(), dtype=float)\n            except ValueError:\n                continue\n            setattr(self, key, val)\n    elif description == 'zeros':\n        keyValuePattern = re.compile('\\\\w+\\\\s+=\\\\s*' + reFloat)\n        KVPairs = keyValuePattern.findall(value)\n        for pair in KVPairs:\n            key, val = pair.split('=')\n            key = key.strip()\n            try:\n                val = np.array(val.strip(), dtype=float)\n            except ValueError:\n                continue\n            key += 'Off'\n            setattr(self, key, val)\nself.__dict__.update(parameters)\nscanParameters = [x.split('=')[0].strip() for x in self.steps.split(',')]\nself.scanParameters = [p.capitalize() for p in scanParameters]\nself.scanUnits = []\nfor param in self.scanParameters:\n    if param.lower() in ['a3', 'a4', 'sgu', 'sgl']:\n        unit = 'degree'\n    elif param.lower() == 'ei':\n        unit = 'meV'\n    else:\n        unit = 'unknown'\n    self.scanUnits.append(unit)\nscanSteps = [float(x.split('=')[1]) for x in self.steps.split(',')]\nscanCommandNPMN = re.compile('\\\\w+\\\\s+\\\\d+')\nNPMN = scanCommandNPMN.findall(self.comnd)[-2:]\nfor paramVal in NPMN:\n    param, val = paramVal.split()\n    if param.lower() == 'np':\n        self.steps = int(val)\n    elif param.lower() == 'mn':\n        self.MonitorPreset = int(val)\n        self.MonitorMode = 'm'\n    elif param.lower() == 'ti':\n        self.MonitorPreset = int(val)\n        self.MonitorMode = 't'\ndef extractSample(obj, sample=None):\n    if sample is None:\n        sample = dict()\n    nameConversion = [['AA', 'alpha'], ['BB', 'beta'], ['CC', 'gamma'], [\n        'AS', 'a'], ['BS', 'b'], ['CS', 'c']]\n    for oldName, newName in nameConversion:\n        sample[newName] = getattr(obj, oldName)\n        delattr(obj, oldName)\n    planeVector1 = [getattr(obj, x) for x in ['AX', 'AY', 'AZ']]\n    planeVector2 = [getattr(obj, x) for x in ['BX', 'BY', 'BZ']]\n    sample['projectionVector1'] = planeVector1\n    sample['projectionVector2'] = planeVector2\n    return sample\ndef updateKeyName(obj, key, newName):\n    if not hasattr(obj, key):\n        return\n    setattr(obj, newName, getattr(obj, key))\n    delattr(obj, key)\nKIPattern = re.compile('PARAM:\\\\s*(FX=\\\\s*\\\\d*.?\\\\d*),\\\\s*(KFIX=\\\\s*' +\n    reFloat + ')')\nEI = np.power(self.KFIX / 0.694692, 2)\nif np.isclose(self.FX, 1.0):\n    self.EI = EI - self.EN\nelse:\n    self.EI = EI + self.EN\nsampleDict = extractSample(self)\nlabels = dataPart[0].split()\nstepData = np.zeros((self.steps, len(labels)))\nsingleDetectorData = np.zeros(self.steps, dtype=int)\nif dataPart[3].strip() == 'endflat':\n    self.pntData = np.array([np.array(x.split(), dtype=float) for x in\n        dataPart[1::3] if x[:8] != 'Finished'])\n    self.multiData = np.array([np.array(x.split()[1:], dtype=int) for x in\n        dataPart[2::3]])\n    self.multiData = self.multiData[:, :155]\n    self.type = 'MultiFLEXX'\nelse:\n    splitMarker = np.array([(x == 'MULTI:') for x in dataPart])\n    split = splitMarker.argmax()\n    if split != 0:\n        self.pntData = np.array([np.array(x.split(), dtype=float) for x in\n            dataPart[1:split]])\n        self.multiData = np.array([np.array(x.split(), dtype=int) for x in\n            dataPart[split + 1:]])\n        self.type = 'FlatCone'\n    else:\n        self.pntData = np.array([np.array(x.split(), dtype=float) for x in\n            dataPart[1:] if x[:8] != 'Finished'])\n        self.type = '1D'\nfor parameter, value in zip(labels[1:], self.pntData[:, 1:].T):\n    setattr(self, parameter, np.array(value))\ndataLen = self.pntData.shape[0]\nif not dataLen == self.steps:\n    self.steps = dataLen\nif hasattr(self, 'multiData'):\n    updateKeyName(self, 'multiData', 'I')\nelse:\n    updateKeyName(self, 'CNTS', 'I')\nnameSwaps = [['file', 'name'], ['MAG', 'magneticField'], ['CNTS',\n    'ISingleDetector'], ['M1', 'Monitor'], ['TIME', 'Time'], ['TT',\n    'temperature'], ['comnd', 'scanCommand'], ['instr', 'instrument'], [\n    'EI', 'Ei'], ['local', 'localContact'], ['user', 'userName'], ['DA',\n    'analyzerDSpacing'], ['expno', 'experimentIdentifier'], ['localContact',\n    'localContactName']]\nfor pair in nameSwaps:\n    updateKeyName(self, pair[0], pair[1])\nself.scanValues = np.array([getattr(self, param) for param in self.\n    scanParameters])\nself.sample = MJOLNIR.Data.Sample.Sample(**sampleDict)\nif calibrationFile is None:\n    this_dir, _ = os.path.split(__file__)\n    if self.type in ['MultiFLEXX', 'FlatCone']:\n        if self.type == 'MultiFLEXX':\n            calibrationFile = os.path.join(this_dir, '..',\n                'CalibrationMultiFLEXX.csv')\n            detectors = 155\n        else:\n            calibrationFile = os.path.join(this_dir, '..',\n                'CalibrationFlatCone.csv')\n            detectors = 31\n            self.mask = False\n        calibrationData = np.genfromtxt(calibrationFile, skip_header=1,\n            delimiter=',')\n        amplitude = calibrationData[:, (3)]\n        background = calibrationData[:, (6)]\n        bound = calibrationData[:, 7:9]\n        final_energy = calibrationData[:, (4)]\n        width = calibrationData[:, (5)]\n        A4 = -calibrationData[:, (9)]\n        EfTable = np.array([amplitude, final_energy, width, background]).T\n        calibrations = [[EfTable, A4, bound]]\n        bound = np.array(detectors * [0, 1], dtype=int).reshape(-1, 2)\n        self.instrumentCalibrationEdges = bound\n        self.instrumentCalibrationEf = EfTable\n        self.instrumentCalibrationA4 = A4\n        self.instrumentCalibrations = calibrations\n        if self.type == 'MultiFLEXX':\n            self.mask = np.zeros_like(self.I, dtype=bool)\n            self.mask[:, (np.isnan(self.instrumentCalibrationEf[:, (0)]))\n                ] = True\n    elif self.type == '1D':\n        pass\n    else:\n        import warnings\n        warnings.warn('Instrument of type \"{}\" is not supported yet....'.\n            format(self.type))\nself.analyzerSelection = 0\nself.detectorSelection = 0\nself.comment = ''\nif self.type == 'MultiFLEXX':\n    self.A3Off = np.array([90.0])\n    self.A4Off = np.array([0.0])\nif not hasattr(self, 'electricField'):\n    self.electricField = None\nif not hasattr(self, 'magneticField'):\n    self.magneticField = None\n_tools.KwargChecker()"
}
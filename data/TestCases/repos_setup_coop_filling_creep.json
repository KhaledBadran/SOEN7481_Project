{
    "functionName": "_setup_coop_filling_creep",
    "className": "MixedInvasionPercolationCoop",
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_algorithms_&_MixedInvasionPercolationCoop.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n        This coop filling model iterates through the invasion pressures set by\n        the inv_points variable and calls the meniscus model whose dictionary\n        key must be given in the algorithm's setup.\n        The meniscus model supplies the position of the meniscus inside each\n        throat as if there were a meniscus in every throat for a given pressure\n        The contact line of the meniscus traces a circle around the inner\n        surface of the throat which is assumed to be toroidal.\n        The contact circle lies on a plane that is defined by the throat's\n        normal vector which runs along the axis of symmetry of the torus.\n        For every pore, every connecting throat is compared with each of it's\n        neighboring throats connected to the same pore. If the planes intersect\n        then the meniscus contact circles may eventually touch if they can\n        advance enough. For highly wetting fluid the contact point may be\n        advanced well into the throat whilst still being at negative capillary\n        pressure.\n        \"\"\"\nstart = time.time()\nnet = self.project.network\nphase = self.project.find_phase(self)\nall_phys = self.project.find_physics(phase=phase)\nif inv_points is None:\n    inv_points = np.arange(0, 1.01, 0.01) * self._max_pressure()\ntry:\n    t_centroids = net['throat.centroid']\nexcept KeyError:\n    t_centroids = np.mean(net['pore.coords'][net['throat.conns']], axis=1)\ntry:\n    t_norms = net['throat.normal']\nexcept KeyError:\n    t_norms = net['pore.coords'][net['throat.conns'][:, (1)]] - net[\n        'pore.coords'][net['throat.conns'][:, (0)]]\ncpf = self.settings['cooperative_pore_filling']\nmodel = all_phys[0].models[cpf]\ntry:\n    t_rad = net[model['throat_diameter']] / 2 + model['r_toroid']\nexcept KeyError:\n    t_rad = net['throat.diameter'] / 2\nplanes = self._transform_point_normal(t_centroids, t_norms)\nNt = net.Nt\nadj_mat = dok_matrix((Nt, Nt), dtype=int)\nfor pore in net.Ps:\n    ts = net.find_neighbor_throats(pores=pore)\n    perms = self._pair_permutations(len(ts))\n    for perm in perms:\n        ta, tb = ts[perm]\n        p, q = self._plane_intersect(planes[ta], planes[tb])\n        if p is not None:\n            d1 = self._distance(p, q, t_centroids[ta])\n            d2 = self._distance(p, q, t_centroids[tb])\n            if t_rad[ta] >= d1 and t_rad[tb] >= d2:\n                adj_mat[ta, tb] = pore + 1\ntfill_angle = cpf + '.alpha'\npairs = np.asarray([list(key) for key in adj_mat.keys()])\npores = np.asarray([adj_mat[key] for key in adj_mat.keys()]) - 1\nself.tt_Pc = adj_mat.copy().astype(float).tocsr()\nself.tt_Pc[pairs[:, (0)], pairs[:, (1)]] = np.nan\nangles = self._throat_pair_angle(pairs[:, (0)], pairs[:, (1)], pores, net)\nT1 = pairs[:, (0)]\nT2 = pairs[:, (1)]\nhits = []\nfor Pc in inv_points:\n    if Pc == 0.0:\n        Pc = 1e-06\n    for phys in all_phys:\n        phys.models[cpf]['target_Pc'] = Pc\n        phys.regenerate_models(propnames=cpf)\n    check_nans = np.asarray(np.isnan(self.tt_Pc[T1, T2]).tolist()[0])\n    fill_angle_sum = np.sum(phase[tfill_angle][pairs], axis=1)\n    coalescence = fill_angle_sum >= angles\n    mask = check_nans * coalescence\n    if np.any(mask):\n        self.tt_Pc[T1[mask], T2[mask]] = Pc\n        hits.append(Pc)\nlogger.info('Coop filling finished in ' + str(np.around(time.time() - start,\n    2)) + ' s')\nlogger.info('Coop Hits', np.unique(np.asarray(hits)))\n"
}
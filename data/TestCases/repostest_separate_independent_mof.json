{
    "functionName": "test_separate_independent_mof",
    "className": null,
    "fileName": "/GPflow_&_GPflow/tests_&_gpflow_&_conditionals_&_test_multioutput.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "\"\"\"\n    Same test as above but we use different (i.e. separate) inducing inducing\n    for each of the output dimensions.\n    \"\"\"\nnp.random.seed(0)\nq_mu_1 = np.random.randn(Data.M * Data.P, 1)\nq_sqrt_1 = np.tril(np.random.randn(Data.M * Data.P, Data.M * Data.P))[None, ...\n    ]\nkernel_1 = mk.SharedIndependent(SquaredExponential(variance=0.5,\n    lengthscales=1.2), Data.P)\ninducing_variable_1 = InducingPoints(Data.X[:Data.M, (...)])\nmodel_1 = SVGP(kernel_1, Gaussian(), inducing_variable_1, q_mu=q_mu_1,\n    q_sqrt=q_sqrt_1)\nset_trainable(model_1, False)\nset_trainable(model_1.q_sqrt, True)\nset_trainable(model_1.q_mu, True)\ngpflow.optimizers.Scipy().minimize(model_1.training_loss_closure(Data.data),\n    variables=model_1.trainable_variables, method='BFGS', compile=True)\nq_mu_2 = np.random.randn(Data.M, Data.P)\nq_sqrt_2 = np.array([np.tril(np.random.randn(Data.M, Data.M)) for _ in\n    range(Data.P)])\nkernel_2 = mk.SharedIndependent(SquaredExponential(variance=0.5,\n    lengthscales=1.2), Data.P)\ninducing_variable_list_2 = [InducingPoints(Data.X[:Data.M, (...)]) for _ in\n    range(Data.P)]\ninducing_variable_2 = mf.SeparateIndependentInducingVariables(\n    inducing_variable_list_2)\nmodel_2 = SVGP(kernel_2, Gaussian(), inducing_variable_2, q_mu=q_mu_2,\n    q_sqrt=q_sqrt_2)\nset_trainable(model_2, False)\nset_trainable(model_2.q_sqrt, True)\nset_trainable(model_2.q_mu, True)\ngpflow.optimizers.Scipy().minimize(model_2.training_loss_closure(Data.data),\n    variables=model_2.trainable_variables, method='BFGS', compile=True)\nq_mu_3 = np.random.randn(Data.M, Data.P)\nq_sqrt_3 = np.array([np.tril(np.random.randn(Data.M, Data.M)) for _ in\n    range(Data.P)])\nkern_list = [SquaredExponential(variance=0.5, lengthscales=1.2) for _ in\n    range(Data.P)]\nkernel_3 = mk.SeparateIndependent(kern_list)\ninducing_variable_list_3 = [InducingPoints(Data.X[:Data.M, (...)]) for _ in\n    range(Data.P)]\ninducing_variable_3 = mf.SeparateIndependentInducingVariables(\n    inducing_variable_list_3)\nmodel_3 = SVGP(kernel_3, Gaussian(), inducing_variable_3, q_mu=q_mu_3,\n    q_sqrt=q_sqrt_3)\nset_trainable(model_3, False)\nset_trainable(model_3.q_sqrt, True)\nset_trainable(model_3.q_mu, True)\ngpflow.optimizers.Scipy().minimize(model_3.training_loss_closure(Data.data),\n    variables=model_3.trainable_variables, method='BFGS', compile=True)\ncheck_equality_predictions(Data.data, [model_1, model_2, model_3])\n"
}
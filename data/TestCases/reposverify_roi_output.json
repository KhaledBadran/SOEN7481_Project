{
    "functionName": "verify_roi_output",
    "className": "_FitXRFMapTesting",
    "fileName": "/NSLS-II_&_PyXRF/pyxrf_&_core_&_tests_&_test_map_processing.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n        Verify computated ROI. Computation of ROI is repeated in this function.\n        Call with the same value of `snip_param` as the one sent to ROI computing function.\n        It may be different from autogenerated `self.snip_param`.\n\n        Parameters\n        ----------\n        data_out: dict\n            Dictionary: key - emission line, value - 2D array with ROI values\n        roi_dict: dict\n            Dictionary: key - emission line, value - tuple (left_val, right_val)\n            Energy values are in keV.\n        snip_param: dict\n            Parameters for SNIP algorithm for background subtraction. See `self.snip_param`\n            defined in the constructor for the example. The values are used for subtracting\n            baseline and for finding ranges of indices to define bands.\n        \"\"\"\ne_offset = snip_param['e_offset']\ne_linear = snip_param['e_linear']\n_data = np.moveaxis(self.data_tmp, 0, 2)\nif self.use_snip:\n    bg_sel = np.zeros(shape=_data.shape)\n    for ny in range(bg_sel.shape[0]):\n        for nx in range(bg_sel.shape[1]):\n            bg = snip_method_numba(_data[(ny), (nx), :], snip_param[\n                'e_offset'], snip_param['e_linear'], snip_param[\n                'e_quadratic'], width=snip_param['b_width'])\n            bg_sel[(ny), (nx), :] = bg\n    _data = _data - bg_sel\ndata_expected = {}\nfor eline in roi_dict.keys():\n    vleft, vright = roi_dict[eline]\n    n_left = int(round((vleft - e_offset) / e_linear)) - self.add_pts_before\n    n_right = int(round((vright - e_offset) / e_linear)) - self.add_pts_before\n    n_left = int(np.clip(n_left, a_min=0, a_max=_data.shape[2] - 1))\n    n_right = int(np.clip(n_right, a_min=0, a_max=_data.shape[2] - 1))\n    if n_right > n_left:\n        data_expected[eline] = np.sum(_data[:, :, n_left:n_right], axis=2)\n    else:\n        data_expected[eline] = np.zeros(shape=_data.shape[0:2])\nassert list(data_out.keys()) == list(data_expected.keys()\n    ), 'The list of output data keys is different from expected'\nfor key in data_out.keys():\n    npt.assert_array_almost_equal(data_out[key], data_expected[key],\n        err_msg=\n        f\"Output ROI count for the key '{key}' is different from expected\")\n"
}
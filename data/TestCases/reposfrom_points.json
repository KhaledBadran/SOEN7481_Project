{
    "functionName": "from_points",
    "className": "RotatedBox",
    "fileName": "/konstantint_&_PassportEye/passporteye_&_util_&_geometry.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n        Interpret a given point cloud as a RotatedBox, using PCA to determine the potential orientation (the longest component becomes width)\n        This is basically an approximate version of a min-area-rectangle algorithm.\n        TODO: Test whether using a true min-area-rectangle algorithm would be more precise or faster.\n\n        :param points: An n x 2 numpy array of coordinates.\n        :param box_type: The kind of method used to estimate the \"box\".\n            Possible values:\n                - `'bb'`, denoting the \"bounding box\" approach (min/max coordinates of the points correspond to box limits)\n                - `'mrz`, denoting a slightly modified technique, suited for MRZ zone detection from contour images.\n                          Here the assumption is that the upper and lower bounds of the box are better estimated as the\n                          10% and 90% quantile of the corresponding coordinates (rather than 0% and 100%, i.e. min and max).\n                          This helps against accidental noise in the contour.\n                          The `'mrz'` correction is only applied when there are at least 10 points in the set.\n        :returns: a RotatedBox, bounding the given set of points, oriented according to the principal components.\n\n        >>> RotatedBox.from_points([[0,0]])\n        RotatedBox(cx=0.0, cy=0.0, width=0.0, height=0.0, angle=0.0)\n        >>> assert RotatedBox.from_points([[0,0], [1,1], [2,2]]).approx_equal([1, 1], np.sqrt(8), 0, np.pi/4)\n        >>> assert RotatedBox.from_points([[0,0], [1,1], [0,1], [1,0]]).approx_equal([0.5, 0.5], 1, 1, 0.0) # The angle is rather arbitrary here\n        >>> assert RotatedBox.from_points([[0,0], [2,1], [0,1], [2,0]]).approx_equal([1, 0.5], 2, 1, 0)\n        >>> assert RotatedBox.from_points([[0,0], [2,4], [0,4], [2,0]]).approx_equal([1, 2], 4, 2, np.pi/2)\n        >>> assert RotatedBox.from_points([[0,0], [1,1.5], [2,0]]).approx_equal([1, 0.75], 2, 1.5, 0)\n        >>> assert RotatedBox.from_points([[0,0], [0,1], [1,1]]).approx_equal([0.25, 0.75], np.sqrt(2), np.sqrt(2)/2, np.pi/4)\n        \"\"\"\npoints = np.asfarray(points)\nif points.shape[0] == 1:\n    return RotatedBox(points[0], width=0.0, height=0.0, angle=0.0, points=\n        points)\nm = PCA(2).fit(points)\nangle = np.arctan2(m.components_[0, 1], m.components_[0, 0]) % np.pi\nif abs(angle - np.pi) < angle:\n    angle = angle - np.pi if angle > 0 else angle + np.pi\npoints_transformed = m.transform(points)\nll = np.min(points_transformed, 0)\nur = np.max(points_transformed, 0)\nwh = ur - ll\nif box_type == 'bb' or box_type == 'mrz' and points.shape[0] < 10:\n    return RotatedBox(np.dot(m.components_.T, (ll + ur) / 2) + m.mean_,\n        width=wh[0], height=wh[1], angle=angle, points=points)\nelif box_type == 'mrz':\n    h_coord = sorted(points_transformed[:, (1)])\n    n = len(h_coord)\n    bottom, top = h_coord[n / 10], h_coord[n * 9 / 10]\n    valid_points = np.logical_and(points_transformed[:, (1)] >= bottom, \n        points_transformed[:, (1)] <= top)\n    rb = RotatedBox.from_points(points[(valid_points), :], 'bb')\n    rb.points = points\n    return rb\nelse:\n    raise ValueError('Unknown parameter value: box_type=%s' % box_type)\nstaticmethod"
}
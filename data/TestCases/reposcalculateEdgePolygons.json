{
    "functionName": "calculateEdgePolygons",
    "className": "DataFile",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataFile.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Method to calculate bounding polygon for all energies. The energies are split using the bin-edges method of DataSet. Hereafter,\n        the outer most points are found in polar coordinates and a possible addition is made creating the padded bounding polygon.\n        \n        Kwargs:\n            \n            - addEdge (bool/float): If true, padding is found as difference between outer and next outer point. If addEdge is a number, generate padding a padding of this value (default True)\n            \n        Returns:\n            \n            - edgePolygon (list): List of shapely polygons of the boundary\n            \n            - EBins (list): Binning edges in energy\n            \n        \"\"\"\nif addEdge:\n    if np.isclose(float(addEdge), 1.0):\n        addEdgeAmount = None\n    else:\n        addEdgeAmount = addEdge\nEnergy = self.energy\nE = np.sort(np.mean(self.energy, axis=(0, 1)))\ndif = np.diff(E) * 0.5\nEBins = np.concatenate([[E[0] - dif[0]], E[:-1] + dif, [E[-1] + dif[-1]]])\nsteps = Energy.shape[0]\nedgePolygon = []\nfor ELow, EHigh in zip(EBins, EBins[1:]):\n    EBool = np.logical_and(Energy > ELow, Energy < EHigh)\n    x = self.qx[EBool]\n    y = self.qy[EBool]\n    r = np.linalg.norm([x, y], axis=0)\n    theta = np.arctan2(y, x)\n    rBins = _tools.binEdges(r, 1e-05)\n    out = -1\n    while np.sum(r > rBins[out]) < steps:\n        out -= 1\n    rOuter = r > rBins[out]\n    inner = 0\n    while np.sum(r < rBins[inner]) < steps:\n        inner += 1\n    rInner = r < rBins[inner]\n    minEdge = []\n    maxEdge = []\n    _minEdge = []\n    _maxEdge = []\n    include = 0\n    for j in range(len(rBins) - 1):\n        Bool = np.logical_and(r > rBins[j - include], r < rBins[j + 1])\n        if np.sum(Bool) < steps - 1:\n            include += 1\n            continue\n        else:\n            include = 0\n        TT = theta[Bool]\n        dif = np.diff(TT)\n        if np.max(abs(dif)) > np.pi * 1.9:\n            idx = np.argmax(abs(dif))\n            TT[idx + 1:] += -np.sign(dif[idx]) * 2 * np.pi\n        minT, maxT = _tools.minMax(TT)\n        _minT, _maxT = _tools.minMax(TT)\n        if addEdge:\n            mint, maxt = _tools.minMax(TT[np.logical_not(np.logical_or(np.\n                isclose(TT, minT), np.isclose(TT, maxT)))])\n            if addEdgeAmount is None:\n                minT = minT - 0.5 * (mint - minT)\n                maxT = maxT - 0.5 * (maxt - maxT)\n            else:\n                minT = minT + np.sign(minT - mint) * addEdgeAmount\n                maxT = maxT + np.sign(maxT - maxt) * addEdgeAmount\n        R = np.mean(r[Bool])\n        minEdge.append([R * np.cos(minT), R * np.sin(minT)])\n        maxEdge.append([R * np.cos(maxT), R * np.sin(maxT)])\n        _minEdge.append([R * np.cos(_minT), R * np.sin(_minT)])\n        _maxEdge.append([R * np.cos(_maxT), R * np.sin(_maxT)])\n    minEdge = np.array(minEdge).T\n    maxEdge = np.array(maxEdge).T\n    innerPoints = np.array([x[rInner], y[rInner]])\n    _innerPoints = np.array([x[rInner], y[rInner]])\n    if addEdge:\n        if addEdgeAmount is None:\n            RR = rBins[inner] - (rBins[inner + 1] - rBins[inner])\n        else:\n            RR = rBins[inner] - addEdgeAmount\n        Theta = np.arctan2(innerPoints[1], innerPoints[0])\n        innerPoints = np.array([np.cos(Theta), np.sin(Theta)]) * RR\n    outerPoints = np.array([x[rOuter], y[rOuter]])\n    _outerPoints = np.array([x[rOuter], y[rOuter]])\n    if addEdge:\n        if addEdgeAmount is None:\n            RR = rBins[out] - (rBins[out - 1] - rBins[out])\n        else:\n            RR = rBins[out] + addEdgeAmount\n        Theta = np.arctan2(outerPoints[1], outerPoints[0])\n        outerPoints = np.array([np.cos(Theta), np.sin(Theta)]) * RR\n    refvec1, center1 = _tools.calRefVector(innerPoints)\n    refvec2, center2 = _tools.calRefVector(outerPoints)\n    sInnerEdge = np.array(sorted(innerPoints.T, key=lambda x: _tools.\n        clockwiseangle_and_distance(x, origin=center1, refvec=refvec1))).T\n    sOuterEdge = np.array(sorted(outerPoints.T, key=lambda x: _tools.\n        clockwiseangle_and_distance(x, origin=center2, refvec=refvec2))).T\n    sMinEdge = np.array(sorted(minEdge.T, key=np.linalg.norm)).T\n    sMaxEdge = np.array(sorted(maxEdge.T, key=np.linalg.norm)).T\n    XY = np.concatenate([sInnerEdge, sMinEdge, np.fliplr(sOuterEdge), np.\n        fliplr(sMaxEdge)], axis=1)\n    edgePolygon.append(shapely.geometry.polygon.Polygon(XY.T))\n    originalPoints = np.concatenate([_innerPoints.T, _outerPoints.T,\n        _minEdge, _maxEdge], axis=0)\n    pointsContained = np.sum([edgePolygon[-1].contains(PointS(\n        originalPoints[I][0], originalPoints[I][1])) for I in range(\n        originalPoints.shape[0])])\n    if pointsContained != originalPoints.shape[0]:\n        inside = np.array([edgePolygon[-1].contains(PointS(originalPoints[I\n            ][0], originalPoints[I][1])) for I in range(originalPoints.\n            shape[0])])\n        outside = np.logical_not(inside)\n        plt.figure()\n        plt.scatter(x, y, c='k')\n        plt.scatter(originalPoints[inside][:, (0)], originalPoints[inside][\n            :, (1)], c='g')\n        plt.scatter(originalPoints[outside][:, (0)], originalPoints[outside\n            ][:, (1)], c='r', zorder=100)\n        plt.plot(np.array(edgePolygon[-1].boundary.coords)[:, (0)], np.\n            array(edgePolygon[-1].boundary.coords)[:, (1)], c='r')\n        plt.title(i)\n        raise AttributeError(\n            'Error! {} points are outside the found shape with energy !'.\n            format(np.sum(outside), 0.5 * (EBins[i] + EBins[i + 1])))\nreturn edgePolygon, EBins\n_tools.KwargChecker()"
}
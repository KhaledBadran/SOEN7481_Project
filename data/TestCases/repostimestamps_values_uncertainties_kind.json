{
    "functionName": "timestamps_values_uncertainties_kind",
    "className": null,
    "fileName": "/PTB-PSt1_&_PyDynamic/test_&_test_interpolate.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "\"\"\"Set custom strategy for _hypothesis_ to draw desired input from\n\n    Parameters\n    ----------\n        draw : callable\n            this is a hypothesis internal callable to actually draw from provided\n            strategies\n        min_count : int, optional\n            the minimum number of elements expected inside the arrays of timestamps\n             (or frequencies), measurement values and associated uncertainties.\n             (default = 2)\n        max_count : int, optional\n            the maximum number of elements expected inside the arrays of timestamps\n            (or frequencies), measurement values and associated uncertainties\n            (default is None)\n        kind_tuple : tuple(str), optional\n            the tuple of strings out of \"linear\", \"previous\", \"next\", \"nearest\",\n            \"spline\", \"least-squares\" from which the strategy for the\n            kind randomly chooses. Defaults to the valid options \"linear\",\n            \"previous\", \"next\", \"nearest\"\n        sorted_timestamps : bool, optional\n            if True (default) the timestamps (or frequencies) are guaranteed to be in\n            ascending order, if False they still might be by coincidence or not\n        extrapolate : bool or str, optional\n            If True the interpolation timestamps (or frequencies) are generated such\n            that extrapolation is necessary by guarantying at least one of the\n            interpolation timestamps (or frequencies) outside the original bounds\n            and accordingly setting appropriate values for `fill_value` and\n            `bounds_error = False`. If False (default) each element of t_new is\n            guaranteed to lie within the range of t. Can be set to \"above\" or \"below\"\n            to guarantee at least one element of t_new to lie either below or above\n            the bounds of t.\n        restrict_fill_value : str, optional\n            String specifying the desired strategy for drawing a fill_value. One of\n            \"float\", \"tuple\", \"str\", \"nan\" to guarantee either a float, a tuple of\n            two floats, the string \"extrapolate\" or np.nan. (default is None)\n        restrict_fill_unc : str, optional\n            Same as fill_value, but just for the uncertainties. (default is None)\n        returnC : bool, optional\n            If True we request the sensitivities to be returned. If False (default) we\n            do not request them.\n        for_make_equidistant : bool, optional\n            If True we return the expected parameters for calling `make_equidistant()`.\n            If False (default) we return the expected parameters for calling\n            `interp1d_unc()`.\n\n    Returns\n    -------\n        A dict containing the randomly generated expected input parameters for\n        `interp1d_unc()`\n    \"\"\"\ndef draw_fill_values(strategy_spec: str):\n    \"\"\"Little helper to find proper strategy for efficient testing.\n\n        Parameters\n        ----------\n            strategy_spec : str\n                String specifying the desired strategy for drawing a fill_value. One of\n                \"float\", \"tuple\", \"str\", \"nan\" to guarantee either a float, a tuple of\n                two floats, the string \"extrapolate\" or np.nan.\n\n        Returns\n        -------\n            The drawn sample to match desired fill_value.\n        \"\"\"\n    float_strategy = st.floats(**float_generic_params)\n    tuple_strategy = st.tuples(float_strategy, float_strategy)\n    string_strategy = st.just('extrapolate')\n    nan_strategy = st.just(np.nan)\n    if strategy_spec == 'float':\n        fill_strategy = float_strategy\n    elif strategy_spec == 'tuple':\n        fill_strategy = tuple_strategy\n    elif strategy_spec == 'str':\n        fill_strategy = string_strategy\n    elif strategy_spec == 'nan':\n        fill_strategy = nan_strategy\n    else:\n        fill_strategy = st.one_of(float_strategy, tuple_strategy,\n            string_strategy, nan_strategy)\n    return draw(fill_strategy)\nfloat_abs_max = 1e+64\nfloat_generic_params = {'allow_nan': False, 'allow_infinity': False}\nshape_for_timestamps = hnp.array_shapes(max_dims=1, min_side=min_count,\n    max_side=max_count)\nstrategy_params = {'dtype': np.float, 'shape': shape_for_timestamps,\n    'elements': st.floats(min_value=-float_abs_max, max_value=float_abs_max,\n    **float_generic_params), 'unique': True}\nt = draw(hnp.arrays(**strategy_params))\nif sorted_timestamps:\n    ind = np.argsort(t)\n    t = t[ind]\nstrategy_params['shape'] = np.shape(t)\ny = draw(hnp.arrays(**strategy_params))\nuy = draw(hnp.arrays(**strategy_params))\nkind = draw(st.sampled_from(kind_tuple))\nif for_make_equidistant:\n    dt = draw(st.floats(min_value=(np.max(t) - np.min(t)) * 0.001,\n        max_value=(np.max(t) - np.min(t)) / 2, exclude_min=True, allow_nan=\n        False, allow_infinity=False))\n    return {'t': t, 'y': y, 'uy': uy, 'dt': dt, 'kind': kind}\nelse:\n    strategy_params['shape'] = shape_for_timestamps\n    t_min = np.min(t)\n    t_max = np.max(t)\n    if not extrapolate:\n        strategy_params['elements'] = st.floats(min_value=t_min, max_value=\n            t_max, **float_generic_params)\n        fill_value = fill_unc = np.nan\n        bounds_error = True\n    else:\n        fill_value = draw_fill_values(restrict_fill_value)\n        fill_unc = draw_fill_values(restrict_fill_unc)\n        bounds_error = False\n    t_new = draw(hnp.arrays(**strategy_params))\n    if extrapolate:\n        assume(np.min(t_new) < np.min(t) or np.max(t_new) > np.max(t))\n        if extrapolate == 'above':\n            assume(np.max(t_new) > np.max(t))\n        else:\n            assume(np.min(t_new) < np.min(t))\n    assume_sorted = sorted_timestamps\n    return {'t_new': t_new, 't': t, 'y': y, 'uy': uy, 'kind': kind,\n        'fill_value': fill_value, 'fill_unc': fill_unc, 'bounds_error':\n        bounds_error, 'assume_sorted': assume_sorted, 'returnC': returnC}\ncomposite"
}
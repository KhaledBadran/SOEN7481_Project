{
    "functionName": "plotCut1D",
    "className": "DataSet",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"plot new or already performed cut.\n        \n        Args:\n                \n                - q1 (3D or 2D array): Start position of cut in format (h,k,l) or (qx,qy) depending on rlu flag.\n                \n                - q2 (3D or 2D array): End position of cut in format (h,k,l) or (qx,qy) depending on rlu flag.\n                \n                - width (float): Full width of cut in q-plane in 1/AA, only needed for new cut (default None)\n                \n                - minPixel (float): Minimal size of binning along the cutting direction. Points will be binned if they are closer than minPixel.\n\n                - Emin (float): Minimal energy to include in cut.\n                \n                - Emax (float): Maximal energy to include in cut.\n                \n            Kwargs:\n                \n                - Data (pandas Dataframe): Data, if previously made cut is to be plotted (default None)\n                \n                - rlu (bool): If True, coordinates given are interpreted as (h,k,l) otherwise as (qx,qy)\n        \n                - extend (bool): Whether or not the cut from q1 to q2 is to be extended throughout the data (default true)\n                \n                - plotCoverage (bool): If True, generates plot of all points in the cutting plane and adds bounding box of cut (default False).\n        \n                - dataFiles (list): List of dataFiles to cut (default None). If none, the ones in the object will be used.\n        \n                - constantBins (bool): If True only bins of size minPixel is used (default False)\n        \n        \"\"\"\nif Data is None:\n    Data, bins = self.cut1D(q1=q1, q2=q2, width=width, minPixel=minPixel,\n        Emin=Emin, Emax=Emax, rlu=rlu, plotCoverage=plotCoverage,\n        constantBins=constantBins)\nwith warnings.catch_warnings():\n    warnings.simplefilter('ignore')\n    INT = np.divide(Data['Intensity'] * Data['BinCount'], Data['Monitor'] *\n        Data['Normalization'])\n    INT_err = np.divide(np.sqrt(Data['Intensity']) * Data['BinCount'], Data\n        ['Monitor'] * Data['Normalization'])\nnum = len(Data)\nq1 = np.array(q1, dtype=float)\nq2 = np.array(q2, dtype=float)\nif rlu:\n    variables = ['H', 'K', 'L']\nelse:\n    variables = ['Qx', 'Qy']\nvariables = variables + ['Energy']\nif not 'ticks' in kwargs:\n    ticks = 5\nelse:\n    ticks = kwargs['ticks']\n    kwargs = _tools.without_keys(dictionary=kwargs, keys='ticks')\nif not 'tickRound' in kwargs:\n    tickRound = 3\nelse:\n    tickRound = kwargs['tickRound']\n    kwargs = _tools.without_keys(dictionary=kwargs, keys='tickRound')\nif not 'fmt' in kwargs:\n    kwargs['fmt'] = '.'\nxvalues = np.round(np.linspace(0, num - 1, ticks)).astype(int)\nmy_xticks = []\nfor i in xvalues:\n    my_xticks.append('\\n'.join(map(lambda x: ('{:.' + str(tickRound) + 'f}'\n        ).format(x), [np.round(Data[var][i], tickRound) for var in variables]))\n        )\nData['binDistance'] = np.linalg.norm(Data[variables] - np.array(Data[\n    variables].iloc[1]), axis=1)\nif ax is None:\n    plt.figure()\n    ax = plt.gca()\nif not 'label' in kwargs:\n    kwargs['label'] = 'Data'\nax.errorbar(Data['binDistance'], INT, yerr=INT_err, **kwargs)\nax.set_xticks(Data['binDistance'].iloc[xvalues])\nax.set_xticklabels(my_xticks, multialignment='center', ha='center')\ndef calculateIndex(binDistance, x):\n    idx = np.argmin(np.abs(binDistance - x))\n    return idx\nax.calculateIndex = lambda x: calculateIndex(Data['binDistance'], x)\nif rlu == False:\n    ax.set_xlabel('$Q_x [\\\\AA^{-1}]$' + '\\n' + '$Q_y [\\\\AA^{-1}]$' + '\\n' +\n        'E [meV]')\n\n    def format_coord(x, y, ax, binCenter):\n        index = ax.calculateIndex(x)\n        qx, qy, E = binCenter[index]\n        return 'qx = {0:.3e}, qy = {1:.3e}, E = {2:.3f}, I = {3:0.4e}'.format(\n            qx, qy, E, y)\nelse:\n\n    def format_coord(x, y, ax, binCenter):\n        index = ax.calculateIndex(x)\n        h, k, l, E = binCenter[index]\n        return (\n            'H = {0:.3e}, K = {1:.3e}, L = {2:.3e}, E = {3:.3f}, I = {4:0.4e}'\n            .format(h, k, l, E, y))\n    ax.set_xlabel('$Q_h$ [RLU]\\n$Q_k$ [RLU]\\n$Q_l$ [RLU]\\nE [meV]')\ndef onclick(event, ax, Data):\n    if ax.in_axes(event):\n        try:\n            C = ax.get_figure().canvas.cursor().shape()\n        except:\n            pass\n        else:\n            if C != 0:\n                return\n        x = event.xdata\n        y = event.ydata\n        printString = ax.format_coord(x, y)\n        index = ax.calculateIndex(x)\n        cts = int(Data['Intensity'][index])\n        Mon = int(Data['Monitor'][0])\n        Norm = float(Data['Normalization'][0])\n        NC = int(Data['BinCount'][0])\n        printString += (\n            ', Cts = {:d}, Norm = {:.3f}, Mon = {:d}, NormCount = {:d}'.\n            format(cts, Norm, int(Mon), NC))\n        print(printString)\nax.xaxis.set_label_coords(1.15, -0.025)\nax.set_ylabel('$I$ [arb.u.]')\nplt.tight_layout()\nax.format_coord = lambda x, y: format_coord(x, y, ax, np.array(Data[variables])\n    )\nax._button_press_event = ax.figure.canvas.mpl_connect('button_press_event',\n    lambda event: onclick(event, ax, Data))\nif ufit == True:\n    print(Emin, Emax)\n    ufitdata = self.generateUFitDataset(pdData=Data, q1=q1, q2=q2, rlu=rlu,\n        width=width, Emin=Emin, Emax=Emax, minPixel=minPixel)\n    return ax, ufitdata\nreturn ax, Data, bins\n_tools.KwargChecker(function=plt.errorbar, include=np.concatenate([_tools.\n    MPLKwargs, ['ticks', 'tickRound', 'mfc', 'markeredgewidth', 'markersize']])\n    )"
}
{
    "functionName": "find_neighbor_bonds",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_topotools_&_topotools.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Given an incidence matrix, finds all sites that are connected to the\n    input sites.\n\n    This function accepts either an incidence or adjacency matrix.\n\n    Parameters\n    ----------\n    im : scipy.sparse matrix\n        The incidence matrix of the network.  Must be shaped as (N-sites,\n        N-bonds), with non-zeros indicating which sites are connected. Either\n        ``am`` or ``im`` must be given.  Passing in ``im`` is slower, but more\n        powerful as it allows for an unflattened list of neighbors.\n\n    am : scipy.sparse matrix (optional)\n        The adjacency matrix of the network. Either ``am`` or ``im`` must be\n        given.  Passing in ``am`` is faster, but does not allow for an\n        unflattened list.\n\n    flatten : boolean (default is ``True``)\n        Indicates whether the returned result is a compressed array of all\n        neighbors, or a list of lists with each sub-list containing the\n        neighbors for each input site.  Note that an *unflattened* list might\n        be slow to generate since it is a Python ``list`` rather than a Numpy\n        array.\n\n    logic : string\n        Specifies logic to filter the resulting list.  Options are:\n\n        **'or'** : (default) All neighbors of the input sites.  This is also\n        known as the 'union' in set theory or 'any' in boolean logic.  Both\n        keywords are accepted and treated as 'or'.\n\n        **'xor'** : Only neighbors of one and only one input site.  This is\n        useful for finding the sites that are not shared by any of the input\n        sites.  'exclusive_or' is also accepted'.\n\n        **'xnor'** : Neighbors that are shared by two or more input sites. This\n        is equivalent to finding all neighbors with 'or', minus those found\n        with 'xor', and is useful for finding neighbors that the inputs have\n        in common.  'nxor' is also accepted.\n\n        **'and'** : Only neighbors shared by all input sites.  This is also\n        known as 'intersection' in set theory and (somtimes) as 'all' in\n        boolean logic.  Both keywords are accepted and treated as 'and'.\n\n    Returns\n    -------\n    An array containing the neighboring bonds filtered by the given logic.  If\n    ``flatten`` is ``False`` then the result is a list of lists containing the\n    neighbors of each given input site.\n\n    See Also\n    --------\n    find_complement\n\n    Notes\n    -----\n    The ``logic`` options are applied to neighboring bonds only, thus it is not\n    possible to obtain bonds that are part of the global set but not neighbors.\n    This is because (a) the list of global bonds might be very large, and\n    (b) it is not possible to return a list of neighbors for each input site\n    if global sites are considered.\n\n    \"\"\"\nif im is not None:\n    if im.format != 'lil':\n        im = im.tolil(copy=False)\n    rows = [im.rows[i] for i in np.array(sites, ndmin=1, dtype=np.int64)]\n    if len(rows) == 0:\n        return []\n    neighbors = np.hstack(rows).astype(np.int64)\n    n_bonds = int(im.nnz / 2)\n    if logic in ['or', 'union', 'any']:\n        neighbors = np.unique(neighbors)\n    elif logic in ['xor', 'exclusive_or']:\n        neighbors = np.unique(np.where(np.bincount(neighbors) == 1)[0])\n    elif logic in ['xnor', 'shared']:\n        neighbors = np.unique(np.where(np.bincount(neighbors) > 1)[0])\n    elif logic in ['and', 'all', 'intersection']:\n        neighbors = set(neighbors)\n        [neighbors.intersection_update(i) for i in rows]\n        neighbors = np.array(list(neighbors), dtype=int, ndmin=1)\n    else:\n        raise Exception('Specified logic is not implemented')\n    if flatten is False:\n        if neighbors.size > 0:\n            mask = np.zeros(shape=n_bonds, dtype=bool)\n            mask[neighbors] = True\n            for i in range(len(rows)):\n                vals = np.array(rows[i], dtype=np.int64)\n                rows[i] = vals[mask[vals]]\n            neighbors = rows\n        else:\n            neighbors = [np.array([], dtype=np.int64) for i in range(len(\n                sites))]\n    return neighbors\nelif am is not None:\n    if am.format != 'coo':\n        am = am.tocoo(copy=False)\n    if not istriu(am):\n        am = sp.sparse.triu(am, k=1)\n    if flatten is False:\n        raise Exception('flatten cannot be used with an adjacency matrix')\n    Ps = np.zeros(am.shape[0], dtype=bool)\n    Ps[sites] = True\n    conns = np.vstack((am.row, am.col)).T\n    if logic in ['or', 'union', 'any']:\n        neighbors = np.any(Ps[conns], axis=1)\n    elif logic in ['xor', 'exclusive_or']:\n        neighbors = np.sum(Ps[conns], axis=1) == 1\n    elif logic in ['xnor', 'shared']:\n        neighbors = np.all(Ps[conns], axis=1)\n    elif logic in ['and', 'all', 'intersection']:\n        raise Exception('Specified logic is not implemented')\n    else:\n        raise Exception('Specified logic is not implemented')\n    neighbors = np.where(neighbors)[0]\n    return neighbors\nelse:\n    raise Exception('Either the incidence or the adjacency matrix must ' +\n        'must be specified')\n"
}
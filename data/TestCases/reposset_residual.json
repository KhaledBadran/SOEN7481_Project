{
    "functionName": "set_residual",
    "className": "MixedInvasionPercolation",
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_algorithms_&_MixedInvasionPercolation.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n        Method to start invasion in a network w. residual saturation.\n        Called after inlets are set.\n\n        Parameters\n        ----------\n        pores : array_like\n            The pores locations that are to be filled with invader at the\n            beginning of the simulation.\n\n        overwrite : boolean\n            If ``True`` then all existing inlet locations will be removed and\n            then the supplied locations will be added.  If ``False``, then\n            supplied locations are added to any already existing locations.\n\n        Notes\n        -----\n        Currently works for pores only and treats inner throats, i.e.\n        those that connect two pores in the cluster as invaded and outer ones\n        as uninvaded. Uninvaded throats are added to a new residual cluster\n        queue but do not start invading independently if not connected to an\n        inlet.\n\n        Step 1. Identify clusters in the phase occupancy.\n        Step 2. Look for clusters that are connected or contain an inlet\n        Step 3. For those that are merge into inlet cluster. May be connected\n        to more than one - run should sort this out\n        Step 4. For those that are isolated set the queue to not invading.\n        Step 5. (in run) When isolated cluster is met my invading cluster it\n        merges in and starts invading\n\n\n        \"\"\"\nPs = self._parse_indices(pores)\nif overwrite:\n    self['pore.residual'] = False\nself['pore.residual'][Ps] = True\nresidual = self['pore.residual']\nnet = self.project.network\nconns = net['throat.conns']\nrclusters = site_percolation(conns, residual).sites\nrcluster_ids = np.unique(rclusters[rclusters > -1])\ninitial_num = len(self.queue) - 1\nfor rcluster_id in rcluster_ids:\n    rPs = rclusters == rcluster_id\n    existing = np.unique(self['pore.cluster'][rPs])\n    existing = existing[existing > -1]\n    if len(existing) > 0:\n        cluster_num = existing[0]\n    else:\n        cluster_num = len(self.queue)\n        self.queue.append([])\n    queue = self.queue[cluster_num]\n    self['pore.cluster'][rPs] = cluster_num\n    Ts = net.find_neighbor_throats(pores=rPs, flatten=True, mode='xnor')\n    self['throat.cluster'][Ts] = cluster_num\n    self['pore.invasion_sequence'][rPs] = 0\n    self['throat.invasion_sequence'][Ts] = 0\n    self['pore.invasion_pressure'][rPs] = -np.inf\n    self['throat.invasion_pressure'][Ts] = -np.inf\n    Ts = net.find_neighbor_throats(pores=rPs, flatten=True, mode='exclusive_or'\n        )\n    for T in Ts:\n        data = []\n        data.append(self['throat.entry_pressure'][T])\n        data.append(T)\n        data.append('throat')\n        hq.heappush(queue, data)\nself.invasion_running = [True] * len(self.queue)\nfor c_num in range(len(self.queue)):\n    if c_num > initial_num:\n        self.invasion_running[c_num] = False\n"
}
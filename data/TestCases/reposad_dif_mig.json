{
    "functionName": "ad_dif_mig",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_models_&_physics_&_ad_dif_mig_conductance.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Calculate the advective-diffusive-migrative conductance of conduits\n    in network, where a conduit is ( 1/2 pore - full throat - 1/2 pore ).\n    See the notes section.\n\n    Parameters\n    ----------\n    target : OpenPNM Object\n        The object which this model is associated with. This controls the\n        length of the calculated array, and also provides access to other\n        necessary properties.\n\n    conduit_lengths : string\n        Dictionary key of the conduit length values\n\n    conduit_shape_factors : string\n        Dictionary key of the conduit DIFFUSION shape factor values\n\n    pore_pressure : string\n        Dictionary key of the pore pressure values\n\n    pore_potential : string\n        Dictionary key of the pore potential values\n\n    throat_hydraulic_conductance : string\n        Dictionary key of the throat hydraulic conductance values\n\n    throat_diffusive_conductance : string\n        Dictionary key of the throat diffusive conductance values\n\n    throat_valence : string\n        Dictionary key of the throat ionic species valence values\n\n    pore_temperature : string\n        Dictionary key of the pore temperature values\n\n    throat_temperature : string\n        Dictionary key of the throat temperature values\n\n    ion : string\n        Name of the ionic species\n\n    s_scheme : string\n        Name of the space discretization scheme to use\n\n    Returns\n    -------\n    g : ndarray\n        Array containing advective-diffusive-migrative conductance values for\n        conduits in the geometry attached to the given physics object.\n\n    Notes\n    -----\n    (1) This function requires that all the necessary phase properties already\n    be calculated.\n\n    (2) This function calculates the specified property for the *entire*\n    network then extracts the values for the appropriate throats at the end.\n\n    (3) This function assumes cylindrical throats with constant cross-section\n    area. Corrections for different shapes and variable cross-section area can\n    be imposed by passing the proper conduit_shape_factors argument.\n\n    (4) shape_factor depends on the physics of the problem, i.e. diffusion-like\n    processes and fluid flow need different shape factors.\n\n    \"\"\"\nthroat_diffusive_conductance = throat_diffusive_conductance + '.' + ion\nthroat_valence = throat_valence + '.' + ion\nnetwork = target.project.network\nthroats = network.map_throats(throats=target.Ts, origin=target)\nphase = target.project.find_phase(target)\ncn = network['throat.conns'][throats]\nL1 = network[conduit_lengths + '.pore1'][throats]\nLt = network[conduit_lengths + '.throat'][throats]\nL2 = network[conduit_lengths + '.pore2'][throats]\ng1, g2, gt = _np.zeros((3, len(Lt)))\nm1, m2, mt = [(Li != 0) for Li in [L1, L2, Lt]]\ng1[~m1] = g2[~m2] = gt[~mt] = _np.inf\ntry:\n    SF1 = phase[conduit_shape_factors + '.pore1'][throats]\n    SFt = phase[conduit_shape_factors + '.throat'][throats]\n    SF2 = phase[conduit_shape_factors + '.pore2'][throats]\nexcept KeyError:\n    SF1 = SF2 = SFt = 1.0\ntry:\n    T = phase[throat_temperature][throats]\nexcept KeyError:\n    T = phase.interpolate_data(propname=pore_temperature)[throats]\ntry:\n    P = phase[pore_pressure]\nexcept KeyError:\n    P = _np.zeros(shape=phase.Np, dtype=float)\ntry:\n    V = phase[pore_potential]\nexcept KeyError:\n    V = _np.zeros(shape=phase.Np, dtype=float)\nz = phase[throat_valence]\nF = 96485.3329\nR = 8.3145\ngh = phase[throat_hydraulic_conductance]\ngd = phase[throat_diffusive_conductance]\ngm = (gd.T * (z * F) / (R * T)).T\ndelta_V = _np.diff(V[cn], axis=1).squeeze()\ndelta_V = _np.append(delta_V, -delta_V)\nif gd.size == throats.size:\n    gd = _np.tile(gd, 2)\n    gm = _np.tile(gm, 2)\nelif gd.size == 2 * throats.size:\n    gd = gd.reshape(throats.size * 2, order='F')\n    gm = gm.reshape(throats.size * 2, order='F')\nelse:\n    raise Exception(\n        f'Shape of {throat_diffusive_conductance} must either be (Nt,1) or (Nt,2)'\n        )\nmig = gm * delta_V\nQij = -gh * _np.diff(P[cn], axis=1).squeeze()\nQij = _np.append(Qij, -Qij)\nadv_mig = Qij - mig\nPeij_adv_mig = adv_mig / gd\nPeij_adv = Qij / gd\nPeij_mig = mig / gd\nPeij_adv_mig[(Peij_adv_mig < 1e-10) & (Peij_adv_mig >= 0)] = 1e-10\nPeij_adv_mig[(Peij_adv_mig > -1e-10) & (Peij_adv_mig <= 0)] = -1e-10\nPeij_adv[(Peij_adv < 1e-10) & (Peij_adv >= 0)] = 1e-10\nPeij_adv[(Peij_adv > -1e-10) & (Peij_adv <= 0)] = -1e-10\nPeij_mig[(Peij_mig < 1e-10) & (Peij_mig >= 0)] = 1e-10\nPeij_mig[(Peij_mig > -1e-10) & (Peij_mig <= 0)] = -1e-10\nphase['throat.peclet.' + 'ad_mig.' + ion] = _np.absolute(Peij_adv_mig[0:len\n    (Lt)])\nphase['throat.peclet.' + 'ad.' + ion] = _np.absolute(Peij_adv[0:len(Lt)])\nphase['throat.peclet.' + 'mig.' + ion] = _np.absolute(Peij_mig[0:len(Lt)])\nadv_mig = Peij_adv_mig * gd\nif s_scheme == 'upwind':\n    w = gd + _np.maximum(0, -adv_mig)\nelif s_scheme == 'hybrid':\n    w = _np.maximum(0, _np.maximum(-adv_mig, gd - adv_mig / 2))\nelif s_scheme == 'powerlaw':\n    w = gd * _np.maximum(0, (1 - 0.1 * _np.absolute(Peij_adv_mig)) ** 5\n        ) + _np.maximum(0, -adv_mig)\nelif s_scheme == 'powerlaw_upwind':\n    w = gd * _np.maximum(0, (1 - 0.1 * _np.absolute(Peij_adv)) ** 5\n        ) + _np.maximum(0, -Qij) + _np.maximum(0, mig)\nelif s_scheme == 'exponential':\n    w = -adv_mig / (1 - _np.exp(Peij_adv_mig))\nelse:\n    raise Exception('Unrecognized discretization scheme: ' + s_scheme)\nw = w.reshape(throats.size, 2, order='F')\nreturn w\nreturn (1 / gt / SFt + 1 / g1 / SF1 + 1 / g2 / SF2) ** -1\n"
}
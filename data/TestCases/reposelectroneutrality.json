{
    "functionName": "electroneutrality",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_models_&_physics_&_ionic_conductance.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Calculate the ionic conductance of conduits in network (assuming\n    electroneutrality for charge conservation), where a conduit is\n    ( 1/2 pore - full throat - 1/2 pore ). See the notes section.\n\n    Parameters\n    ----------\n    target : OpenPNM Object\n        The object which this model is associated with. This controls the\n        length of the calculated array, and also provides access to other\n        necessary properties.\n\n    pore_area : string\n        Dictionary key of the pore area values\n\n    throat_area : string\n        Dictionary key of the throat area values\n\n    pore_diffusivity : string\n        Dictionary key of the pore diffusivity values\n\n    throat_diffusivity : string\n        Dictionary key of the throat diffusivity values\n\n    conduit_lengths : string\n        Dictionary key of the conduit length values\n\n    conduit_shape_factors : string\n        Dictionary key of the conduit DIFFUSION shape factor values\n\n    pore_volume : string\n        Dictionary key of the pore volume values\n\n    pore_temperature : string\n        Dictionary key of the pore temperature values\n\n    throat_temperature : string\n        Dictionary key of the throat temperature values\n\n    pore_valence : string\n       Dictionary key of the pore ionic species valence values\n\n    throat_valence : string\n       Dictionary key of the throat ionic species valence values\n\n    pore_concentration : string\n       Dictionary key of the pore ionic species concentration values\n\n    Returns\n    -------\n    g : ndarray\n        Array containing ionic conductance values for conduits in the\n        geometry attached to the given physics object.\n\n    Notes\n    -----\n    (1) This function requires that all the necessary phase properties already\n    be calculated.\n\n    (2) This function calculates the specified property for the *entire*\n    network then extracts the values for the appropriate throats at the end.\n\n    (3) This function assumes cylindrical throats with constant cross-section\n    area. Corrections for different shapes and variable cross-section area can\n    be imposed by passing the proper conduit_shape_factors argument.\n\n    (4) shape_factor depends on the physics of the problem, i.e. diffusion-like\n    processes and fluid flow need different shape factors.\n\n    \"\"\"\nnetwork = target.project.network\nthroats = network.map_throats(throats=target.Ts, origin=target)\nphase = target.project.find_phase(target)\ncn = network['throat.conns'][throats]\nA1 = network[pore_area][cn[:, (0)]]\nAt = network[throat_area][throats]\nA2 = network[pore_area][cn[:, (1)]]\nL1 = network[conduit_lengths + '.pore1'][throats]\nLt = network[conduit_lengths + '.throat'][throats]\nL2 = network[conduit_lengths + '.pore2'][throats]\ng1, g2, gt = _np.zeros((3, len(Lt)))\nm1, m2, mt = [(Li != 0) for Li in [L1, L2, Lt]]\ng1[~m1] = g2[~m2] = gt[~mt] = _np.inf\ntry:\n    SF1 = phase[conduit_shape_factors + '.pore1'][throats]\n    SFt = phase[conduit_shape_factors + '.throat'][throats]\n    SF2 = phase[conduit_shape_factors + '.pore2'][throats]\nexcept KeyError:\n    SF1 = SF2 = SFt = 1.0\nF = 96485.3329\nR = 8.3145\nVol1 = network[pore_volume][cn[:, (0)]]\nVol2 = network[pore_volume][cn[:, (1)]]\ntry:\n    Tt = phase[throat_temperature][throats]\nexcept KeyError:\n    Tt = phase.interpolate_data(propname=pore_temperature)[throats]\ntry:\n    T1 = phase[pore_temperature][cn[:, (0)]]\n    T2 = phase[pore_temperature][cn[:, (1)]]\nexcept KeyError:\n    T1 = phase.interpolate_data(propname=throat_temperature)[cn[:, (0)]]\n    T2 = phase.interpolate_data(propname=throat_temperature)[cn[:, (1)]]\nif ions == []:\n    logger.error('List of ions must be provided')\nfor i in ions:\n    i = '.' + i\n    try:\n        c1 = phase[pore_concentration + i][cn[:, (0)]]\n        c2 = phase[pore_concentration + i][cn[:, (1)]]\n    except KeyError:\n        c1 = _np.zeros(network.Nt)[cn[:, (0)]]\n        c2 = _np.zeros(network.Nt)[cn[:, (1)]]\n    ct = (c1 * Vol1 + c2 * Vol2) / (Vol1 + Vol2)\n    try:\n        Dt = phase[throat_diffusivity + i][throats]\n        Vt = phase[throat_valence + i][throats]\n    except KeyError:\n        Dt = phase.interpolate_data(propname=pore_diffusivity + i)[throats]\n        Vt = phase.interpolate_data(propname=pore_valence + i)[throats]\n    try:\n        D1 = phase[pore_diffusivity + i][cn[:, (0)]]\n        D2 = phase[pore_diffusivity + i][cn[:, (1)]]\n        V1 = phase[pore_valence + i][cn[:, (0)]]\n        V2 = phase[pore_valence + i][cn[:, (1)]]\n    except KeyError:\n        D1 = phase.interpolate_data(propname=throat_diffusivity + i)[cn[:, (0)]\n            ]\n        D2 = phase.interpolate_data(propname=throat_diffusivity + i)[cn[:, (1)]\n            ]\n        V1 = phase.interpolate_data(propname=throat_valence + i)[cn[:, (0)]]\n        V2 = phase.interpolate_data(propname=throat_valence + i)[cn[:, (1)]]\n    g1[m1] += F ** 2 * V1 ** 2 * (D1 * A1 * c1)[m1] / (R * T1 * L1[m1])\n    g2[m2] += F ** 2 * V2 ** 2 * (D2 * A2 * c2)[m1] / (R * T2 * L2[m2])\n    gt[mt] += F ** 2 * Vt ** 2 * (Dt * At * ct)[mt] / (R * Tt * Lt[mt])\ng_inv1, g_inv2, g_invt = _np.zeros((3, len(Lt)))\nf1, f2, ft = [(gi != 0) for gi in [g1, g2, gt]]\ng_inv1[~f1] = g_inv2[~f2] = g_invt[~ft] = _np.inf\ng_inv1[f1] = 1 / g1[f1]\ng_inv2[f2] = 1 / g2[f2]\ng_invt[ft] = 1 / gt[ft]\ng = g_inv1 / SF1 + g_inv2 / SF2 + g_invt / SFt\ng[g != 0] = g[g != 0] ** -1\nreturn g\n"
}
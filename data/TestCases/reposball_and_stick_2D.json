{
    "functionName": "ball_and_stick_2D",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_models_&_physics_&_poisson_shape_factors.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Calculate conduit shape factors for throat conductance associated with\n    diffusion-like physics (ex. thermal/diffusive/electrical conductance),\n    assuming pores and throats are circles (balls) and rectangles (sticks).\n\n    Parameters\n    ----------\n    target : OpenPNM Object\n        The object which this model is associated with. This controls the\n        length of the calculated array, and also provides access to other\n        necessary properties.\n\n    pore_area : string\n        Dictionary key of the pore area values\n\n    throat_area : string\n        Dictionary key of the throat area values\n\n    pore_diameter : string\n        Dictionary key of the pore diameter values\n\n    throat_diameter : string\n        Dictionary key of the throat diameter values\n\n    conduit_lengths : string\n        Dictionary key of the conduit lengths' values\n\n    Returns\n    -------\n    SF : dictionary\n        Dictionary containing conduit shape factors to be used in conductance\n        models associated with diffusion-like physics. Shape factors are\n        accessible via the keys: 'pore1', 'pore2' and 'throat'.\n\n    Notes\n    -----\n    (1) This model accounts for the variable cross-section area in circles.\n\n    (2) WARNING: This model could break if `conduit_lengths` does not\n    correspond to an actual ball and stick! Example: pore length is greater\n    than pore radius --> :(\n\n    \"\"\"\nnetwork = target.project.network\nthroats = network.map_throats(throats=target.Ts, origin=target)\ncn = network['throat.conns'][throats]\nD1 = network[pore_diameter][cn[:, (0)]]\nD2 = network[pore_diameter][cn[:, (1)]]\nL1 = network[conduit_lengths + '.pore1'][throats]\nL2 = network[conduit_lengths + '.pore2'][throats]\nLt = network[conduit_lengths + '.throat'][throats]\nA1 = network[pore_area][cn[:, (0)]]\nA2 = network[pore_area][cn[:, (1)]]\nAt = network[throat_area][throats]\nF1, F2, Ft = _np.zeros((3, len(Lt)))\nSF1, SF2, SFt = _np.ones((3, len(Lt)))\nm1, m2, mt = [(Li != 0) for Li in [L1, L2, Lt]]\nSF1[~m1] = SF2[~m2] = SFt[~mt] = 1\nF1[m1] = (0.5 * _atanh(2 * L1 / _sqrt(D1 ** 2 - 4 * L1 ** 2)))[m1]\nF2[m2] = (0.5 * _atanh(2 * L2 / _sqrt(D2 ** 2 - 4 * L2 ** 2)))[m2]\nFt[mt] = (Lt / At)[mt]\nSF1[m1] = (L1 / (A1 * F1))[m1]\nSF2[m2] = (L2 / (A2 * F2))[m2]\nSFt[mt] = (Lt / (At * Ft))[mt]\nreturn {'pore1': SF1, 'throat': SFt, 'pore2': SF2}\n"
}
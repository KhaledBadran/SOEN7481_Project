{
    "functionName": "general_symbolic",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_models_&_physics_&_generic_source_term.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    A general function to interpret a sympy equation and evaluate the linear\n    components of the source term.\n\n    Parameters\n    ----------\n    target : OpenPNM object\n        The OpenPNM object where the result will be applied.\n\n    eqn : sympy symbolic expression for the source terms\n        e.g. y = a*x**b + c\n\n    arg_map : Dict mapping the symbols in the expression to OpenPNM data\n        on the target. Must contain 'x' which is the independent variable.\n        e.g. arg_map={'a':'pore.a', 'b':'pore.b', 'c':'pore.c', 'x':'pore.x'}\n\n    Example\n    ----------\n    >>> import openpnm as op\n    >>> from openpnm.models.physics import generic_source_term as gst\n    >>> import numpy as np\n    >>> import sympy\n    >>> pn = op.network.Cubic(shape=[5, 5, 5], spacing=0.0001)\n    >>> water = op.phases.Water(network=pn)\n    >>> water['pore.a'] = 1\n    >>> water['pore.b'] = 2\n    >>> water['pore.c'] = 3\n    >>> water['pore.x'] = np.random.random(water.Np)\n    >>> a, b, c, x = sympy.symbols('a,b,c,x')\n    >>> y = a*x**b + c\n    >>> arg_map = {'a':'pore.a', 'b':'pore.b', 'c':'pore.c', 'x':'pore.x'}\n    >>> water.add_model(propname='pore.general',\n    ...                 model=gst.general_symbolic,\n    ...                 eqn=y, arg_map=arg_map,\n    ...                 regen_mode='normal')\n    >>> assert 'pore.general.rate' in water.props()\n    >>> assert 'pore.general.S1' in water.props()\n    >>> assert 'pore.general.S1' in water.props()\n    \"\"\"\nfrom sympy import postorder_traversal, srepr, symbols\nfor arg in postorder_traversal(eqn):\n    if srepr(arg)[:6] == 'Symbol':\n        key = srepr(arg)[7:].strip('(').strip(')').strip(\"'\")\n        if key not in arg_map.keys():\n            raise Exception('argument mapping incomplete, missing ' + key)\nif 'x' not in arg_map.keys():\n    raise Exception('argument mapping must contain \"x\" for the ' +\n        'independent variable')\ndata = {}\nargs = {}\nfor key in arg_map.keys():\n    data[key] = target[arg_map[key]]\n    args[key] = symbols(key)\nr, s1, s2 = _build_func(eqn, **args)\nr_val = r(*data.values())\ns1_val = s1(*data.values())\ns2_val = s2(*data.values())\nvalues = {'S1': s1_val, 'S2': s2_val, 'rate': r_val}\nreturn values\n"
}
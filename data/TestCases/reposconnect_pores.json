{
    "functionName": "connect_pores",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_topotools_&_topotools.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Returns the possible connections between two groups of pores, and optionally\n    makes the connections.\n\n    See ``Notes`` for advanced usage.\n\n    Parameters\n    ----------\n    network : OpenPNM Network Object\n\n    pores1 : array_like\n        The first group of pores on the network\n\n    pores2 : array_like\n        The second group of pores on the network\n\n    labels : list of strings\n        The labels to apply to the new throats.  This argument is only needed\n        if ``add_conns`` is True.\n\n    add_conns : bool\n        Indicates whether the connections should be added to the supplied\n        network (default is True).  Otherwise, the connections are returned\n        as an Nt x 2 array that can be passed directly to ``extend``.\n\n    Notes\n    -----\n    (1) The method also works if ``pores1`` and ``pores2`` are list of lists,\n    in which case it consecutively connects corresponding members of the two\n    lists in a 1-to-1 fashion. Example: pores1 = [[0, 1], [2, 3]] and\n    pores2 = [[5], [7, 9]] leads to creation of the following connections:\n\n    ::\n\n        0 --> 5     2 --> 7     3 --> 7\n        1 --> 5     2 --> 9     3 --> 9\n\n    (2) If you want to use the batch functionality, make sure that each element\n    within ``pores1`` and ``pores2`` are of type list or ndarray.\n\n    (3) It creates the connections in a format which is acceptable by\n    the default OpenPNM connections ('throat.conns') and either adds them to\n    the network or returns them.\n\n    Examples\n    --------\n    >>> import openpnm as op\n    >>> pn = op.network.Cubic(shape=[5, 5, 5])\n    >>> pn.Nt\n    300\n    >>> op.topotools.connect_pores(network=pn, pores1=[22, 32],\n    ...                            pores2=[16, 80, 68])\n    >>> pn.Nt\n    306\n    >>> pn['throat.conns'][300:306]\n    array([[16, 22],\n           [22, 80],\n           [22, 68],\n           [16, 32],\n           [32, 80],\n           [32, 68]])\n\n    \"\"\"\ntry:\n    len(pores1[0])\nexcept (TypeError, IndexError):\n    pores1 = [pores1]\ntry:\n    len(pores2[0])\nexcept (TypeError, IndexError):\n    pores2 = [pores2]\nif len(pores1) != len(pores2):\n    raise Exception('Running in batch mode! pores1 and pores2 must be' +\n        ' of the same length.')\narr1, arr2 = [], []\nfor ps1, ps2 in zip(pores1, pores2):\n    size1 = np.size(ps1)\n    size2 = np.size(ps2)\n    arr1.append(np.repeat(ps1, size2))\n    arr2.append(np.tile(ps2, size1))\nconns = np.vstack([np.concatenate(arr1), np.concatenate(arr2)]).T\nif add_conns:\n    extend(network=network, throat_conns=conns, labels=labels)\nelse:\n    return conns\n"
}
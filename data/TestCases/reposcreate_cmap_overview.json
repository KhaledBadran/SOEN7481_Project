{
    "functionName": "create_cmap_overview",
    "className": null,
    "fileName": "/1313e_&_CMasher/cmasher_&_utils.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Creates an overview plot containing all colormaps defined in the provided\n    `cmaps`.\n\n    Optional\n    --------\n    cmaps : list of {str; :obj:`~matplotlib.colors.Colormap` objects}, dict         of lists or None. Default: None\n        A list of all colormaps that must be included in the overview plot.\n        If dict of lists, the keys define categories for the colormaps.\n        If *None*, all colormaps defined in *CMasher* are used instead.\n    savefig : str or None. Default: None\n        If not *None*, the path where the overview plot must be saved to.\n        Else, the plot will simply be shown.\n    use_types : bool. Default: True\n        Whether all colormaps in `cmaps` should be categorized into their\n        colormap types (sequential; diverging; cyclic; qualitative; misc).\n        If `cmaps` is a dict, this value is ignored.\n    sort : {'alphabetical'/'name'; 'lightness'}, function or None. Default:         'alphabetical'\n        String or function indicating how the colormaps should be sorted in the\n        overview.\n        If 'alphabetical', the colormaps are sorted alphabetically on their\n        name.\n        If 'lightness', the colormaps are sorted based on their lightness\n        profile.\n        If function, a function definition that takes a\n        :obj:`~matplotlib.colors.Colormap` object and returns the sorted\n        position of that colormap.\n        If *None*, the colormaps retain the order they were given in.\n    plot_profile : bool or float. Default: False\n        Whether the lightness profiles of all colormaps should be plotted. If\n        not *False*, the lightness profile of a colormap is plotted on top of\n        its gray-scale version and `plot_profile` is used for setting the alpha\n        (opacity) value.\n        If `plot_profile` is *True*, it will be set to `0.25`.\n    title : str or None. Default: \"Colormap Overview\"\n        String to be used as the title of the colormap overview.\n        If empty or *None*, no title will be used.\n\n    Notes\n    -----\n    The colormaps in `cmaps` can either be provided as their registered name in\n    :mod:`matplotlib.cm`, or their corresponding\n    :obj:`~matplotlib.colors.Colormap` object.\n    Any provided reversed colormaps (colormaps that end their name with '_r')\n    are ignored if their normal versions were provided as well.\n\n    If `plot_profile` is not set to *False*, the lightness profiles are plotted\n    on top of the gray-scale colormap versions, where the y-axis ranges from 0%\n    lightness to 100% lightness.\n    The lightness profile transitions between black and white at 50% lightness.\n\n    \"\"\"\nif plot_profile is True:\n    plot_profile = 0.25\nif cmaps is None:\n    cmaps = cmrcm.cmap_d.values()\nif isinstance(sort, str):\n    sort = sort.lower()\n    if sort in ('alphabetical', 'name'):\n\n        def sort(x):\n            return x.name\n    elif sort == 'lightness':\n        sort = _get_cmap_lightness_rank\ncmaps_list = []\nif isinstance(cmaps, dict):\n    use_types = True\n    cmaps_dict = odict()\n    input_cmaps = cmaps\n    for cm_type, cmaps in input_cmaps.items():\n        cmaps_dict[cm_type] = []\n        for cmap in cmaps:\n            if isinstance(cmap, str):\n                cmaps_dict[cm_type].append(mplcm.get_cmap(cmap))\n            else:\n                cmaps_dict[cm_type].append(cmap)\nelif use_types:\n    cm_types = ['sequential', 'diverging', 'cyclic', 'qualitative', 'misc']\n    cmaps_dict = odict([[cm_type, []] for cm_type in cm_types])\n    for cmap in cmaps:\n        cm_type = get_cmap_type(cmap)\n        if isinstance(cmap, str):\n            cmaps_dict[cm_type].append(mplcm.get_cmap(cmap))\n        else:\n            cmaps_dict[cm_type].append(cmap)\nelse:\n    for cmap in cmaps:\n        if isinstance(cmap, str):\n            cmaps_list.append(mplcm.get_cmap(cmap))\n        else:\n            cmaps_list.append(cmap)\nif use_types:\n    for key, value in cmaps_dict.items():\n        if value:\n            names = [x.name for x in value]\n            off_dex = len(names) - 1\n            for i, name in enumerate(reversed(names)):\n                if name.endswith('_r') and name[:-2] in names:\n                    value.pop(off_dex - i)\n            if sort is not None:\n                value.sort(key=sort)\n            cmaps_list.append(key)\n            cmaps_list.extend(value)\nelse:\n    names = [x.name for x in cmaps_list]\n    off_dex = len(names) - 1\n    for i, name in enumerate(reversed(names)):\n        if name.endswith('_r') and name[:-2] in names:\n            cmaps_list.pop(off_dex - i)\n    if sort is not None:\n        cmaps_list.sort(key=sort)\ncspace_convert = cspace_converter('sRGB1', 'CAM02-UCS')\nheight = 0.4 * (len(cmaps_list) + bool(title))\nfig, axes = plt.subplots(figsize=(6.4, height), nrows=len(cmaps_list), ncols=2)\nif title:\n    fig.subplots_adjust(top=1 - 0.288 / height, bottom=0.048 / height, left\n        =0.2, right=0.99, wspace=0.05)\n    fig.suptitle(title, fontsize=16, x=0.595, y=1.0 - 0.048 / height)\nelse:\n    fig.subplots_adjust(top=1 - 0.048 / height, bottom=0.048 / height, left\n        =0.2, right=0.99, wspace=0.05)\nif len(cmaps_list) == 1:\n    axes = [axes]\ncm_type = None\nfor ax, cmap in zip(axes, cmaps_list):\n    ax[0].set_axis_off()\n    ax[1].set_axis_off()\n    if isinstance(cmap, str):\n        fig.text(0.595, ax[0].get_position().bounds[1], cmap, va='bottom',\n            ha='center', fontsize=14)\n        cm_type = cmap\n    else:\n        x = np.arange(cmap.N)\n        rgb = cmap(x)[:, :3]\n        lab = cspace_convert(rgb)\n        L = lab[:, (0)]\n        L /= 99.99871678\n        rgb_L = cmrcm.neutral(L)[:, :3]\n        ax[0].imshow(rgb[np.newaxis, ...], aspect='auto')\n        if plot_profile and cm_type != 'qualitative':\n            plot_L = -(L - 0.5)\n            points = np.stack([x, plot_L], axis=1)\n            colors = np.zeros_like(plot_L, dtype=int)\n            colors[plot_L >= 0] = 1\n            s_idx = np.nonzero(np.diff(colors))[0] + 1\n            segments = np.split(points, s_idx)\n            for i, (seg1, seg2) in enumerate(zip(segments[:-1], segments[1:])):\n                central_point = (seg1[-1] + seg2[0]) / 2\n                segments[i] = np.concatenate([segments[i], [central_point]],\n                    axis=0)\n                segments[i + 1] = np.concatenate([[central_point], segments\n                    [i + 1]], axis=0)\n            lc = LineCollection(segments, cmap=cmrcm.neutral, alpha=\n                plot_profile)\n            lc.set_linewidth(1)\n            s_colors = [colors[0]]\n            s_colors.extend(colors[s_idx])\n            s_colors = np.array(s_colors)\n            lc.set_array(s_colors)\n            ax[1].add_collection(lc)\n        ax[1].imshow(rgb_L[np.newaxis, ...], aspect='auto')\n        pos = list(ax[0].get_position().bounds)\n        x_text = pos[0] - 0.01\n        y_text = pos[1] + pos[3] / 2\n        fig.text(x_text, y_text, cmap.name, va='center', ha='right',\n            fontsize=10)\nif savefig is not None:\n    dpi = 100 if path.splitext(savefig)[1] == '.svg' else 250\n    plt.savefig(savefig, dpi=dpi)\n    plt.close(fig)\nelse:\n    plt.show()\n"
}
{
    "functionName": "subdivide",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_topotools_&_topotools.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    It trim the pores and replace them by cubic networks with the sent shape.\n\n    Parameters\n    ----------\n    network : OpenPNM Network Object\n\n    pores : array_like\n        The first group of pores to be replaced\n\n    shape : array_like\n        The shape of cubic networks in the target locations\n\n    Notes\n    -----\n    - It works only for cubic networks.\n\n    Examples\n    --------\n    >>> import openpnm as op\n    >>> pn = op.network.Cubic(shape=[5, 6, 5], spacing=0.001)\n    >>> pn.Np\n    150\n    >>> nano_pores = [2, 13, 14, 15]\n    >>> op.topotools.subdivide(network=pn, pores=nano_pores, shape=[4, 7, 3],\n    ...                        labels='nano')\n    >>> pn.Np\n    482\n\n    \"\"\"\nmro = network._mro()\nif 'Cubic' not in mro:\n    raise Exception('Subdivide is only supported for Cubic Networks')\nfrom openpnm.network import Cubic\npores = network._parse_indices(pores)\nif 'pore.boundary' in network.labels():\n    if np.in1d(pores, network.pores('boundary')).any():\n        raise Exception('boundary pores cannot be subdivided!')\nif not hasattr(network, '_subdivide_flag'):\n    network._subdivide_flag = True\nelse:\n    raise Exception(\n        'The network has subdivided pores, so the method                          does not support another subdivision'\n        )\nif np.size(shape) != 2 and np.size(shape) != 3:\n    raise Exception(\n        'Subdivide not implemented for Networks other than 2D                          and 3D'\n        )\nelif np.size(shape) == 3 and 1 not in shape:\n    div = np.array(shape, ndmin=1)\n    single_dim = None\nelse:\n    single_dim = np.where(np.array(network.shape) == 1)[0]\n    if np.size(single_dim) == 0:\n        single_dim = None\n    if np.size(shape) == 3:\n        div = np.array(shape, ndmin=1)\n    else:\n        div = np.zeros(3, dtype=np.int32)\n        if single_dim is None:\n            dim = 2\n        else:\n            dim = single_dim\n        div[dim] = 1\n        div[-np.array(div, ndmin=1, dtype=bool)] = np.array(shape, ndmin=1)\nnetworkspacing = network.spacing\nnew_netspacing = networkspacing / div\nnew_net = Cubic(shape=div, spacing=new_netspacing)\nmain_labels = ['left', 'right', 'front', 'back', 'top', 'bottom']\nif single_dim is not None:\n    label_groups = np.array([['front', 'back'], ['left', 'right'], ['top',\n        'bottom']])\n    non_single_labels = label_groups[np.array([0, 1, 2]) != single_dim]\nfor l in main_labels:\n    new_net['pore.surface_' + l] = False\n    network['pore.surface_' + l] = False\n    if single_dim is None:\n        new_net['pore.surface_' + l][new_net.pores(labels=l)] = True\n    else:\n        for ind in [0, 1]:\n            loc = non_single_labels[ind] == l\n            temp_pores = new_net.pores(non_single_labels[ind][loc])\n            new_net['pore.surface_' + l][temp_pores] = True\nold_coords = np.copy(new_net['pore.coords'])\nif labels == []:\n    labels = ['pore.subdivided_' + new_net.name]\nfor P in pores:\n    shift = network['pore.coords'][P] - networkspacing / 2\n    new_net['pore.coords'] += shift\n    Pn = network.find_neighbor_pores(pores=P)\n    try:\n        Pn_new_net = network.pores(labels)\n    except KeyError:\n        Pn_new_net = []\n    Pn_old_net = Pn[~np.in1d(Pn, Pn_new_net)]\n    Np1 = network.Np\n    extend(pore_coords=new_net['pore.coords'], throat_conns=new_net[\n        'throat.conns'] + Np1, labels=labels, network=network)\n    for l in main_labels:\n        network['pore.surface_' + l][Np1:] = new_net['pore.surface_' + l]\n    surf_pores = network.pores('surface_*')\n    surf_coord = network['pore.coords'][surf_pores]\n    for neighbor in Pn:\n        neighbor_coord = network['pore.coords'][neighbor]\n        dist = [round(np.inner(neighbor_coord - x, neighbor_coord - x), 20) for\n            x in surf_coord]\n        nearest_neighbor = surf_pores[dist == np.amin(dist)]\n        if neighbor in Pn_old_net:\n            coplanar_labels = network.labels(pores=nearest_neighbor)\n            new_neighbors = network.pores(coplanar_labels, mode='and')\n            if np.size(new_neighbors) == 0:\n                labels = network.labels(pores=nearest_neighbor, mode='and')\n                common_label = [l for l in labels if 'surface_' in l]\n                new_neighbors = network.pores(common_label)\n        elif neighbor in Pn_new_net:\n            new_neighbors = nearest_neighbor\n        connect_pores(network=network, pores1=neighbor, pores2=\n            new_neighbors, labels=labels)\n    for l in main_labels:\n        network['pore.surface_' + l] = False\n    new_net['pore.coords'] = np.copy(old_coords)\nlabel_faces(network=network)\nfor l in main_labels:\n    del network['pore.surface_' + l]\ntrim(network=network, pores=pores)\nws = network.project.workspace\nws.close_project(new_net.project)\n"
}
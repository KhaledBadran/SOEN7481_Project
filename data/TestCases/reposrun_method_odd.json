{
    "functionName": "run_method_odd",
    "className": null,
    "fileName": "/PyAbel_&_PyAbel/abel_&_tests_&_test_tools_distributions.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Test harmonics and Ibeta for various combinations of origins and weights\n    for default order=2, but with odd=True.\n\n    method = method name\n    rmax = 'MIN' or 'all'\n    tol... = (atol, rmstol) for ...\n    tolbeta = atol for beta\n    weq = compare symbolic and array weights\n    \"\"\"\nn = 81\nm = 91\nxc = [0, 30, n // 2, 50, n - 1]\nyc = [0, 25, m // 2, 65, m - 1]\nsigma = 2.0\ndef peak(i, r):\n    return np.exp(-(r - i * step) ** 2 / (2 * sigma ** 2))\ndef image():\n    x = np.arange(float(n)) - x0\n    y = y0 - np.arange(float(m))[:, (None)]\n    r = np.sqrt(x ** 2 + y ** 2)\n    r[y0, x0] = np.inf\n    c = y / r\n    s = np.abs(x) / r\n    s[y0, x0] = 1\n    r[y0, x0] = 0\n    IM = s ** 2 * peak(1, r) + c ** 2 * peak(2, r) + (1 / 2 + c) * peak(3, r\n        ) + peak(4, r)\n    return IM, s\ndef ref_distr():\n    r = np.arange(R + 1)\n    P0 = 2 / 3 * peak(1, r) + 1 / 3 * peak(2, r) + 1 / 2 * peak(3, r) + peak(\n        4, r)\n    P1 = peak(3, r)\n    P2 = -2 / 3 * peak(1, r) + 2 / 3 * peak(2, r)\n    I = 4 * np.pi * r ** 2 * P0\n    beta1 = P1 / P0\n    beta2 = P2 / P0\n    return r, P0, P1, P2, I, beta1, beta2\nfor y0, x0 in itertools.product(yc, xc):\n    param = ' @ y0 = {}, x0 = {}, rmax = {}, method = {}'.format(y0, x0,\n        rmax, method)\n    if rmax == 'MIN':\n        R = min(max(x0, n - 1 - x0), max(y0, m - 1 - y0))\n    elif rmax == 'MAX':\n        if y0 in [0, m - 1] and x0 not in [0, n - 1] or x0 == n // 2 and abs(\n            y0 - m // 2) not in [0, m // 2]:\n            continue\n        R = max(max(x0, n - 1 - x0), max(y0, m - 1 - y0))\n    step = (R - 5 * sigma) / 4\n    refr, refP0, refP1, refP2, refI, refbeta1, refbeta2 = ref_distr()\n    f = 1 / (4 * np.pi * (1 + refr ** 2))\n    IM, ws = image()\n    w1 = np.ones_like(IM)\n    IMcopy = IM.copy()\n    w1copy = w1.copy()\n    wscopy = ws.copy()\n    weights = [(False, None, None), (True, None, None), (False, '1', w1), (\n        False, 'sin', ws), (True, '1', w1)]\n    P0, P1, P2, r, I, beta1, beta2 = {}, {}, {}, {}, {}, {}, {}\n    for use_sin, wname, warray in weights:\n        weight_param = param + ', sin = {}, weights = {}'.format(use_sin, wname\n            )\n        key = use_sin, wname\n        distr = Distributions((y0, x0), rmax, odd=True, use_sin=use_sin,\n            weights=warray, method=method)\n        res = distr(IM)\n        P0[key], P1[key], P2[key] = res.harmonics()\n        r[key], I[key], beta1[key], beta2[key] = res.rIbeta()\n\n        def assert_cmp(msg, a, ref, tol):\n            atol, rmstol = tol\n            assert_allclose(a, ref, atol=atol, err_msg=msg + weight_param)\n            rms = np.sqrt(np.mean((a - ref) ** 2))\n            assert rms < rmstol, '\\n' + msg + weight_param + '\\nRMS error = {} > {}'.format(\n                rms, rmstol)\n        assert_cmp('-> P0', P0[key], refP0, tolP0)\n        assert_cmp('-> P1', P1[key], refP1, tolP1)\n        assert_cmp('-> P2', P2[key], refP2, tolP2)\n        assert_equal(r[key], refr, err_msg='-> r' + weight_param)\n        assert_cmp('-> I', f * I[key], f * refI, tolI)\n        b1 = [round(beta1[key][int(i * step)], 5) for i in (1, 2, 3, 4)]\n        assert_allclose(b1, [0, 0, 2, 0], atol=tolbeta1, err_msg='-> beta1' +\n            weight_param)\n        b2 = [round(beta2[key][int(i * step)], 5) for i in (1, 2, 3, 4)]\n        assert_allclose(b2, [-1, 2, 0, 0], atol=tolbeta2, err_msg=\n            '-> beta2' + weight_param)\n        assert_equal(IM, IMcopy, err_msg='-> IM corrupted' + weight_param)\n        assert_equal(w1, w1copy, err_msg='-> weights corrupted' + weight_param)\n        assert_equal(ws, wscopy, err_msg='-> weights corrupted' + weight_param)\n    if not weq:\n        continue\n    for key1, key2 in [((False, '1'), (False, None)), ((False, 'sin'), (\n        True, None)), ((True, '1'), (False, 'sin'))]:\n        pair_param = param + ', sin + weights {} != {}'.format(key1, key2)\n        assert_allclose(P0[key1], P0[key2], err_msg='-> P0' + pair_param)\n        assert_allclose(P1[key1], P1[key2], err_msg='-> P1' + pair_param)\n        assert_allclose(P2[key1], P2[key2], err_msg='-> P2' + pair_param)\n        assert_allclose(I[key1], I[key2], err_msg='-> I' + pair_param)\n        assert_allclose(beta1[key1], beta1[key2], err_msg='-> beta1' +\n            pair_param)\n        assert_allclose(beta2[key1], beta2[key2], err_msg='-> beta2' +\n            pair_param)\n"
}
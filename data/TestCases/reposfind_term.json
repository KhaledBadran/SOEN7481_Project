{
    "functionName": "find_term",
    "className": "OnToma",
    "fileName": "/opentargets_&_OnToma/ontoma_&_interface.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Finds the most likely EFO code for a given string or ontology code.\n\n        If the code argument is passed, it will attempt to perform an exact match\n        amongst the mappings available.\n\n        If only a string is passed, it will attempt to match it against mappings,\n        but will try using the EBI SPOT APIs if no match is found, until a likely\n        code is identified.\n\n        Operations roughly ordered from least expensive to most expensive\n        and also from most authorative to least authorative\n\n        1. EFO OBO lookup\n        2. Zooma mappings lookup\n        3. Zooma API high confidence lookup\n        4. OLS API EFO lookup - exact match\n        --- below this line we might not have a term in the platform ---\n        5. HP OBO lookup\n        6. OLS API HP lookup - exact match\n        7. OLS API ORDO lookup - exact match\n        8. OLS API EFO lookup - not exact\n        9. OLS API HP+ORDO lookup - not exact\n\n\n        Args:\n            query (str): the disease/phenotype to be matched to an EFO code\n            code: accepts one of \"ICD9CM\", \"OMIM\"\n                **TODO** expand to more ontologies\n                If a code is passed, it will attempt to find the code in one of\n                our curated mapping datasources. Defaults to None.\n            suggest (boolean): if True the OLS API will be queried for any match\n                               in HP, ORDO and EFO, whether or not these terms\n                               are already included in the Open Targets platform\n                               ontology.\n            verbose (bool): if True returns a dictionary containing\n                            {term, label, source, quality, action}\n\n\n        Returns:\n            A valid OT ontology URI. `None` if no EFO code was found\n        \"\"\"\nif code:\n    try:\n        uri = make_uri(self._find_term_from_code(query, code=code))\n        logger.info('Found %s for %s in %s mappings', uri, query, code)\n        if verbose:\n            return {'term': uri, 'label': self.get_efo_label(uri), 'source':\n                code, 'quality': 'match', 'action': ''}\n        else:\n            return uri\n    except KeyError as e:\n        logger.info('Could not find a match for %s in %s mappings. ', e, code)\n        return None\nelse:\n    found = self._find_term_from_string(query, suggest)\n    if found:\n        msg = 'Found {} for {} from {} - {} - {}'.format(make_uri(found[\n            'term']), query, found['source'], found['quality'], found['action']\n            )\n        if found['quality'] == 'match':\n            logger.info(msg)\n        else:\n            logger.warning(msg)\n        if verbose:\n            return found\n        else:\n            return make_uri(found['term'])\n    logger.error('Could not find *any* term for string: %s', query)\n    return None\n"
}
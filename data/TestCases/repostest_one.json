{
    "functionName": "test_one",
    "className": "TestChapter1",
    "fileName": "/axiros_&_DevApps/tests_&_test_tutorial.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "t = \"\"\"\n\n        [TOC]\n\n        # `devapp`: Command Line Function Configurator and Runner\n\n        Given you have a setup like this:\n\n        <from-file: calc.py>\n\n        Via the `devapp` command, you can provide config on the CLI (in addition to\n        config file and environ) and run this right away:\n\n        \"\"\"\nmd(t)\nac, d_ac = appcond_cmd()\nac = ac + ' ' + dtut + 'calc.py '\nres = bash_run([ac + '41 1', ac + 'b=1 41', ac + 'oper_func=mul a=2 b=100',\n    ac + 'of=mul a=2 b=150', \n    'export Calc_oper_func=mul Calc_run=\\'{\"a\":100}\\'; %s b=4' % ac, ac +\n    'a=1 b=foo # b has wrong type', ac + '# missing params', ac +\n    'of=mul -h # help output'], no_cmd_path=True, no_show_in_cmd=d_ac + '/')\nfor i, j in ((0, 42), (1, 42), (2, 200), (3, 300), (4, 400)):\n    assert res[i]['res'].strip() == str(j)\nassert Exc.cannot_cast in res[5]['res']\nassert Exc.require_value in res[6]['res']\nassert 'oper_func' in res[7]['res']\nassert '# ' in res[7]['res']\nt = \"\"\"\n\n        # `@app`: Converts Class Trees\n\n        The decorator variant allows to run the application standalone:\n\n        <from-file: calc1.py>\n\n        We\n        - added a hashbang and made the file executable.\n        - decorated the toplevel class.\n\n        We can run the thing now from the CLI, directly:\n\n\n        \"\"\"\nmd(t)\nres = bash_run(['calc1.py a=2 b=4',\n    'calc1.py b=2 a=4 # mappable so supported',\n    'calc1.py 2 4.1 # positionally given, rounded',\n    'calc1.py a=2 4.1 # mapping found', 'calc1.py oper_func=mul a=2 b=4',\n    'calc1.py of=mul a=2 b=4 # short form for oper_func'])\nassert res[0]['res'] == '6'\nassert res[1]['res'] == '6'\nassert res[2]['res'] == '6'\nassert res[3]['res'] == '6'\nassert res[4]['res'] == '8'\nassert res[5]['res'] == '8'\n"
}
{
    "functionName": "run_random",
    "className": null,
    "fileName": "/PyAbel_&_PyAbel/abel_&_tests_&_test_tools_distributions.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Test quadrant flipping and image folding using random image data.\n\n    method = method name\n    parts = test that masking by weights array equals image cropping\n    \"\"\"\nn = 51\nm = 41\nnp.random.seed(0)\nIM = np.random.random((m, n)) + 1\nweights = np.random.random((m, n)) + 1\nfor y in [0, m - 1]:\n    ydir = -1 if y > 0 else 1\n    for x in [0, n - 1]:\n        xdir = -1 if x > 0 else 1\n        ho = harmonics(IM, (y, x), 'all', odd=odd, use_sin=use_sin, weights\n            =weights, method=method)\n        hf = harmonics(IM[::ydir, ::xdir], (0, 0), 'all', odd=odd, use_sin=\n            use_sin, weights=weights[::ydir, ::xdir], method=method)\n        if odd:\n            ho = ho[:, :-3]\n            hf = hf[:, :-3]\n            if ydir == -1:\n                hf[1] = -hf[1]\n            cmp = assert_allclose\n        else:\n            cmp = assert_equal\n        cmp(ho, hf, err_msg=\n            '-> flip({}, {}) @ method = {}, odd = {}, sin = {}'.format(ydir,\n            xdir, method, odd, use_sin))\nif not parts:\n    return\nfor y0, x0 in itertools.product([15, m // 2, 25], [10, n // 2, 40]):\n    param = ' @ y0 = {}, x0 = {}, method = {}, odd = {}, sin = {}'.format(y0,\n        x0, method, odd, use_sin)\n    trim = slice(1, -1), slice(1, -1)\n    IMtrim = IM[trim]\n    wtrim = weights[trim]\n    ht = harmonics(IMtrim, (y0 - 1, x0 - 1), 'all', odd=odd, use_sin=\n        use_sin, weights=wtrim, method=method)\n    wmask = np.zeros_like(IM)\n    wmask[trim] = weights[trim]\n    hm = harmonics(IM, (y0, x0), 'all', odd=odd, use_sin=use_sin, weights=\n        wmask, method=method)\n    assert_allclose(ht, hm[:, :ht.shape[1]], err_msg='-> trim' + param)\n    regions = [((slice(0, y0 + 1), slice(0, x0 + 1)), 'lr'), ((slice(0, y0 +\n        1), slice(x0, None)), 'll'), ((slice(y0, None), slice(0, x0 + 1)),\n        'ur'), ((slice(y0, None), slice(x0, None)), 'ul')]\n    for region, origin in regions:\n        Q = IM[region]\n        Qw = weights[region]\n        hc = harmonics(Q, origin, 'all', odd=odd, use_sin=use_sin, weights=\n            Qw, method=method)\n        wmask = np.zeros_like(IM)\n        wmask[region] = weights[region]\n        hm = harmonics(IM, (y0, x0), 'all', odd=odd, use_sin=use_sin,\n            weights=wmask, method=method)\n        assert_allclose(hc, hm[:, :hc.shape[1]], err_msg='-> Q (origin = ' +\n            origin + ')' + param)\n"
}
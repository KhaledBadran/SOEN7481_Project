{
    "functionName": "autocrop",
    "className": null,
    "fileName": "/Lasagne_&_Lasagne/lasagne_&_layers_&_merge.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Crops the given input arrays.\n\n    Cropping takes a sequence of inputs and crops them per-axis in order to\n    ensure that their sizes are consistent so that they can be combined\n    in an element-wise fashion. If cropping is enabled for a specific axis,\n    the minimum size in that axis of all inputs is computed, and all\n    inputs are cropped to that size.\n\n    The per-axis cropping modes are:\n\n    `None`: this axis is not cropped, inputs are unchanged in this axis\n\n    `'lower'`: inputs are cropped choosing the lower portion in this axis\n    (`a[:crop_size, ...]`)\n\n    `'upper'`: inputs are cropped choosing the upper portion in this axis\n    (`a[-crop_size:, ...]`)\n\n    `'center'`: inputs are cropped choosing the central portion in this axis\n    (``a[offset:offset+crop_size, ...]`` where\n    ``offset = (a.shape[0]-crop_size)//2)``\n\n    Parameters\n    ----------\n    inputs : list of Theano expressions\n        The input arrays in the form of a list of Theano expressions\n\n    cropping : list of cropping modes\n        Cropping modes, one for each axis. If length of `cropping` is less\n        than the number of axes in the inputs, it is padded with `None`.\n        If `cropping` is None, `input` is returned as is.\n\n    Returns\n    -------\n    list of Theano expressions\n        each expression is the cropped version of the corresponding input\n\n    Example\n    -------\n    For example, given three inputs:\n\n    >>> import numpy\n    >>> import theano\n\n    >>> a = numpy.random.random((1, 2, 3, 4))\n    >>> b = numpy.random.random((5, 4, 4, 2))\n    >>> c = numpy.random.random((7, 1, 8, 9))\n\n    Cropping mode for each axis:\n\n    >>> cropping = [None, 'lower', 'center', 'upper']\n\n    Crop (note that the input arrays are converted to Theano vars first,\n    and that the results are converted back from Theano expressions to\n    numpy arrays by calling `eval()`)\n    >>> xa, xb, xc = autocrop([theano.shared(a),                                theano.shared(b),                                theano.shared(c)], cropping)\n    >>> xa, xb, xc = xa.eval(), xb.eval(), xc.eval()\n\n    They will be left as is in axis 0 and cropped in the other three,\n    choosing the lower, center and upper portions:\n\n    Axis 0: choose all, axis 1: lower 1 element,\n    axis 2: central 3 (all) and axis 3: upper 2\n    >>> (xa == a[:, :1, :3, -2:]).all()\n    True\n\n    Axis 0: choose all, axis 1: lower 1 element,\n    axis 2: central 3 starting at 0 and axis 3: upper 2 (all)\n    >>> (xb == b[:, :1, :3, -2:]).all()\n    True\n\n    Axis 0: all, axis 1: lower 1 element (all),\n    axis 2: central 3 starting at 2 and axis 3: upper 2\n    >>> (xc == c[:, :1, 2:5:, -2:]).all()\n    True\n    \"\"\"\nif cropping is None:\n    return inputs\nelse:\n    ndim = inputs[0].ndim\n    if not all(input.ndim == ndim for input in inputs):\n        raise ValueError(\n            'Not all inputs are of the same dimensionality. Got {0} inputs of dimensionalities {1}.'\n            .format(len(inputs), [input.ndim for input in inputs]))\n    shapes = [input.shape for input in inputs]\n    shapes_tensor = T.as_tensor_variable(shapes)\n    min_shape = T.min(shapes_tensor, axis=0)\n    slices_by_input = [[] for i in range(len(inputs))]\n    cropping = list(cropping)\n    if ndim > len(cropping):\n        cropping = list(cropping) + [None] * (ndim - len(cropping))\n    for dim, cr in enumerate(cropping):\n        if cr is None:\n            slice_all = slice(None)\n            for slices in slices_by_input:\n                slices.append(slice_all)\n        else:\n            sz = min_shape[dim]\n            if cr == 'lower':\n                slc_lower = slice(None, sz)\n                for slices in slices_by_input:\n                    slices.append(slc_lower)\n            elif cr == 'upper':\n                slc_upper = slice(-sz, None)\n                for slices in slices_by_input:\n                    slices.append(slc_upper)\n            elif cr == 'center':\n                for sh, slices in zip(shapes, slices_by_input):\n                    offset = (sh[dim] - sz) // 2\n                    slices.append(slice(offset, offset + sz))\n            else:\n                raise ValueError(\"Unknown crop mode '{0}'\".format(cr))\n    return [input[slices] for input, slices in zip(inputs, slices_by_input)]\n"
}
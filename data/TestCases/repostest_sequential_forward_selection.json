{
    "functionName": "test_sequential_forward_selection",
    "className": null,
    "fileName": "/gelijergensen_&_PermutationImportance/test_&_test_sequential_selection.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "A = [1, 2]\nB = [2, 4]\nC = [3, 6]\nD = [1, 0]\ninputs = pd.DataFrame({'A': A, 'B': B, 'C': C})\noutputs = pd.DataFrame({'D': D})\ntraining_data = inputs, outputs\nscoring_data = inputs, outputs\ndef scoring_fn(training_data, scoring_data):\n    if len(training_data[0].columns) == 0:\n        return 0\n    if 'A' in training_data[0].columns:\n        return scoring_data[0].iloc[1, -1]\n    else:\n        return scoring_data[0].iloc[1, -1] / 2\nexpected = ImportanceResult('Sequential Forward Selection', ['A', 'B', 'C'], 6)\nexpected.add_new_results({'A': (0, 2), 'B': (1, 2), 'C': (2, 3)})\nexpected.add_new_results({'B': (0, 4), 'C': (1, 6)})\nexpected.add_new_results({'C': (0, 6)})\nresult = sequential_forward_selection(training_data, scoring_data,\n    scoring_fn, 'argmin', njobs=2)\nassert expected.method == result.method\nassert expected.original_score == result.original_score\nassert (expected.variable_names == result.variable_names).all()\nassert expected.retrieve_singlepass() == result.retrieve_singlepass()\nassert expected.retrieve_multipass() == result.retrieve_multipass()\nfor (exp_context, exp_result), (true_context, true_result) in zip(expected,\n    result):\n    assert exp_context == true_context\n    assert exp_result == true_result\n"
}
{
    "functionName": "View3D",
    "className": "DataSet",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"View data in the Viewer3D object. \n\n        Args:\n\n            - dQx (float): step size in qx\n\n            - dQy (float): step size in qy\n\n            - dE (float): step size in E\n\n        Kwargs:\n\n            - rlu (Bool): If true a rlu axis is used for plotting otherwise qx,qy (Default True).\n\n            - log (Bool): If true logarithm of intensity is plotted\n\n            - grid (Bool): If true, grid is plotted. If float or integer, value is used as zorder of grid (Default False)\n\n            - axis (int): Axis shown initially (default 2)\n\n            - counts (bool): If set true, data shown is number of neutrons/pixel\n\n            - adjustable (bool): If set true, 2 sliders will be present allowing to fine tune the c-axis (Default True)\n\n            - kwargs: The remaining kwargs are given to the createRLUAxes method, intended for tick mark positioning (see createRLUAxes)\n\n        If one plots not using RLU, everything is plotted in real units (1/AA), and the Qx and QY is not rotated. That is, the\n        x axis in energy is not along the projection vector. The cuts of constant Qx and Qy does not represent any symmetry directions in\n        the sample.\n        However, if one utilizes the RLU flag, first Qx and Qy are rotated with first HKL vector along the x-axis. This thus means that \n        cuts of constant Qx (or more correctly along the principal HKL vector) represents a symmetry direction. However, as the data is \n        binned in equal sized voxels, constant Qy does not necessarily correspond to HKL vector 2 (it will in systems with 90 degrees \n        between the two vectors). \n        \"\"\"\nif rlu:\n    rluax = self.createRLUAxes(**kwargs)\n    figure = rluax.get_figure()\n    figure.delaxes(rluax)\n    qxEax = self.createQEAxes(axis=1, figure=figure)\n    figure.delaxes(qxEax)\n    qyEax = self.createQEAxes(axis=0, figure=figure)\n    figure.delaxes(qyEax)\n    axes = [qxEax, qyEax, rluax]\nelse:\n    axes = None\nData, bins = self.binData3D(dx=dQx, dy=dQy, dz=dE, rlu=rlu)\nif counts:\n    Intensity = Data[0] / Data[3]\n    Viewer = Viewer3D.Viewer3D(Data=Intensity, bins=bins, axis=axis, ax=\n        axes, grid=grid, log=log, adjustable=adjustable)\nelse:\n    Viewer = Viewer3D.Viewer3D(Data=Data, bins=bins, axis=axis, ax=axes,\n        grid=grid, log=log, adjustable=adjustable)\nreturn Viewer\n_tools.KwargChecker(function=createRLUAxes)"
}
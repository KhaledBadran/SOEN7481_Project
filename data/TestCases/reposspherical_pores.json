{
    "functionName": "spherical_pores",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_models_&_geometry_&_throat_endpoints.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Calculate the coordinates of throat endpoints, assuming spherical pores.\n    This model accounts for the overlapping lens between pores and throats.\n\n    Parameters\n    ----------\n    target : OpenPNM Object\n        The object which this model is associated with. This controls the\n        length of the calculated array, and also provides access to other\n        necessary properties.\n\n    pore_diameter : string\n        Dictionary key of the pore diameter values.\n\n    throat_diameter : string\n        Dictionary key of the throat diameter values.\n\n    throat_centroid : string, optional\n        Dictionary key of the throat centroid values. See the notes.\n\n    Returns\n    -------\n    EP : dictionary\n        Coordinates of throat endpoints stored in Dict form. Can be accessed\n        via the dict keys 'head' and 'tail'.\n\n    Notes\n    -----\n    (1) This model should not be applied to true 2D networks. Use\n    ``circular_pores`` model instead.\n\n    (2) By default, this model assumes that throat centroid and pore\n    coordinates are colinear. If that's not the case, such as in extracted\n    networks, ``throat_centroid`` could be passed as an optional argument, and\n    the model takes care of the rest.\n\n    \"\"\"\nnetwork = target.project.network\nthroats = network.map_throats(throats=target.Ts, origin=target)\nxyz = network['pore.coords']\ncn = network['throat.conns'][throats]\nL = _ctc(target=target) + 1e-15\nDt = network[throat_diameter][throats]\nD1 = network[pore_diameter][cn[:, (0)]]\nD2 = network[pore_diameter][cn[:, (1)]]\nL1 = _np.zeros_like(L)\nL2 = _np.zeros_like(L)\nmask = Dt > D1\nL1[mask] = 0.5 * D1[mask]\nL1[~mask] = _np.sqrt(D1[~mask] ** 2 - Dt[~mask] ** 2) / 2\nmask = Dt > D2\nL2[mask] = 0.5 * D2[mask]\nL2[~mask] = _np.sqrt(D2[~mask] ** 2 - Dt[~mask] ** 2) / 2\ntry:\n    TC = network[throat_centroid][throats]\n    LP1T = _np.linalg.norm(TC - xyz[cn[:, (0)]], axis=1) + 1e-15\n    LP2T = _np.linalg.norm(TC - xyz[cn[:, (1)]], axis=1) + 1e-15\n    unit_vec_P1T = (TC - xyz[cn[:, (0)]]) / LP1T[:, (None)]\n    unit_vec_P2T = (TC - xyz[cn[:, (1)]]) / LP2T[:, (None)]\nexcept KeyError:\n    unit_vec_P1T = (xyz[cn[:, (1)]] - xyz[cn[:, (0)]]) / L[:, (None)]\n    unit_vec_P2T = -1 * unit_vec_P1T\nEP1 = xyz[cn[:, (0)]] + L1[:, (None)] * unit_vec_P1T\nEP2 = xyz[cn[:, (1)]] + L2[:, (None)] * unit_vec_P2T\nL1 = (4 * L ** 2 + D1 ** 2 - D2 ** 2) / (8 * L)\nL2 = (4 * L ** 2 + D2 ** 2 - D1 ** 2) / (8 * L)\nh = (2 * _np.sqrt(D1 ** 2 / 4 - L1 ** 2)).real\noverlap = L - 0.5 * (D1 + D2) < 0\nmask = overlap & (Dt < h)\nEP1[mask] = (xyz[cn[:, (0)]] + L1[:, (None)] * unit_vec_P1T)[mask]\nEP2[mask] = (xyz[cn[:, (1)]] + L2[:, (None)] * unit_vec_P2T)[mask]\nreturn {'head': EP1, 'tail': EP2}\n"
}
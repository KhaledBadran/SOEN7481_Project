{
    "functionName": "scale_data_colormap",
    "className": "Brain",
    "fileName": "/nipy_&_PySurfer/surfer_&_viz.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Scale the data colormap.\n\n        The colormap may be sequential or divergent. When the colormap is\n        divergent indicate this by providing a value for 'center'. The\n        meanings of fmin, fmid and fmax are different for sequential and\n        divergent colormaps. For sequential colormaps the colormap is\n        characterised by::\n\n            [fmin, fmid, fmax]\n\n        where fmin and fmax define the edges of the colormap and fmid will be\n        the value mapped to the center of the originally chosen colormap. For\n        divergent colormaps the colormap is characterised by::\n\n            [center-fmax, center-fmid, center-fmin, center,\n             center+fmin, center+fmid, center+fmax]\n\n        i.e., values between center-fmin and center+fmin will not be shown\n        while center-fmid will map to the middle of the first half of the\n        original colormap and center-fmid to the middle of the second half.\n\n        Parameters\n        ----------\n        fmin : float\n            minimum value for colormap\n        fmid : float\n            value corresponding to color midpoint\n        fmax : float\n            maximum value for colormap\n        transparent : boolean\n            if True: use a linear transparency between fmin and fmid and make\n            values below fmin fully transparent (symmetrically for divergent\n            colormaps)\n        center : float\n            if not None, gives the data value that should be mapped to the\n            center of the (divergent) colormap\n        alpha : float\n            sets the overall opacity of colors, maintains transparent regions\n        data : dict | None\n            The data entry for which to scale the colormap.\n            If None, will use the data dict from either the left or right\n            hemisphere (in that order).\n        hemi : str | None\n            If None, all hemispheres will be scaled.\n        verbose : bool, str, int, or None\n            If not None, override default verbose level (see surfer.verbose).\n        \"\"\"\ndivergent = center is not None\nhemis = self._check_hemis(hemi)\ndel hemi\nif data is None:\n    for hemi in hemis:\n        data = self.data_dict[hemi]\n        if data is not None:\n            break\ntable = data['orig_ctable'].copy()\nlut = _scale_mayavi_lut(table, fmin, fmid, fmax, transparent, center, alpha)\nbgcolor = self._brain_color\nviews = self._toggle_render(False)\nfor hemi in hemis:\n    data = self.data_dict[hemi]\n    if data is not None:\n        for surf in data['surfaces']:\n            cmap = surf.module_manager.scalar_lut_manager\n            cmap.load_lut_from_list(lut / 255.0)\n            if divergent:\n                cmap.data_range = np.array([center - fmax, center + fmax])\n            else:\n                cmap.data_range = np.array([fmin, fmax])\n            if np.any(lut[:, (-1)] < 255):\n                cbar_lut = tvtk.LookupTable()\n                cbar_lut.deep_copy(surf.module_manager.scalar_lut_manager.lut)\n                alphas = lut[:, (-1)][:, (np.newaxis)] / 255.0\n                use_lut = lut.copy()\n                use_lut[:, (-1)] = 255.0\n                vals = use_lut * alphas + bgcolor * (1 - alphas)\n                cbar_lut.table.from_array(vals)\n                cmap.scalar_bar.lookup_table = cbar_lut\n                cmap.scalar_bar.use_opacity = 1\n        data.update(fmin=fmin, fmid=fmid, fmax=fmax, center=center,\n            transparent=transparent)\n        for glyph in data['glyphs']:\n            if glyph is not None:\n                l_m = glyph.parent.vector_lut_manager\n                l_m.load_lut_from_list(lut / 255.0)\n                if divergent:\n                    l_m.data_range = np.array([center - fmax, center + fmax])\n                else:\n                    l_m.data_range = np.array([fmin, fmax])\nself._toggle_render(True, views)\nverbose"
}
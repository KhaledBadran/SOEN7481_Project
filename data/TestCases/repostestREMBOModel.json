{
    "functionName": "testREMBOModel",
    "className": "REMBOTest",
    "fileName": "/facebook_&_Ax/ax_&_models_&_tests_&_test_rembo.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "A = torch.cat((torch.eye(2), -torch.eye(2)))\ninitial_X_d = torch.tensor([[0.25, 0.5], [1, 0], [0, -1]])\nbounds_d = [(-2, 2), (-2, 2)]\nmy_metric_names = ['a', 'b']\nm = REMBO(A=A, initial_X_d=initial_X_d, bounds_d=bounds_d)\nself.assertTrue(torch.allclose(A, m.A))\nself.assertTrue(torch.allclose(torch.pinverse(A), m._pinvA))\nself.assertEqual(m.bounds_d, bounds_d)\nself.assertEqual(len(m.X_d), 3)\nX_D = torch.t(torch.mm(A, torch.t(initial_X_d)))\nXs = [X_D, X_D.clone()]\nYs = [torch.randn(3, 1)] * 2\nYvars = [0.1 * torch.ones(3, 1)] * 2\nbounds = [(-1, 1)] * 4\nwith self.assertRaises(AssertionError):\n    m.fit(Xs=Xs, Ys=Ys, Yvars=Yvars, bounds=[(0, 1)] * 4, task_features=[],\n        feature_names=[], metric_names=my_metric_names, fidelity_features=[])\nwith mock.patch('ax.models.torch.botorch_defaults.fit_gpytorch_model',\n    autospec=True):\n    m.fit(Xs=Xs, Ys=Ys, Yvars=Yvars, bounds=bounds, task_features=[],\n        feature_names=[], metric_names=my_metric_names, fidelity_features=[])\nfor x in m.Xs:\n    self.assertTrue(torch.allclose(x, m.to_01(initial_X_d)))\nself.assertEqual(len(m.X_d), 3)\nX_d2 = torch.tensor([[0.25, 0.5], [2.0, 0.0], [-4.0, 4.0]])\nX_D2 = torch.tensor([[0.25, 0.5, -0.25, -0.5], [1.0, 0.0, -1.0, 0.0], [-1.0,\n    1.0, 1.0, -1.0]])\nZ = m.project_up(X_d2)\nself.assertTrue(torch.allclose(Z, X_D2))\nf1, var = m.predict(X=X_D)\nself.assertEqual(f1.shape, torch.Size([3, 2]))\nwith self.assertRaises(NotImplementedError):\n    m.predict(torch.tensor([[0.1, 0.2, 0.3, 0.4]]))\nf2, var = m.predict(initial_X_d)\nself.assertTrue(torch.allclose(f1, f2))\nx_best = m.best_point(bounds=[(-1, 1)] * 4, objective_weights=torch.tensor(\n    [1.0, 0.0]))\nself.assertEqual(len(x_best), 4)\nf, var = m.cross_validate(Xs_train=[X_D[:-1, :], X_D[:-1, :]], Ys_train=[Ys\n    [0][:-1, :], Ys[1][:-1, :]], Yvars_train=[Yvars[0][:-1, :], Yvars[1][:-\n    1, :]], X_test=X_D[-1:, :])\nself.assertEqual(f.shape, torch.Size([1, 2]))\nXgen_d = torch.tensor([[0.4, 0.8], [-0.2, 1.0]])\nacqfv_dummy = torch.tensor([[0.0, 0.0], [0.0, 0.0]])\nwith mock.patch('ax.models.torch.botorch_defaults.optimize_acqf', autospec=\n    True, return_value=(Xgen_d, acqfv_dummy)):\n    Xgen, w, _, __ = m.gen(n=2, bounds=[(-1, 1)] * 4, objective_weights=\n        torch.tensor([1.0, 0.0]))\nself.assertEqual(Xgen.shape[1], 4)\nself.assertEqual(len(m.X_d), 5)\nwith self.assertRaises(ValueError):\n    m.update(Xs=[torch.tensor([[0.1, 0.2, 0.3, 0.4]])] * 2, Ys=[torch.randn\n        (1, 1)] * 2, Yvars=[torch.ones(1, 1)] * 2)\nm.update(Xs=[Xgen] * 2, Ys=[torch.randn(2, 1)] * 2, Yvars=[torch.ones(2, 1)\n    ] * 2)\nfor x in m.Xs:\n    self.assertTrue(torch.allclose(x, Xgen_d))\n"
}
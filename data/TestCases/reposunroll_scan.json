{
    "functionName": "unroll_scan",
    "className": null,
    "fileName": "/Lasagne_&_Lasagne/lasagne_&_utils.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n        Helper function to unroll for loops. Can be used to unroll theano.scan.\n        The parameter names are identical to theano.scan, please refer to here\n        for more information.\n\n        Note that this function does not support the truncate_gradient\n        setting from theano.scan.\n\n        Parameters\n        ----------\n\n        fn : function\n            Function that defines calculations at each step.\n\n        sequences : TensorVariable or list of TensorVariables\n            List of TensorVariable with sequence data. The function iterates\n            over the first dimension of each TensorVariable.\n\n        outputs_info : list of TensorVariables\n            List of tensors specifying the initial values for each recurrent\n            value.\n\n        non_sequences: list of TensorVariables\n            List of theano.shared variables that are used in the step function.\n\n        n_steps: int\n            Number of steps to unroll.\n\n        go_backwards: bool\n            If true the recursion starts at sequences[-1] and iterates\n            backwards.\n\n        Returns\n        -------\n        List of TensorVariables. Each element in the list gives the recurrent\n        values at each time step.\n\n        \"\"\"\nif not isinstance(sequences, (list, tuple)):\n    sequences = [sequences]\ncounter = range(n_steps)\nif go_backwards:\n    counter = counter[::-1]\noutput = []\nprev_vals = outputs_info\nfor i in counter:\n    step_input = [s[i] for s in sequences] + prev_vals + non_sequences\n    out_ = fn(*step_input)\n    if isinstance(out_, T.TensorVariable):\n        out_ = [out_]\n    if isinstance(out_, tuple):\n        out_ = list(out_)\n    output.append(out_)\n    prev_vals = output[-1]\noutput_scan = []\nfor i in range(len(output[0])):\n    l = map(lambda x: x[i], output)\n    output_scan.append(T.stack(*l))\nreturn output_scan\n"
}
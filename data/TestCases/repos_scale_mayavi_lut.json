{
    "functionName": "_scale_mayavi_lut",
    "className": null,
    "fileName": "/nipy_&_PySurfer/surfer_&_viz.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Scale a mayavi colormap LUT to a given fmin, fmid and fmax.\n\n    This function operates on a Mayavi LUTManager. This manager can be obtained\n    through the traits interface of mayavi. For example:\n    ``x.module_manager.vector_lut_manager``.\n\n    Divergent colormaps are respected, if ``center`` is given, see\n    ``Brain.scale_data_colormap`` for more info.\n\n    Parameters\n    ----------\n    lut_orig : array\n        The original LUT.\n    fmin : float\n        minimum value of colormap.\n    fmid : float\n        value corresponding to color midpoint.\n    fmax : float\n        maximum value for colormap.\n    transparent : boolean\n        if True: use a linear transparency between fmin and fmid and make\n        values below fmin fully transparent (symmetrically for divergent\n        colormaps)\n    center : float\n        gives the data value that should be mapped to the center of the\n        (divergent) colormap\n    alpha : float\n        sets the overall opacity of colors, maintains transparent regions\n    verbose : bool, str, int, or None\n        If not None, override default verbose level (see mne.verbose).\n\n    Returns\n    -------\n    lut_table_new : 2D array (n_colors, 4)\n        The re-scaled color lookup table\n    \"\"\"\nif not fmin < fmid and fmid < fmax:\n    raise ValueError('Invalid colormap, we need fmin<fmid<fmax')\nif not 0 <= alpha <= 1:\n    raise ValueError('Invalid alpha: it needs to be within [0, 1]')\nfmin = float(fmin)\nfmid = float(fmid)\nfmax = float(fmax)\n_check_limits(fmin, fmid, fmax)\ndivergent = center is not None\ntrstr = ['(opaque)', '(transparent)']\nif divergent:\n    logger.debug(\n        'colormap divergent: center=%0.2e, [%0.2e, %0.2e, %0.2e] %s' % (\n        center, fmin, fmid, fmax, trstr[transparent]))\nelse:\n    logger.debug('colormap sequential: [%0.2e, %0.2e, %0.2e] %s' % (fmin,\n        fmid, fmax, trstr[transparent]))\nn_colors = lut_table.shape[0]\nif transparent:\n    if divergent:\n        N4 = np.full(4, n_colors / 4, dtype=int)\n        N4[:np.mod(n_colors, 4)] += 1\n        assert N4.sum() == n_colors\n        lut_table[:, (-1)] = np.r_[255 * np.ones(N4[0]), np.linspace(255, 0,\n            N4[2]), np.linspace(0, 255, N4[3]), 255 * np.ones(N4[1])]\n    else:\n        n_colors2 = int(n_colors / 2)\n        lut_table[:n_colors2, (-1)] = np.linspace(0, 255, n_colors2)\n        lut_table[n_colors2:, (-1)] = 255 * np.ones(n_colors - n_colors2)\nalpha = float(alpha)\nif alpha < 1.0:\n    lut_table[:, (-1)] = lut_table[:, (-1)] * alpha\nif divergent:\n    n_colors2 = int(n_colors / 2)\n    n_fill = int(round(fmin * n_colors2 / (fmax - fmin))) * 2\n    lut_table = np.r_[_scale_sequential_lut(lut_table[:n_colors2, :], \n        center - fmax, center - fmid, center - fmin), _get_fill_colors(\n        lut_table[n_colors2 - 3:n_colors2 + 3, :], n_fill),\n        _scale_sequential_lut(lut_table[n_colors2:, :], center + fmin, \n        center + fmid, center + fmax)]\nelse:\n    lut_table = _scale_sequential_lut(lut_table, fmin, fmid, fmax)\nn_colors = lut_table.shape[0]\nif n_colors != 256:\n    lut = np.zeros((256, 4))\n    x = np.linspace(1, n_colors, 256)\n    for chan in range(4):\n        lut[:, (chan)] = np.interp(x, np.arange(1, n_colors + 1), lut_table\n            [:, (chan)])\n    lut_table = lut\nreturn lut_table\nverbose"
}
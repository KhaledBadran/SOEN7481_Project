{
    "functionName": "test_ParamQuantitativeAnalysis",
    "className": null,
    "fileName": "/NSLS-II_&_PyXRF/pyxrf_&_core_&_tests_&_test_quant_analysis.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "incident_energy = 12.0\nfile_paths, img_list = create_ref_calib_data(tmp_path, incident_energy=\n    incident_energy)\nn_entries = len(file_paths)\nassert n_entries >= 2, 'The number of calibration data entries must be >= 2. Test can not be performed.'\nfln0 = file_paths[0]\npqa = ParamQuantitativeAnalysis()\nfor fpath in file_paths:\n    pqa.load_entry(file_path=fpath)\nassert pqa.get_n_entries(\n    ) == n_entries, 'Incorrect number of loaded calibration data entries'\nassert pqa.get_file_path_list(\n    ) == file_paths, 'The returned list of file paths is not the same as the expected list'\npqa.load_entry(fln0)\nassert len(pqa.calibration_data\n    ) == n_entries, 'Incorrect number of loaded calibration data entries'\nassert len(pqa.calibration_settings\n    ) == n_entries, \"Unexpected number of 'calibration_settings' elements\"\npqa.remove_entry(file_path=fln0)\nassert len(pqa.calibration_data\n    ) == n_entries - 1, 'The result of calibration entry removal is not as expected'\nassert len(pqa.calibration_settings\n    ) == n_entries - 1, \"Unexpected number of 'calibration_settings' elements\"\npqa.load_entry(fln0)\nassert len(pqa.calibration_data\n    ) == n_entries, 'Incorrect number of loaded calibration data entries'\nassert len(pqa.calibration_settings\n    ) == n_entries, \"Unexpected number of 'calibration_settings' elements\"\nassert pqa.calibration_settings[-1]['file_path'\n    ] == fln0, \"The last element of 'calibration_settings' list contains wrong calibration data entry\"\nfor n, fp in enumerate(file_paths):\n    n_expected = n - 1\n    if n_expected < 0:\n        n_expected += n_entries\n    assert pqa.find_entry_index(fp\n        ) == n_expected, f\"Index of the calibration entry '{fp}' is determined incorrectly\"\nfor fp in file_paths:\n    assert pqa.get_entry_text_preview(fp\n        ), f\"Failed to generate text preview for the calibration entry '{fp}'\"\neline_list_expected = []\nfor settings in pqa.calibration_settings:\n    for ln in settings['element_lines'].keys():\n        if ln not in eline_list_expected:\n            eline_list_expected.append(ln)\npqa.update_emission_line_list()\nassert pqa.active_emission_lines == eline_list_expected, 'Generated emission line list does not match the expected list'\nelist0 = list(pqa.calibration_settings[0]['element_lines'].keys())\nelist1 = list(pqa.calibration_settings[1]['element_lines'].keys())\nelist = list(set(elist0).intersection(set(elist1)))\ndef set_selection(pqa, elist, selection):\n    for ln, sel in zip(elist, selection):\n        el_info = pqa.get_eline_info_complete(ln)\n        assert len(el_info\n            ) >= 2, f'The emission line {ln} must exist in at least 2 entries'\n        el_info[0]['eline_settings']['selected'] = sel\n        el_info[1]['eline_settings']['selected'] = not sel\ndef check_selection(pqa, elist, selection):\n    for ln, sel in zip(elist, selection):\n        selected = pqa.calibration_settings[0]['element_lines'][ln]['selected']\n        selected1 = pqa.calibration_settings[1]['element_lines'][ln]['selected'\n            ]\n        assert selected == sel, f\"Entry 0: selection state of element line '{ln}' incorrect\"\n        assert selected1 != sel, f\"Entry 1: selection state of element line '{ln}' incorrect\"\npqa.update_emission_line_list()\nsel_list = [True] * len(elist)\ncheck_selection(pqa, elist, sel_list)\nsel_list = [False] * len(elist)\nset_selection(pqa, elist, sel_list)\npqa.update_emission_line_list()\ncheck_selection(pqa, elist, sel_list)\npqa.calibration_settings[0]['element_lines'][elist[0]]['selected'] = True\npqa.update_emission_line_list()\nsel_list[0] = True\npqa.update_emission_line_list()\ncheck_selection(pqa, elist, sel_list)\nfln1 = pqa.calibration_settings[0]['file_path']\npqa.remove_entry(fln1)\nfor ln in elist:\n    assert pqa.calibration_settings[0]['element_lines'][ln]['selected'\n        ], f'Element line {ln} is not selected in calibration entry #0'\npqa.load_entry(fln1)\nsel_list = [True] * len(elist)\ncheck_selection(pqa, elist, sel_list)\nel_info = pqa.get_eline_info_complete(elist[0])\nassert el_info[0]['eline_data'] == pqa.calibration_data[0]['element_lines'][\n    elist[0]], 'Returned calibration data does not match the expected data'\nassert el_info[0]['eline_settings'] == pqa.calibration_settings[0][\n    'element_lines'][elist[0]\n    ], 'Returned calibration settings do not match the settings dictionary'\nassert el_info[0]['standard_data'] == pqa.calibration_data[0\n    ], 'Returned standard data does not match the expected data'\nassert el_info[0]['standard_settings'] == pqa.calibration_settings[0\n    ], 'Returned standard settings does not match the settings dictionary'\nel_calib = pqa.get_eline_calibration(elist[0])\nassert el_calib['fluorescence'] == pqa.calibration_data[0]['element_lines'][\n    elist[0]]['fluorescence'\n    ], 'The returned selected emission line calibration is incorrect'\npqa.set_experiment_detector_channel('sum')\nassert pqa.experiment_detector_channel == 'sum', 'Detector channel is set incorrectly'\npqa.set_experiment_distance_to_sample(2.0)\nassert pqa.experiment_distance_to_sample == 2.0, 'Distance-to-sample is set incorrectly'\npqa.set_experiment_incident_energy(12.0)\nassert pqa.experiment_incident_energy == 12.0, 'Incident energy is set incorrectly'\nimg_dict = img_list[0]\neline = elist[0]\nscaler, scaler2 = 'sclr', 'sclr2'\nscaler_dict = {scaler: img_dict[scaler], scaler2: img_dict[scaler] * 2}\ndata_mean, scaler_mean = np.mean(img_dict[eline]), np.mean(scaler_dict[scaler])\nel_calib = pqa.get_eline_calibration(elist[0])\ncalib_fluor, calib_density = el_calib['fluorescence'], el_calib['density']\ndata_out, is_applied = pqa.apply_quantitative_normalization(img_dict[eline],\n    scaler_dict=scaler_dict, scaler_name_default=scaler2, data_name=eline,\n    name_not_scalable=None)\nnpt.assert_almost_equal(np.mean(data_out), data_mean / scaler_mean *\n    calib_density / calib_fluor, err_msg=\n    'The value of normalized map is different from expected')\nassert is_applied, 'Quantitative normalization was not applied'\npqa.set_experiment_distance_to_sample(0.0)\ndata_out, is_applied = pqa.apply_quantitative_normalization(img_dict[eline],\n    scaler_dict=scaler_dict, scaler_name_default=scaler2, data_name=eline,\n    name_not_scalable=None)\nnpt.assert_almost_equal(np.mean(data_out), data_mean / scaler_mean *\n    calib_density / calib_fluor, err_msg=\n    'The value of normalized map is different from expected')\nassert is_applied, 'Quantitative normalization was not applied'\npqa.set_experiment_distance_to_sample(4.0)\ndata_out, is_applied = pqa.apply_quantitative_normalization(img_dict[eline],\n    scaler_dict=scaler_dict, scaler_name_default=scaler2, data_name=eline,\n    name_not_scalable=None)\nnpt.assert_almost_equal(np.mean(data_out), data_mean / scaler_mean *\n    calib_density / calib_fluor * 4.0, err_msg=\n    'The value of normalized map is different from expected')\nassert is_applied, 'Quantitative normalization was not applied'\ndata_out, is_applied = pqa.apply_quantitative_normalization(img_dict[eline],\n    scaler_dict=scaler_dict, scaler_name_default=scaler2, data_name='Cu_K',\n    name_not_scalable=None)\nnpt.assert_almost_equal(np.mean(data_out), data_mean / (scaler_mean * 2),\n    err_msg='The value of normalized map is different from expected')\nassert not is_applied, 'Quantitative normalization was applied'\nscaler_dict2 = scaler_dict.copy()\ndel scaler_dict2['sclr']\ndata_out, is_applied = pqa.apply_quantitative_normalization(img_dict[eline],\n    scaler_dict=scaler_dict2, scaler_name_default=scaler2, data_name=eline,\n    name_not_scalable=None)\nnpt.assert_almost_equal(np.mean(data_out), data_mean / (scaler_mean * 2),\n    err_msg='The value of normalized map is different from expected')\nassert not is_applied, 'Quantitative normalization was applied'\ndata_out, is_applied = pqa.apply_quantitative_normalization(img_dict[eline],\n    scaler_dict=scaler_dict, scaler_name_default='sclr3', data_name='Cu_K',\n    name_not_scalable=['sclr2', 'sclr'])\nassert data_out is img_dict[eline\n    ], 'Function output is not a reference to the input data'\nassert not is_applied, 'Quantitative normalization was applied'\ndata_out, is_applied = pqa.apply_quantitative_normalization(img_dict[eline],\n    scaler_dict=scaler_dict, scaler_name_default=scaler2, data_name=eline,\n    name_not_scalable=['sclr2', eline, 'sclr'])\nassert data_out is img_dict[eline\n    ], 'Function output is not a reference to the input data'\nassert not is_applied, 'Quantitative normalization was applied'\n"
}
{
    "functionName": "plotRaw1D",
    "className": "DataSet",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"plot 1D figures of data in the specified DASEL.\n        \n        kwargs:\n            detectorSelection (int): Detector to be used (default from file)\n            \n            analyzerSelection (int): Analyzer segment to be used (default from file)\n\n            legend (bool list): Insert legend with provided names or file names (default True)\n\n            grid (bool, Int): If true plot at grid on figure. If integer set zorder of grid (default -10)\n            \n        returns:\n            Ax (list): List of axes in which data are plotted.\n        \"\"\"\ndef intrextrapolate(oldPosition, oldValues, newValues):\n    \"\"\"interpolates between old and new through linear regression and returns best estimate at old positions\n            \n            arg:\n            oldPosition (list): List of position to estimate the new value at (in coordinates of oldValues)\n            \n            oldValues (list): List of old values \n            \n            newValues (list): List of new values\n            \n            return:\n                newPosition (list): estimate of newValue at oldPosition\n            \"\"\"\n    oldOffset = oldValues[0]\n    oldSize = np.diff([oldValues[0], oldValues[-1]])\n    newOffset = newValues[0]\n    newSize = np.diff([newValues[0], newValues[-1]])\n    X = (oldPosition - oldOffset) / oldSize\n    newPosition = X * newSize + newOffset\n    return newPosition\ndef format_coord(x, y, X, labels):\n    \"\"\"format coordinates according to x and y. When X is multidimensional an approximation for its value at x is estimated\"\"\"\n    fmtOrder = np.ceil(-np.log(np.mean(np.abs(np.diff(X, axis=1)), axis=1)))\n    fmtOrder = [(o if o > 0 else 0) for o in fmtOrder.astype(int)]\n    xFormatString = [('{:.' + str(fO) + 'f}') for fO in fmtOrder]\n    newX = [intrextrapolate(x, X[0], XX)[0] for XX in X[1:]]\n    xs = [fstring.format(XX) for fstring, XX in zip(xFormatString, np.\n        concatenate([[x], newX], axis=0))]\n    return ', '.join([(label + ' = ' + str(X)) for X, label in zip(np.\n        concatenate([xs, [y]], axis=0), labels)])\ndef onclick(event, ax):\n    if ax.in_axes(event):\n        try:\n            C = ax.get_figure().canvas.cursor().shape()\n        except:\n            pass\n        else:\n            if C != 0:\n                return\n        x = event.xdata\n        y = event.ydata\n        if hasattr(ax, '__format_coord__'):\n            print(ax.__format_coord__(x, y))\n        else:\n            print(ax.format_coord(x, y))\n_, ax = plt.subplots()\nif legend:\n    if legend is True:\n        legend = [d.name for d in self]\n    elif len(legend) != len(self):\n        raise AttributeError(\n            'Provided list of legends does not match length of dataset. Expected {}, but got {}'\n            .format(len(self), len(legend)))\nax.X, ax.I, ax.parameter, ax.unit = self.cutRaw1D(detectorSelection=\n    detectorSelection, analyzerSelection=analyzerSelection)\nax.xlabels = ['{} [{}s]'.format(p, u) for p, u in zip(ax.parameter, ax.unit)]\nax.__labels__ = np.concatenate([ax.xlabels, ['Int [count]']], axis=0)\nplots = []\nfor X, I in zip(ax.X, ax.I):\n    plots.append(ax.scatter(X[0], I))\nax.set_ylabel('Int [counts]')\nax.__format_coord__ = lambda x, y: format_coord(x, y, X=np.concatenate(ax.X,\n    axis=0), labels=ax.__labels__)\nax.format_coord = lambda x, y: ax.__format_coord__(x, y)\nax._button_press_event = ax.figure.canvas.mpl_connect('button_press_event',\n    lambda event: onclick(event, ax))\nax.set_xlabel(ax.xlabels[0])\nif legend:\n    for plot, lab in zip(plots, legend):\n        plot.set_label(lab)\n    ax.legend()\nax.grid(grid)\nreturn ax\n"
}
{
    "functionName": "recovery_tester",
    "className": null,
    "fileName": "/PECOS-packages_&_PECOS/tests_&_example_tests_&_test_recovery.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Used to check:\n     - That ideal logical |0> and |+> return the same output for check measurements.\n     - That whether a recovery operation flips a logical operator or not can be determined.\n\n    Args:\n        qecc:\n\n    Returns:\n\n    \"\"\"\ninitzero = pc.circuits.LogicalCircuit(suppress_warning=True)\ninitzero.append(qecc.gate('ideal init |0>'))\ninitplus = pc.circuits.LogicalCircuit(suppress_warning=True)\ninitplus.append(qecc.gate('ideal init |+>'))\nsyn_ext = pc.circuits.LogicalCircuit(suppress_warning=True)\nsyn_ext.append(qecc.gate('I', num_syn_extract=1))\ndepolar = pc.error_gens.DepolarGen(model_level='code_capacity')\nsim = pc.circuit_runners.Standard()\nstate_zero = sim.init(qecc.num_qudits)\noutput_zero, _ = sim.run_logic(state_zero, initzero)\nassert not output_zero\nstate_plus = sim.init(qecc.num_qudits)\noutput_plus, _ = sim.run_logic(state_plus, initplus)\nassert not output_plus\noutput1, error_circuits1 = sim.run_logic(state_zero, syn_ext)\noutput2, error_circuits2 = sim.run_logic(state_plus, syn_ext)\nassert error_circuits1 == error_circuits2\nassert not error_circuits1\nassert output1 == output2\nassert not output1\noutput1, error_circuits1 = sim.run_logic(state_zero, syn_ext, error_gen=\n    depolar, error_params={'p': 0.3})\noutput2, error_circuits2 = sim.run_logic(state_plus, syn_ext,\n    error_circuits=error_circuits1)\nassert error_circuits1 == error_circuits2\nassert output1 == output2\nlogical_ops = qecc.instruction('instr_syn_extract').final_logical_ops[0]\nsign1 = state_zero.logical_sign(logical_ops['Z'], logical_ops['X'])\nsign2 = state_plus.logical_sign(logical_ops['X'], logical_ops['Z'])\nmwpm2d = pc.decoders.MWPM2D(qecc)\nrecovery = mwpm2d.decode(output2)\ncommute1 = pc.misc.commute.qubit_pauli(logical_ops['Z'], recovery)\ncommute2 = pc.misc.commute.qubit_pauli(logical_ops['X'], recovery)\nsim.run_circuit(state_zero, recovery)\nsim.run_circuit(state_plus, recovery)\nsign1_new = state_zero.logical_sign(logical_ops['Z'], logical_ops['X'])\nsign2_new = state_plus.logical_sign(logical_ops['X'], logical_ops['Z'])\nif commute1:\n    assert sign1 == sign1_new\nelse:\n    assert sign1 != sign1_new\nif commute2:\n    assert sign2 == sign2_new\nelse:\n    assert sign2 != sign2_new\n"
}
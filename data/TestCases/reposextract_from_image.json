{
    "functionName": "extract_from_image",
    "className": "RotatedBox",
    "fileName": "/konstantint_&_PassportEye/passporteye_&_util_&_geometry.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Extracts the contents of this box from a given image.\n        For that the image is \"unrotated\" by the appropriate angle, and the corresponding part is extracted from it.\n\n        Returns an image with dimensions height*scale x width*scale.\n        Note that the box coordinates are interpreted as \"image coordinates\" (i.e. x is row and y is column),\n        and box angle is considered to be relative to the vertical (i.e. np.pi/2 is \"normal orientation\")\n\n        :param img: a numpy ndarray suitable for image processing via skimage.\n        :param scale: the RotatedBox is scaled by this value before performing the extraction.\n            This is necessary when, for example, the location of a particular feature is determined using a smaller image,\n            yet then the corresponding area needs to be extracted from the original, larger image.\n            The scale parameter in this case should be width_of_larger_image/width_of_smaller_image.\n        :param margin_width: The margin that should be added to the width dimension of the box from each size.\n            This value is given wrt actual box dimensions (i.e. not scaled).\n        :param margin_height: The margin that should be added to the height dimension of the box from each side.\n        :return: a numpy ndarray, corresponding to the extracted region (aligned straight).\n\n        TODO: This could be made more efficient if we avoid rotating the full image and cut out the ROI from it beforehand.\n        \"\"\"\nrotate_by = (np.pi / 2 - self.angle) * 180 / np.pi\nimg_rotated = transform.rotate(img, angle=rotate_by, center=[self.center[1] *\n    scale, self.center[0] * scale], resize=True)\nshift_c, shift_r = self._compensate_rotation_shift(img, scale)\nr1 = max(int((self.center[0] - self.height / 2 - margin_height) * scale -\n    shift_r), 0)\nr2 = int((self.center[0] + self.height / 2 + margin_height) * scale - shift_r)\nc1 = max(int((self.center[1] - self.width / 2 - margin_width) * scale -\n    shift_c), 0)\nc2 = int((self.center[1] + self.width / 2 + margin_width) * scale - shift_c)\nreturn img_rotated[r1:r2, c1:c2]\n"
}
{
    "functionName": "import_cmaps",
    "className": null,
    "fileName": "/1313e_&_CMasher/cmasher_&_utils.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Reads in custom colormaps from a provided file or directory `cmap_path`;\n    transforms them into :obj:`~matplotlib.colors.ListedColormap` objects; and\n    makes them available in the :mod:`cmasher.cm` module, in addition to\n    registering them in the :mod:`matplotlib.cm` module.\n    Both the imported colormap and its reversed version will be registered.\n\n    If a provided colormap is a 'cyclic' colormap, its shifted version will\n    also be registered.\n\n    Parameters\n    ----------\n    cmap_path : str\n        Relative or absolute path to a custom colormap file; or directory that\n        contains custom colormap files. A colormap file can be a *NumPy* binary\n        file ('.npy'); a *viscm* source file ('.jscm'); or any text file.\n        If the file is not a JSCM-file, it must contain the normalized RGB\n        values that define the colormap.\n\n    Notes\n    -----\n    All colormap files must have names starting with the 'cm\\\\_' prefix. The\n    resulting colormaps will have the name of their file without the prefix and\n    extension.\n\n    In *MPL*, the colormaps will have the added 'cmr.' prefix to avoid name\n    clashes.\n\n    Example\n    -------\n    Importing a colormap named 'test' can be done by saving its normalized RGB\n    values in a file called 'cm_test.txt' and executing\n\n        >>> import_cmaps('/path/to/dir/cm_test.txt')\n\n    The 'test' colormap is now available in *CMasher* and *MPL* using\n\n        >>> cmr.cm.test                 # CMasher\n        >>> plt.get_cmap('cmr.test')    # MPL\n\n    \"\"\"\ncmap_path = path.abspath(cmap_path)\nif not path.exists(cmap_path):\n    raise OSError(\"Input argument 'cmap_path' is a non-existing path (%r)!\" %\n        cmap_path)\nif path.isfile(cmap_path):\n    cmap_dir, cmap_file = path.split(cmap_path)\n    if not cmap_file.startswith('cm_'):\n        raise OSError(\n            \"Input argument 'cmap_path' does not lead to a file with the 'cm_' prefix (%r)!\"\n             % cmap_path)\n    cm_files = [cmap_file]\nelse:\n    cmap_dir = cmap_path\n    cm_files = list(map(path.basename, glob('%s/cm_*' % cmap_dir)))\n    cm_files.sort()\nfor cm_file in cm_files:\n    base_str, ext_str = path.splitext(cm_file)\n    cm_name = base_str[3:]\n    cm_file_path = path.join(cmap_dir, cm_file)\n    try:\n        if ext_str == '.npy':\n            rgb = np.load(cm_file_path)\n        elif ext_str == '.jscm':\n            try:\n                import viscm\n            except ImportError:\n                raise ImportError(\n                    \"The 'viscm' package is required to read '.jscm' files!\")\n            else:\n                cmap = viscm.gui.Colormap(None, None, None)\n                cmap.load(cm_file_path)\n                v = viscm.viscm_editor(uniform_space=cmap.uniform_space,\n                    cmtype=cmap.cmtype, method=cmap.method, **cmap.params)\n                rgb, _ = v.cmap_model.get_sRGB()\n        else:\n            rgb = np.genfromtxt(cm_file_path, dtype=None, encoding=None)\n        register_cmap(cm_name, rgb)\n        if get_cmap_type('cmr.' + cm_name) == 'cyclic':\n            idx = len(rgb) // 2\n            rgb_s = np.concatenate([rgb[idx:], rgb[:idx]], axis=0)\n            register_cmap(cm_name + '_shifted', rgb_s)\n    except Exception as error:\n        raise ValueError('Provided colormap %r is invalid! (%s)' % (cm_name,\n            error))\n"
}
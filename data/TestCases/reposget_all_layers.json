{
    "functionName": "get_all_layers",
    "className": null,
    "fileName": "/Lasagne_&_Lasagne/lasagne_&_layers_&_helper.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    This function gathers all layers below one or more given :class:`Layer`\n    instances, including the given layer(s). Its main use is to collect all\n    layers of a network just given the output layer(s). The layers are\n    guaranteed to be returned in a topological order: a layer in the result\n    list is always preceded by all layers its input depends on.\n\n    Parameters\n    ----------\n    layer : Layer or list\n        the :class:`Layer` instance for which to gather all layers feeding\n        into it, or a list of :class:`Layer` instances.\n\n    treat_as_input : None or iterable\n        an iterable of :class:`Layer` instances to treat as input layers\n        with no layers feeding into them. They will show up in the result\n        list, but their incoming layers will not be collected (unless they\n        are required for other layers as well).\n\n    Returns\n    -------\n    list\n        a list of :class:`Layer` instances feeding into the given\n        instance(s) either directly or indirectly, and the given\n        instance(s) themselves, in topological order.\n\n    Examples\n    --------\n    >>> from lasagne.layers import InputLayer, DenseLayer\n    >>> l_in = InputLayer((100, 20))\n    >>> l1 = DenseLayer(l_in, num_units=50)\n    >>> get_all_layers(l1) == [l_in, l1]\n    True\n    >>> l2 = DenseLayer(l_in, num_units=10)\n    >>> get_all_layers([l2, l1]) == [l_in, l2, l1]\n    True\n    >>> get_all_layers([l1, l2]) == [l_in, l1, l2]\n    True\n    >>> l3 = DenseLayer(l2, num_units=20)\n    >>> get_all_layers(l3) == [l_in, l2, l3]\n    True\n    >>> get_all_layers(l3, treat_as_input=[l2]) == [l2, l3]\n    True\n    \"\"\"\ntry:\n    queue = deque(layer)\nexcept TypeError:\n    queue = deque([layer])\nseen = set()\ndone = set()\nresult = []\nif treat_as_input is not None:\n    seen.update(treat_as_input)\nwhile queue:\n    layer = queue[0]\n    if layer is None:\n        queue.popleft()\n    elif layer not in seen:\n        seen.add(layer)\n        if hasattr(layer, 'input_layers'):\n            queue.extendleft(reversed(layer.input_layers))\n        elif hasattr(layer, 'input_layer'):\n            queue.appendleft(layer.input_layer)\n    else:\n        queue.popleft()\n        if layer not in done:\n            result.append(layer)\n            done.add(layer)\nreturn result\n"
}
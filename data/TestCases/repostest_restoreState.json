{
    "functionName": "test_restoreState",
    "className": "MethodicalTests",
    "fileName": "/glyph_&_Automat/automat_&__test_&_test_methodical.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "\"\"\"\n        L{MethodicalMachine.unserializer} decorates a function that becomes a\n        machine-state unserializer; its return value is mapped to the\n        C{serialized} parameter to C{state}, and the L{MethodicalMachine}\n        associated with that instance's state is updated to that state.\n        \"\"\"\nclass Mechanism(object):\n    m = MethodicalMachine()\n\n    def __init__(self):\n        self.value = 1\n        self.ranOutput = False\n\n    @m.state(serialized='first-state', initial=True)\n    def first(self):\n        \"\"\"First state.\"\"\"\n\n    @m.state(serialized='second-state')\n    def second(self):\n        \"\"\"Second state.\"\"\"\n\n    @m.input()\n    def input(self):\n        \"\"\"an input\"\"\"\n\n    @m.output()\n    def output(self):\n        self.value = 2\n        self.ranOutput = True\n        return 1\n\n    @m.output()\n    def output2(self):\n        return 2\n    first.upon(input, second, [output], collector=lambda x: list(x)[0])\n    second.upon(input, second, [output2], collector=lambda x: list(x)[0])\n\n    @m.serializer()\n    def save(self, state):\n        return {'machine-state': state, 'some-value': self.value}\n\n    @m.unserializer()\n    def _restore(self, blob):\n        self.value = blob['some-value']\n        return blob['machine-state']\n\n    @classmethod\n    def fromBlob(cls, blob):\n        self = cls()\n        self._restore(blob)\n        return self\nm1 = Mechanism()\nm1.input()\nblob = m1.save()\nm2 = Mechanism.fromBlob(blob)\nself.assertEqual(m2.ranOutput, False)\nself.assertEqual(m2.input(), 2)\nself.assertEqual(m2.save(), {'machine-state': 'second-state', 'some-value': 2})\n"
}
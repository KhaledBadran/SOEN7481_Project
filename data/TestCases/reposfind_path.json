{
    "functionName": "find_path",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_topotools_&_topotools.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Find the shortest path between pairs of pores.\n\n    Parameters\n    ----------\n    network : OpenPNM Network Object\n        The Network object on which the search should be performed\n\n    pore_pairs : array_like\n        An N x 2 array containing N pairs of pores for which the shortest\n        path is sought.\n\n    weights : array_like, optional\n        An Nt-long list of throat weights for the search.  Typically this\n        would be the throat lengths, but could also be used to represent\n        the phase configuration.  If no weights are given then the\n        standard topological connections of the Network are used.\n\n    Returns\n    -------\n    A dictionary containing both the pores and throats that define the\n    shortest path connecting each pair of input pores.\n\n    Notes\n    -----\n    The shortest path is found using Dijkstra's algorithm included in the\n    scipy.sparse.csgraph module\n\n    TODO: The returned throat path contains the correct values, but not\n    necessarily in the true order\n\n    Examples\n    --------\n    >>> import openpnm as op\n    >>> pn = op.network.Cubic(shape=[3, 3, 3])\n    >>> a = op.topotools.find_path(network=pn, pore_pairs=[[0, 4], [0, 10]])\n    >>> a['pores']\n    [array([0, 1, 4]), array([ 0,  1, 10])]\n    >>> a['throats']\n    [array([ 0, 19]), array([ 0, 37])]\n    \"\"\"\nPs = np.array(pore_pairs, ndmin=2)\nif weights is None:\n    weights = np.ones_like(network.Ts)\ngraph = network.create_adjacency_matrix(weights=weights, fmt='csr',\n    drop_zeros=False)\npaths = csgraph.dijkstra(csgraph=graph, indices=Ps[:, (0)],\n    return_predecessors=True)[1]\npores = []\nthroats = []\nfor row in range(0, np.shape(Ps)[0]):\n    j = Ps[row][1]\n    ans = []\n    while paths[row][j] > -9999:\n        ans.append(j)\n        j = paths[row][j]\n    ans.append(Ps[row][0])\n    ans.reverse()\n    pores.append(np.array(ans, dtype=int))\n    Ts = network.find_neighbor_throats(pores=ans, mode='xnor')\n    throats.append(np.array(Ts, dtype=int))\npdict = PrintableDict\ndict_ = pdict(**{'pores': pores, 'throats': throats})\nreturn dict_\n"
}
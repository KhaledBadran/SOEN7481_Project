{
    "functionName": "largest_sphere",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_models_&_geometry_&_pore_size.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Finds the maximum diameter pore that can be placed in each location without\n    overlapping any neighbors.\n\n    This method iteratively expands pores by increasing their diameter to\n    encompass half of the distance to the nearest neighbor.  If the neighbor\n    is not growing because it's already touching a different neighbor, then\n    the given pore will never quite touch this neighbor.  Increating the value\n    of ``iters`` will get it closer, but it's case of\n    [Zeno's paradox](https://en.wikipedia.org/wiki/Zeno%27s_paradoxes) with\n    each step cutting the remaining distance in half\n\n    Parameters\n    ----------\n    target : OpenPNM Object\n        The object which this model is associated with. This controls the\n        length of the calculated array, and also provides access to other\n        necessary properties.\n\n    fixed_diameter : string\n        The dictionary key containing the pore diameter values already\n        assigned to network, if any.  If not provided a starting value is\n        assumed as half-way to the nearest neighbor.\n\n    iters : integer\n        The number of iterations to perform when searching for maximum\n        diameter.  This function iteratively grows pores until they touch\n        their nearest neighbor, which is also growing, so this parameter limits\n        the maximum number of iterations.  The default is 10, but 5 is usally\n        enough.\n\n    Returns\n    -------\n    D : NumPy ndarray\n        Array containing pore diameter values.\n\n    Notes\n    -----\n    This model looks into all pores in the network when finding the diameter.\n    This means that when multiple Geometry objects are defined, it will\n    consider the diameter of pores on adjacent Geometries. If no diameters\n    have been assigned to these neighboring pores it will assume 0.  If\n    diameter value are assigned to the neighboring pores AFTER this model is\n    run, the pores will overlap.  This can be remedied by running this model\n    again.\n\n    \"\"\"\nnetwork = target.project.network\nP12 = network['throat.conns']\nC1 = network['pore.coords'][network['throat.conns'][:, (0)]]\nC2 = network['pore.coords'][network['throat.conns'][:, (1)]]\nL = _np.sqrt(_np.sum((C1 - C2) ** 2, axis=1))\ntry:\n    D = network[fixed_diameter]\n    D[_np.isnan(D)] = 0\nexcept KeyError:\n    _logger.info('Pore sizes not present, calculating starting values ' +\n        'as half-way to the nearest neighbor')\n    D = _np.inf * _np.ones([network.Np], dtype=float)\n    _np.minimum.at(D, P12[:, (0)], L)\n    _np.minimum.at(D, P12[:, (1)], L)\nwhile iters >= 0:\n    iters -= 1\n    Lt = L - _np.sum(D[P12], axis=1) / 2\n    Dadd = _np.ones_like(D) * _np.inf\n    _np.minimum.at(Dadd, P12[:, (0)], Lt)\n    _np.minimum.at(Dadd, P12[:, (1)], Lt)\n    D += Dadd\nif _np.any(D < 0):\n    _logger.info('Negative pore diameters found!  Neighboring pores are ' +\n        'larger than the pore spacing.')\nreturn D[network.pores(target.name)]\n"
}
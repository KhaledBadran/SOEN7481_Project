{
    "functionName": "merge_pores",
    "className": null,
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_topotools_&_topotools.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n    Combines a selection of pores into a new single pore located at the\n    centroid of the selected pores and connected to all of their neighbors.\n\n    Parameters\n    ----------\n    network : OpenPNM Network Object\n\n    pores : array_like\n        The list of pores which are to be combined into a new single pore\n\n    labels : string or list of strings\n        The labels to apply to the new pore and new throat connections\n\n    Notes\n    -----\n    (1) The method also works if a list of lists is passed, in which case\n    it consecutively merges the given selections of pores.\n\n    (2) The selection of pores should be chosen carefully, preferrable so that\n    they all form a continuous cluster.  For instance, it is recommended\n    to use the ``find_nearby_pores`` method to find all pores within a\n    certain distance of a given pore, and these can then be merged without\n    causing any abnormal connections.\n\n    Examples\n    --------\n    >>> import openpnm as op\n    >>> pn = op.network.Cubic(shape=[20, 20, 1])\n    >>> Ps = pn.find_nearby_pores(pores=111, r=5, flatten=True)\n    >>> op.topotools.merge_pores(network=pn, pores=Ps, labels=['merged'])\n    >>> print(pn.Np)\n    321\n    >>> pn.pores('merged')\n    array([320])\n    >>> pn.num_throats('merged')\n    32\n\n    \"\"\"\ntry:\n    len(pores[0])\nexcept (TypeError, IndexError):\n    pores = [pores]\nN = len(pores)\nNBs, XYZs = [], []\nfor Ps in pores:\n    temp = network.find_neighbor_pores(pores=Ps, mode='union', flatten=True,\n        include_input=False)\n    NBs.append(temp)\n    points = np.concatenate((temp, Ps))\n    XYZs.append(hull_centroid(network['pore.coords'][points]))\nextend(network, pore_coords=XYZs, labels=labels)\nPnew = network.Ps[-N:]\npores_set = [set(items) for items in pores]\nNBs_set = [set(items) for items in NBs]\nps1, ps2 = [], []\nfrom itertools import combinations\nfor i, j in combinations(range(N), 2):\n    if not NBs_set[i].isdisjoint(pores_set[j]):\n        ps1.append([network.Ps[-N + i]])\n        ps2.append([network.Ps[-N + j]])\nconnect_pores(network, pores1=ps1, pores2=ps2, labels=labels)\nconnect_pores(network, pores2=np.split(Pnew, N), pores1=NBs, labels=labels)\ntrim(network=network, pores=np.concatenate(pores))\n"
}
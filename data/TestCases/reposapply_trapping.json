{
    "functionName": "apply_trapping",
    "className": "MixedInvasionPercolation",
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_algorithms_&_MixedInvasionPercolation.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n        Apply trapping based on algorithm described by Y. Masson [1].\n\n        Parameters\n        ----------\n        partial : boolean\n            Indicating whether partially filled network\n\n        Notes\n        -----\n        It is applied as a post-process and runs the percolation algorithm in\n        reverse assessing the occupancy of pore neighbors. 3 situations can\n        happen on invasion without trapping:\n\n        * The number of defending clusters stays the same and clusters can shrink\n        * A cluster of size one is suppressed\n        * A cluster is split into multiple clusters\n\n        In reverse the following situations can happen:\n\n        * The number of defending clusters stays the same and clusters can grow\n        * A cluster of size one is created\n        * Mutliple clusters merge into one cluster\n\n        With trapping the reversed rules are adjusted so that:\n\n        * Only clusters that do not connect to a sink can grow and merge.\n        * At the point that a neighbor connected to a sink is touched, the\n        trapped cluster stops growing as this is the point of trapping in\n        forward invasion time.\n\n        Logger info displays the invasion Sequence and pore index and a message\n        with condition number based on the modified trapping rules and the\n        assignment of the pore to a given cluster.\n\n        Initially all invaded pores are given cluster label -1\n        Outlets / Sinks are given -2\n\n        New clusters that grow into fully trapped clusters are either\n        identified at the point of breakthrough or grow from nothing if the\n        full invasion sequence is run, they are assigned numbers from 0 up.\n\n        References\n        ----------\n        [1] Masson, Y., 2016. A fast two-step algorithm for invasion\n        percolation with trapping. Computers & Geosciences, 90, pp.41-48\n\n        Returns\n        -------\n        Creates a throat array called 'pore.clusters' in the Algorithm\n        dictionary. Any positive number is a trapped cluster. Also creates 2\n        boolean arrays Np and Nt long called '<element>.trapped'\n\n        \"\"\"\nnet = self.project.network\noutlets = self['pore.outlets']\nif np.sum(outlets) == 0:\n    raise Exception('Outlets must be set using the set_outlets method' +\n        ' before applying trapping')\nif partial:\n    invaded_ps = self['pore.invasion_sequence'] > -1\n    clusters = find_clusters(network=net, pmask=~invaded_ps)\n    out_clusters = np.unique(clusters[outlets])\n    for c in out_clusters:\n        if c >= 0:\n            clusters[clusters == c] = -2\nelse:\n    clusters = np.ones(net.Np, dtype=int) * -1\n    clusters[outlets] = -2\ninv_seq = np.vstack((self['pore.invasion_sequence'].astype(int), np.arange(\n    0, net.Np, dtype=int))).T\ninv_seq = inv_seq[inv_seq[:, (0)].argsort()][::-1]\nnext_cluster_num = np.max(clusters) + 1\nstopped_clusters = np.zeros(net.Np, dtype=bool)\nall_neighbors = net.find_neighbor_pores(net.pores(), flatten=False,\n    include_input=True)\nfor un_seq, pore in inv_seq:\n    if ~outlets[pore] and un_seq > -1:\n        nc = clusters[all_neighbors[pore]]\n        unique_ns = np.unique(nc[nc != -1])\n        seq_pore = 'S:' + str(un_seq) + ' P:' + str(pore)\n        if np.all(nc == -1):\n            clusters[pore] = next_cluster_num\n            next_cluster_num += 1\n            msg = seq_pore + ' C:1 new cluster number: ' + str(clusters[pore])\n            logger.info(msg)\n        elif len(unique_ns) == 1:\n            if not stopped_clusters[unique_ns[0]]:\n                clusters[pore] = unique_ns[0]\n                msg = seq_pore + ' C:2 joins cluster number: ' + str(clusters\n                    [pore])\n                logger.info(msg)\n            else:\n                clusters[pore] = -2\n        elif -2 in unique_ns:\n            msg = seq_pore + ' C:3 joins sink cluster'\n            logger.info(msg)\n            clusters[pore] = -2\n            stopped_clusters[unique_ns[unique_ns > -1]] = True\n        elif np.any(stopped_clusters[unique_ns]):\n            msg = seq_pore + ' C:4 joins sink cluster'\n            logger.info(msg)\n            clusters[pore] = -2\n            stopped_clusters[unique_ns] = True\n        else:\n            new_num = unique_ns[0]\n            clusters[pore] = new_num\n            for c in unique_ns:\n                clusters[clusters == c] = new_num\n                msg = seq_pore + ' C:5 merge clusters: ' + str(c\n                    ) + ' into ' + str(new_num)\n                logger.info(msg)\nclusters[outlets] = -2\nnum_trap = np.sum(np.unique(clusters) >= 0)\nif num_trap > 0:\n    logger.info('Number of trapped clusters ' + str(num_trap))\n    self['pore.trapped'] = clusters > -1\n    num_tPs = np.sum(self['pore.trapped'])\n    logger.info('Number of trapped pores: ' + str(num_tPs))\n    self['pore.invasion_sequence'][self['pore.trapped']] = -1\n    self['throat.trapped'] = np.zeros([net.Nt], dtype=bool)\n    for c in np.unique(clusters[clusters >= 0]):\n        c_ts = net.find_neighbor_throats(clusters == c, mode='xnor')\n        self['throat.trapped'][c_ts] = True\n    num_tTs = np.sum(self['throat.trapped'])\n    logger.info('Number of trapped throats: ' + str(num_tTs))\n    self['throat.invasion_sequence'][self['throat.trapped']] = -1\n    phase = self.project.find_phase(self)\n    phase['pore.occupancy'] = ~self['pore.trapped']\n    phase['throat.occupancy'] = ~self['throat.trapped']\nelse:\n    logger.info('No trapped clusters found')\n"
}
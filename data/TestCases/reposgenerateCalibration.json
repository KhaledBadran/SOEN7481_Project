{
    "functionName": "generateCalibration",
    "className": "Instrument",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Geometry_&_Instrument.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Method to generate look-up tables for normalization. Saves calibration file(s) as 'Calibration_Np.calib', where Np is the number of pixels.\n        \n        Generates 4 different tables:\n\n            - Prismatic High Definition (8 pixels/energy or 64 pixels/detector)\n\n            - Prismatic Low Definition (3 pixels/energy or 24 pixels/detector)\n\n            - Single (1 pixel/energy or 8 pixels/detector)\n\n            - Number (integer)\n        \n        Args:\n\n            - Vanadiumdatafile (string): String to single data file used for normalization, Vanadium Ei scan (required).\n\n        Kwargs:\n\n            - A4datafile (string): String to single data file used for normalization, AlO A4 scan (default False).\n\n            - savelocation (string): String to save location folder (calibration)\n\n            - tables (list): List of needed conversion tables (Default: ['Single','PrismaticLowDefinition','PrismaticHighDefinition'], increasing number of pixels).\n\n            - plot (boolean): Set to True if pictures of all fit are to be stored in savelocation\n\n            - mask (boolean): If True the lower 100 pixels are set to 0\n\n            - adaptiveBinning (boolean): If true pixel bins are asigned to give same Gaussian area of intensity for all pixels (default False)\n\n        .. warning::\n            At the moment, the active detector area is defined by NumberOfSigmas (currently 3) times the Gaussian width of Vanadium peaks.\n\n        \"\"\"\nself.initialize()\nwith hdf.File(Vanadiumdatafile, 'r') as VanFile:\n    if not A4datafile == False:\n        A4File = hdf.File(A4datafile, 'r')\n        A4FileInstrument = getInstrument(A4File)\n        A4FileInstrumentType = A4FileInstrument.name.split('/')[-1]\n    VanFileInstrument = getInstrument(VanFile)\n    VanFileInstrumentType = VanFileInstrument.name.split('/')[-1]\n    if not A4datafile == False:\n        if VanFileInstrumentType == A4FileInstrumentType:\n            InstrumentType = VanFileInstrumentType\n        else:\n            raise AttributeError(\n                'The provided Vanadium and Powder files does not have the same instrument type ({} and {} respectively).'\n                .format(VanFileInstrumentType, A4FileInstrumentType))\n    InstrumentType = VanFileInstrumentType\n    if InstrumentType == 'CAMEA':\n        if savelocation[-1] != '/':\n            savelocation += '/'\n        Data = np.array(VanFileInstrument.get('detector/counts')).transpose(\n            2, 0, 1).astype(float)\n        if False:\n            Data[:, :, :100] = 0\n        Ei = np.array(VanFileInstrument.get('monochromator/energy')).astype(\n            float)\n        analysers = 8\n        pixels = self.wedges[0].detectors[0].pixels\n        detectors = len(self.A4[0]) * len(self.A4)\n        detectorsorInWedge = len(self.A4[0])\n        wedges = len(self.A4)\n        if pixels != Data.shape[2]:\n            raise ValueError(\n                'The number of pixels ({}) in the data file does not match instrument description ({})!'\n                .format(pixels, Data.shape[2]))\n        bins = []\n        for table in tables:\n            if isinstance(table, int):\n                bins.append(table)\n            else:\n                raise AttributeError(\n                    'Provided table attribute ({}) not recognized an integer.'\n                    .format(table))\n        if len(bins) == 0:\n            raise AttributeError(\n                'No binning has been chosen for normalization routine.')\n        peakPos = np.ones((detectors, analysers), dtype=float) * -1\n        peakVal = np.zeros_like(peakPos, dtype=float)\n        peakWidth = np.ones_like(peakPos, dtype=float)\n        peakBackg = np.zeros_like(peakPos, dtype=float)\n        ESummedData = Data.sum(axis=1)\n        dataSubtracted = np.array(ESummedData.copy(), dtype=float)\n        if plot:\n            plt.ioff()\n            plt.figure(figsize=(16, 11))\n            if not os.path.exists(savelocation + 'Raw'):\n                os.makedirs(savelocation + 'Raw')\n            for i in range(detectors):\n                plt.clf()\n                plt.scatter(np.arange(pixels), np.sum(Data[:][i], axis=0), s=5)\n                plt.ylim(0, np.max(np.sum(Data[i], axis=0)) * 1.1)\n                plt.xlabel('Pixel')\n                plt.ylabel('Intensity [arg]')\n                plt.title('Vanadium normalization detector ' + str(i))\n                plt.tight_layout()\n                plt.savefig(savelocation + 'Raw/detector' + str(i) + '.png',\n                    format='png', dpi=150)\n        for j in range(analysers):\n            peakPos[:, (j)], peakVal[:, (j)] = findPeak(dataSubtracted)\n            for i in range(detectors):\n                guess = [peakVal[i, j], float(peakPos[i, j]), 20, np.min(\n                    ESummedData[i])]\n                try:\n                    res = scipy.optimize.curve_fit(Gaussian, np.arange(\n                        ESummedData.shape[1]), dataSubtracted[(i), :], p0=[\n                        guess])\n                except RuntimeError:\n                    raise RuntimeError(\n                        'Fitting did not converge at detector {} analyser {}'\n                        .format(i, j))\n                peakPos[i, j] = res[0][1]\n                peakVal[i, j] = res[0][0]\n                peakWidth[i, j] = res[0][2]\n                if peakPos[i, j] > ESummedData.shape[1]:\n                    raise ValueError(\n                        'Peak found at {} for analyser {} and detector {}'.\n                        format(peakPos[i, j], j, i))\n                x = np.arange(pixels)\n                y = Gaussian(x, peakVal[i, j], peakPos[i, j], peakWidth[i,\n                    j], peakBackg[i, j])\n                peak = y > peakVal[i, j] * 0.05\n                dataSubtracted[i, peak] = 0\n        if plot:\n            x = np.arange(pixels)\n            for k in range(wedges):\n                plt.clf()\n                plt.suptitle('Fits')\n                for i in range(detectorsorInWedge):\n                    y = np.zeros_like(x, dtype=float)\n                    plt.subplot(4, 4, i + 1)\n                    plt.scatter(np.arange(pixels), ESummedData[i + 13 * k], s=4\n                        )\n                    for j in range(analysers):\n                        y += Gaussian(x, peakVal[i + 13 * k, j], peakPos[i +\n                            13 * k, j], peakWidth[i + 13 * k, j], peakBackg\n                            [i + 13 * k, j])\n                        plt.plot([peakPos[i + 13 * k, j], peakPos[i + 13 *\n                            k, j]], [0, np.max(ESummedData[i + 13 * k]) * 1.1])\n                    plt.plot(x, y, 'k')\n                    plt.xlabel('Pixel')\n                    plt.ylabel('Intensity [arg]')\n                    plt.title('Detector {}'.format(i + 13 * k))\n                    plt.ylim(0, np.max(ESummedData[i + 13 * k]) * 1.1)\n                plt.tight_layout()\n                plt.savefig(savelocation + '/Raw/Fit_wedge_' + str(k) +\n                    '.png', format='png', dpi=150)\n                print('Saving: {}'.format(savelocation + '/Raw/Fit_wedge_' +\n                    str(k) + '.png'))\n        sortedPeakPosArg = np.argsort(peakPos, axis=1)\n        sortedPeakPos = np.sort(peakPos, axis=1)\n        sortedPeakPos[np.logical_or(sortedPeakPos > pixels, sortedPeakPos < 0)\n            ] = 5 * pixels\n        sortedPeakPosArg2 = np.argsort(sortedPeakPos, axis=1)\n        sortedPeakPos.sort(axis=1)\n        sortedPeakPosArg3 = np.argsort(sortedPeakPos, axis=1)\n        argSort = np.array([sortedPeakPosArg[i, sortedPeakPosArg2[i,\n            sortedPeakPosArg3[(i), :]]] for i in range(detectors)])\n        sortedPeakPos = np.sort(sortedPeakPos, axis=1)\n        peaks = np.sum(sortedPeakPos < 7 * pixels, axis=1)\n        if np.any(peaks != analysers):\n            raise ValueError(\n                \"\"\"Wrong number of peaks, {} found in detector(s): {}\nIn total error in {} detector(s).\"\"\"\n                .format(peaks[peaks != analysers], np.arange(peaks.shape[0]\n                )[peaks != analysers], np.sum(peaks != analysers)))\n        pixelpos = np.array([peakPos[i, argSort[i]] for i in range(detectors)])\n        widths = np.array([peakWidth[i, argSort[i]] for i in range(detectors)])\n        sigmas = NumberOfSigmas\n        lowerPixel = pixelpos - sigmas * widths\n        upperPixel = pixelpos + sigmas * widths\n        split = (lowerPixel[:, 1:] - upperPixel[:, :-1]) / 2 + upperPixel[:,\n            :-1]\n        extendedSplit = np.zeros((split.shape[0], split.shape[1] + 2))\n        extendedSplit[:, 1:-1] = split\n        extendedSplit[:, (-1)] = np.ones(split.shape[0]) * pixels\n        x = np.arange(pixels)\n        activePixels = np.zeros((detectors, analysers, pixels), dtype=bool)\n        for i in range(detectors):\n            if plot:\n                plt.clf()\n                plt.title('Detector {} Active pixels'.format(i))\n                plt.scatter(x, ESummedData[i], s=4, color='black')\n            for j in range(analysers):\n                activePixels[i, j] = np.logical_and(x > lowerPixel[i, j], x <\n                    upperPixel[i, j])\n                if plot:\n                    plt.scatter(x[np.logical_and(x > lowerPixel[i, j], x <\n                        upperPixel[i, j])], ESummedData[i, np.logical_and(x >\n                        lowerPixel[i, j], x < upperPixel[i, j])], s=4,\n                        color='red')\n            if plot:\n                plt.ylim(0, np.max(ESummedData[i]) * 1.1)\n                plt.xlabel('Pixel')\n                plt.ylabel('Intensity [arg]')\n                plt.savefig(savelocation + '/Raw/Active_' + str(i) + '.png',\n                    format='png', dpi=150)\n        Eguess = np.zeros_like(peakPos, dtype=int)\n        for i in range(Eguess.shape[0]):\n            for j in range(analysers):\n                Eguess[i, j] = np.argmax(Data[(i), :, (int(pixelpos[i, j]))])\n        fitParameters = []\n        activePixelRanges = []\n        for detpixels in bins:\n            if detpixels * analysers * 3 > len(Ei):\n                warnings.warn(\n                    'Fitting might be unstable due to {} pixels being fitted using only {} energies ({} free parameters).'\n                    .format(detpixels, len(Ei), detpixels * analysers * 3),\n                    category=RuntimeWarning, stacklevel=2)\n            if plot:\n                EiX = np.linspace(Ei[0], Ei[-1], len(Ei))\n                if not os.path.exists(savelocation + '/{}_pixels'.format(\n                    detpixels)):\n                    os.makedirs(savelocation + '/{}_pixels'.format(detpixels))\n                colors = np.zeros((3, detpixels))\n                if pixels == 1:\n                    colors[:, (0)] = [0.65, 0.2, 0.45]\n                else:\n                    colors[0] = np.linspace(0.3, 1.0, detpixels)\n                    colors[1] = np.linspace(0.2, 0.2, detpixels)\n                    colors[2] = np.linspace(0.8, 0.1, detpixels)\n                plt.suptitle('{} pixels'.format(detpixels))\n            fittedParameters = np.zeros((detectors, analysers, detpixels, 4))\n            activePixelDetector = []\n            for i in range(detectors):\n                activePixelAnalyser = []\n                if plot:\n                    plt.clf()\n                    plt.title('Detector {}, {} pixels'.format(i, detpixels))\n                    x = np.linspace(0, detpixels, len(Ei))\n                for j in range(analysers):\n                    center = int(round(sortedPeakPos[i, j]))\n                    width = activePixels[i, j].sum()\n                    if adaptiveBinning:\n                        binStart, binEnd = [center - width / 2.0, center + \n                            width / 2.0]\n                        binMid = center\n                        binWidth = (binEnd - binStart) / (2.0 * NumberOfSigmas)\n                        totalArea = norm.cdf(NumberOfSigmas) - norm.cdf(-\n                            NumberOfSigmas)\n                        areaOutside = norm.cdf(-NumberOfSigmas)\n                        areaPerBin = totalArea / detpixels\n                        areaLeftOfBin = [(areaOutside + n * areaPerBin) for\n                            n in range(detpixels + 1)]\n                        pixelAreas = np.round(norm.ppf(areaLeftOfBin) *\n                            binWidth + binMid).astype(int)\n                    else:\n                        pixelAreas = np.linspace(-width / 2.0, width / 2.0,\n                            detpixels + 1, dtype=int) + center + 1\n                    for k in range(detpixels):\n                        binPixelData = Data[(i), :, pixelAreas[k]:\n                            pixelAreas[k + 1]].sum(axis=1)\n                        ECenter = Ei[np.argmax(binPixelData)]\n                        ECutLow = ECenter - 0.4\n                        ECutHigh = ECenter + 0.4\n                        TopId = np.argmin(np.abs(Ei - ECutHigh))\n                        BotId = np.argmin(np.abs(ECutLow - Ei))\n                        if TopId < BotId:\n                            _ = TopId\n                            TopId = BotId\n                            BotId = _\n                        binPixelData = binPixelData[BotId:TopId]\n                        EiLocal = Ei[BotId:TopId]\n                        Bg = np.min(binPixelData[[0, -1]])\n                        guess = np.array([np.max(binPixelData), ECenter, \n                            0.005, Bg], dtype=float)\n                        try:\n                            res = scipy.optimize.curve_fit(Gaussian,\n                                EiLocal, binPixelData.astype(float), p0=guess)\n                        except:\n                            if not os.path.exists(savelocation +\n                                '/{}_pixels'.format(detpixels)):\n                                os.makedirs(savelocation + '/{}_pixels'.\n                                    format(detpixels))\n                            if not plot:\n                                plt.ioff\n                            plt.figure()\n                            plt.scatter(EiLocal, binPixelData)\n                            plt.plot(Ei, Gaussian(Ei, *guess))\n                            plt.savefig(savelocation +\n                                '/{}_pixels/Detector{}_{}.png'.format(\n                                detpixels, i, k), format='png', dpi=150)\n                            plt.close()\n                        fittedParameters[i, j, k] = res[0]\n                        fittedParameters[i, j, k, 0] *= np.sqrt(2 * np.pi\n                            ) * fittedParameters[i, j, k, 2]\n                        if plot:\n                            plt.plot(EiX, GaussianNormalized(EiX, *\n                                fittedParameters[i, j, k]), color='black')\n                            plt.scatter(EiLocal, binPixelData, color=colors\n                                [:, (k)])\n                    activePixelAnalyser.append(np.linspace(-width / 2.0, \n                        width / 2.0, detpixels + 1, dtype=int) + center + 1)\n                activePixelDetector.append(activePixelAnalyser)\n                if plot:\n                    plt.grid('on')\n                    plt.xlabel('Ei [meV]')\n                    plt.ylabel('Weight [arb]')\n                    plt.tight_layout(rect=(0, 0, 1, 0.95))\n                    plt.savefig(savelocation + '/{}_pixels/Detector{}.png'.\n                        format(detpixels, i), format='png', dpi=150)\n                    print('Saving: {}'.format(savelocation +\n                        '/{}_pixels/Detector{}.png'.format(detpixels, i)))\n            if not A4datafile is False:\n                A4FileValue = np.array(A4FileInstrument.get(\n                    'detector/polar_angle'))\n                EiFile = np.array(A4FileInstrument.get('monochromator/energy')\n                    )[0]\n                A4FileIntensity = np.array(A4FileInstrument.get(\n                    'detector/data'))\n                factorsqrtEK = 0.694692\n                ki = np.sqrt(EiFile) * factorsqrtEK\n                Qvec = 1.8049\n                theta = np.arcsin(Qvec / (2 * ki))\n                A4 = np.array(self.A4)\n                A4 = A4.reshape(A4.shape[0] * A4.shape[1], A4.shape[2],\n                    order='C')\n                EPrDetector = len(self.wedges[0].detectors[0].split) + 1\n                pixelList = np.array(activePixelDetector).reshape(A4.shape[\n                    0], EPrDetector, detpixels + 1).astype(int)\n                PixelEdge = np.array([[pixelList[:, :, (i)], pixelList[:, :,\n                    (i + 1)]] for i in range(detpixels)]).transpose((2, 3, \n                    0, 1))\n                PixelEnergy = fittedParameters[:, :, :, (1)].reshape(A4.\n                    shape[0], EPrDetector * detpixels)\n                SoftwarePixel = np.array([np.argmin(np.abs(x - EiFile)) for\n                    x in PixelEnergy])\n                MeanA4Instr = np.zeros((A4.shape[0], EPrDetector * detpixels))\n                MeanIntensity = np.zeros((len(A4FileValue), A4.shape[0], \n                    EPrDetector * detpixels))\n                for i in range(A4.shape[0]):\n                    for j in range(EPrDetector):\n                        for k in range(detpixels):\n                            MeanIntensity[:, (i), (j * detpixels + k)\n                                ] = np.sum(A4FileIntensity[:, (i),\n                                PixelEdge[i, j, k, 0]:PixelEdge[i, j, k, 1]\n                                ], axis=1)\n                            MeanA4Instr[i, j * detpixels + k] = np.mean(A4[\n                                (i), PixelEdge[i, j, k, 0]:PixelEdge[i, j,\n                                k, 1]])\n                x = A4FileValue\n                A4FitValue = np.zeros(A4.shape[0])\n                if plot == True:\n                    plt.clf()\n                for i in range(104):\n                    y = MeanIntensity[:, (i), (SoftwarePixel[i])]\n                    if plot == True:\n                        plt.scatter(x, y)\n                    guess = [np.max(y), x[np.argmax(y)], 3, 0]\n                    try:\n                        fit = scipy.optimize.curve_fit(Gaussian, x, y, p0=[\n                            guess])\n                    except:\n                        A4FitValue[i] = guess[1]\n                    else:\n                        A4FitValue[i] = fit[0][1]\n                if plot == True:\n                    if not os.path.exists(savelocation + 'A4'):\n                        os.makedirs(savelocation + 'A4')\n                    plt.savefig(savelocation + 'A4' + '/A4_{}.png'.format(\n                        detpixels), format='png', dpi=150)\n                A4FitValue += 2 * theta * 180.0 / np.pi\n                if plot == True:\n                    plt.clf()\n                    plt.scatter(range(A4.shape[0]), A4FitValue)\n                    plt.scatter(range(A4.shape[0]), MeanA4Instr[:, (int(np.\n                        round(np.mean(SoftwarePixel))))] * 180.0 / np.pi)\n                    plt.legend(['File', 'Geometry'])\n                    plt.savefig(savelocation + 'A4' + '/Points_{}.png'.\n                        format(detpixels), format='png', dpi=150)\n                    diff = A4FitValue - MeanA4Instr[:, (int(np.round(np.\n                        mean(SoftwarePixel))))] * 180.0 / np.pi\n                    plt.clf()\n                    plt.scatter(range(A4.shape[0]), diff)\n                    plt.savefig(savelocation + 'A4' + '/diff_{}.png'.format\n                        (detpixels), format='png', dpi=150)\n            else:\n                A4 = np.array(self.A4).reshape(104, 1024)\n                A4Pixel = []\n                for i in range(len(fittedParameters)):\n                    for j in range(len(fittedParameters[i])):\n                        for k in range(len(fittedParameters[i][j])):\n                            A4Pixel.append(np.mean(A4[(i),\n                                activePixelDetector[i][j][k]:\n                                activePixelDetector[i][j][k + 1]]))\n                A4Pixel = np.array(A4Pixel).reshape(len(fittedParameters),\n                    len(fittedParameters[i]), len(fittedParameters[i][j]))\n                A4FitValue = np.rad2deg(A4Pixel)\n            fitParameters.append(fittedParameters)\n            activePixelRanges.append(np.array(activePixelDetector))\n            tableString = (\n                \"\"\"Normalization for {} pixel(s) using VanData {} and A4Data{}\nPerformed {}\nDetector,Energy,Pixel,IntegratedIntensity,Center,Width,Background,lowerBin,upperBin,A4Offset\n\"\"\"\n                .format(detpixels, Vanadiumdatafile, A4datafile, datetime.\n                datetime.now()))\n            for i in range(len(fittedParameters)):\n                for j in range(len(fittedParameters[i])):\n                    for k in range(len(fittedParameters[i][j])):\n                        tableString += str(i) + ',' + str(j) + ',' + str(k\n                            ) + ',' + ','.join([str(x) for x in\n                            fittedParameters[i][j][k]])\n                        tableString += ',' + str(activePixelRanges[-1][i][j][k]\n                            ) + ',' + str(activePixelRanges[-1][i][j][k + 1])\n                        tableString += ',' + str(A4FitValue[i, j, k]) + '\\n'\n            tableName = 'Normalization_{}.calib'.format(detpixels)\n            print('Saving {} pixel data to {}'.format(detpixels, \n                savelocation + tableName))\n            file = open(savelocation + tableName, mode='w')\n            file.write(tableString)\n            file.close()\n    if not A4datafile is False:\n        A4File.close()\n_tools.KwargChecker()"
}
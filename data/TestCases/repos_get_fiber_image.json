{
    "functionName": "_get_fiber_image",
    "className": "DelaunayGeometry",
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_materials_&_VoronoiFibers.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n        Produce image by filling in voxels along throat edges using Bresenham\n        line then performing distance transform on fiber voxels to erode the\n        pore space\n        \"\"\"\nfiber_rad = self.network.fiber_rad\nvox_len = self.network.resolution\nfiber_rad = np.around((fiber_rad - vox_len / 2) / vox_len, 0).astype(int)\nverts = self['throat.vertices']\n[vxmin, vxmax, vymin, vymax, vzmin, vzmax] = self.vertex_dimension(face1=\n    self.pores(), parm='minmax')\nfor index in range(len(verts)):\n    verts[index] -= np.array([vxmin, vymin, vzmin])\ncdomain = np.around(np.array([vxmax - vxmin, vymax - vymin, vzmax - vzmin]), 6)\nlogger.info('Creating fibers in range: ' + str(np.around(cdomain, 5)))\nlx = np.int(np.around(cdomain[0] / vox_len) + 1)\nly = np.int(np.around(cdomain[1] / vox_len) + 1)\nlz = np.int(np.around(cdomain[2] / vox_len) + 1)\nlogger.info('Voxels: ' + str(lx) + ' ' + str(ly) + ' ' + str(lz))\ntry:\n    pore_space = np.ones([lx, ly, lz], dtype=np.uint8)\n    fiber_space = np.zeros(shape=[lx, ly, lz], dtype=np.uint8)\n    dt = np.zeros([lx, ly, lz], dtype=float)\n    cx = cy = cz = 1\n    chunk_len = np.max(np.shape(pore_space))\nexcept Exception:\n    logger.info('Domain too large to fit into memory so chunking ' +\n        'domain to process image, this may take some time')\n    chunk_len = 100\n    if lx > chunk_len:\n        cx = np.ceil(lx / chunk_len).astype(int)\n    else:\n        cx = 1\n    if ly > chunk_len:\n        cy = np.ceil(ly / chunk_len).astype(int)\n    else:\n        cy = 1\n    if lz > chunk_len:\n        cz = np.ceil(lz / chunk_len).astype(int)\n    else:\n        cz = 1\nline_points = self._bresenham(verts, vox_len / 2)\nline_ints = np.around(line_points / vox_len, 0).astype(int)\nfor x, y, z in line_ints:\n    try:\n        pore_space[x][y][z] = 0\n    except IndexError:\n        logger.warning('Some elements in image processing are out' +\n            'of bounds')\nnum_chunks = np.int(cx * cy * cz)\ncnum = 1\nfor ci in range(cx):\n    for cj in range(cy):\n        for ck in range(cz):\n            logger.info('Processing fiber Chunk: ' + str(cnum) + ' of ' +\n                str(num_chunks))\n            cxmin = ci * chunk_len\n            cxmax = np.int(np.ceil((ci + 1) * chunk_len + 5 * fiber_rad))\n            cymin = cj * chunk_len\n            cymax = np.int(np.ceil((cj + 1) * chunk_len + 5 * fiber_rad))\n            czmin = ck * chunk_len\n            czmax = np.int(np.ceil((ck + 1) * chunk_len + 5 * fiber_rad))\n            if cxmax > lx:\n                cxmax = lx\n            if cymax > ly:\n                cymax = ly\n            if czmax > lz:\n                czmax = lz\n            dt_edt = ndimage.distance_transform_edt\n            dtc = dt_edt(pore_space[cxmin:cxmax, cymin:cymax, czmin:czmax])\n            fiber_space[cxmin:cxmax, cymin:cymax, czmin:czmax][dtc <= fiber_rad\n                ] = 0\n            fiber_space[cxmin:cxmax, cymin:cymax, czmin:czmax][dtc > fiber_rad\n                ] = 1\n            dt[cxmin:cxmax, cymin:cymax, czmin:czmax] = dtc - fiber_rad\n            cnum += 1\ndel pore_space\nself._fiber_image = fiber_space\ndt[dt < 0] = 0\nself._dt_image = dt\n"
}
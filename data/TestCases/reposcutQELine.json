{
    "functionName": "cutQELine",
    "className": "DataSet",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n        Method to perform Q-energy cuts from a variable number of points. The function takes both qx/qy or hkl positions. In the case of using only two Q points,\n        the method is equivalent to cutQE.\n        \n        Args:\n            \n            - QPoints (list of points): Q positions between which cuts are performed. Can be specified with both qx, qy or hkl positions dependent on the choice of format.\n            \n            - EnergyBins (list of floats): Energy bins for which the cuts are performed\n            \n        Kwargs:\n        \n            - width (float): Width of the cut in 1/AA (default 0.1).\n            \n            - minPixel (float): Minimal size of binning along the cutting directions. Points will be binned if they arecloser than minPixel (default=0.01)\n        \n            - rlu (bool): If True, provided QPoints are interpreted as (h,k,l) otherwise as (qx,qy), (default True).\n        \n            - dataFiles (list): List of dataFiles to cut. If none, the ones in the object will be used (default None).\n\n            - constantBins (bool): If True only bins of size minPixel is used (default False)\n        \n        .. warning::\n            The way the binning works is by extending the end points with 0.5*minPixel, but the method sorts away points not between the two Q points given and thus the start and end\n            bins are only half filled. This might result in discrepancies between a single cut and the same cut split into different steps. Further, splitting lines into sub-cuts \n            forces a new binning to be done and the bin positions can then differ from the case where only one cut is performed.\n\n        \n        Returns: m = Q points, n = energy bins\n                \n            - Data list (pandas DataFrame): DataFrame containing qx,qy,H,K,L,Intensity,Normalization,Monitor,BinCount,Int,binDistance for all 2D cuts.\n            \n            - Bin list (m * n * 3 arrays): n instances of bin edge positions in plane of size (m+1,3), orthogonal positions of bin edges in plane of size (2,2), and energy edges of size (2).\n            \n            - center position (m * n * 3D arrays): n instances of center positions for the bins.\n\n            - binDistance (m * n arrays): n instances of arrays holding the distance in q to q1.\n\n        .. note::\n            If an HKL point outside of the scattering plane is given, the program will just take the projection onto the scattering plane.\n            \n        \"\"\"\nif not isinstance(QPoints, np.ndarray):\n    QPoints = np.array(QPoints)\nif len(QPoints) < 2:\n    raise AttributeError('Number of Q points given is less than 2.')\nif rlu == True:\n    pass\nelif rlu == False:\n    if QPoints.shape[1] != 2:\n        raise AttributeError(\n            'Provide Q list is not 2 dimensional, should have shape (n,2) in QxQy mode but got shape {}.'\n            .format(QPoints.shape))\nelse:\n    raise AttributeError(\n        'Given Q mode not understood. Got {} but must be either \"RLU\", \"HKL\" or \"QxQy\"'\n        )\nif EnergyBins.shape == ():\n    EnergyBins = np.array([EnergyBins])\nif len(EnergyBins.shape) == 1 and not isinstance(EnergyBins[0], (list, np.\n    ndarray)):\n    EnergyBins = np.array([EnergyBins for _ in range(len(QPoints) - 1)]\n        ).reshape(len(QPoints) - 1, -1)\nif not isinstance(width, (list, np.ndarray)):\n    width = np.array([width for _ in range(len(QPoints) - 1)]).reshape(len(\n        QPoints) - 1)\nif not isinstance(minPixel, (list, np.ndarray)):\n    minPixel = np.array([minPixel for _ in range(len(QPoints) - 1)]).reshape(\n        len(QPoints) - 1)\nDataList = []\nBinList = []\ncenterPosition = []\nbinDistance = []\nfor cutIndex, [pStart, pStop, w, mP, EB] in enumerate(zip(QPoints, QPoints[\n    1:], width, minPixel, EnergyBins)):\n    _DataList, _BinList, _centerPosition, _binDistance = self.cutQE(q1=\n        pStart, q2=pStop, width=w, minPixel=mP, EnergyBins=EB, rlu=rlu,\n        dataFiles=dataFiles, extend=False, constantBins=constantBins)\n    _DataList['qCut'] = cutIndex\n    DataList.append(_DataList)\n    if rlu:\n        UB2D = self.sample[0].convertHKLINV\n        _BinListUpdated = []\n        _centerPositionUpdated = []\n        for i, [Position, ortho, E] in enumerate(_BinList):\n            pos = np.array([np.concatenate([np.dot(UB2D, x[:2]), [x[2]]],\n                axis=0) for x in Position])\n            orthogonal = [np.dot(UB2D, x) for x in ortho]\n            _BinListUpdated.append([pos, orthogonal, E])\n            cPos = np.array([np.concatenate([np.dot(UB2D, x[:2]), [x[2]]],\n                axis=0) for x in _centerPosition[i]])\n            _centerPositionUpdated.append(cPos)\n        _BinList = _BinListUpdated\n        _centerPosition = _centerPositionUpdated\n    BinList.append(_BinList)\n    centerPosition.append(_centerPosition)\n    binDistance.append(_binDistance)\nDataList = pd.concat(DataList)\nreturn DataList, np.array(BinList, dtype=object), np.array(centerPosition,\n    dtype=object), np.array(binDistance, dtype=object)\n_tools.KwargChecker()"
}
{
    "functionName": "cut1D",
    "className": null,
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Perform 1D cut through constant energy plane from q1 to q2 returning binned intensity, monitor, normalization and normcount. The full width of the line is width while height is given by Emin and Emax. \n    the minimum step sizes is given by minPixel.\n    \n    .. note::\n        Can only perform cuts for a constant energy plane of definable width.\n    \n    Args:\n        \n        - positions (3 arrays): position in Qx, Qy, and E in flattend arrays.\n        \n        - I (array): Flatten intensity array\n        \n        - Norm (array): Flatten normalization array\n        \n        - Monitor (array): Flatten monitor array\n        \n        - q1 (2D array): Start position of cut in format (qx,qy).\n        \n        - q2 (2D array): End position of cut in format (qx,qy).\n        \n        - width (float): Full width of cut in q-plane.\n        \n        - minPixel (float): Minimal size of binning along the cutting direction. Points will be binned if they are closer than minPixel.\n        \n        - Emin (float): Minimal energy to include in cut.\n        \n        - Emax (float): Maximal energy to include in cut\n        \n    Kwargs:\n        \n        - plotCoverage (bool): If True, generates plot of all points in the cutting plane and adds bounding box of cut in new figure, if axis, plots on top (default False).\n\n        - extend (bool): Whether or not the cut from q1 to q2 is to be extended throughout the data (default true)\n\n        - constantBins (bool): If True only bins of size minPixel is used (default False)\n    \n    Returns:\n        \n        - Data list (4 arrays): Intensity, monitor count, normalization and normalization counts binned in the 1D cut.\n        \n        - Bin list (3 arrays): Bin edge positions in plane of size (n+1,3), orthogonal positions of bin edges in plane of size (2,2), and energy edges of size (2).\n        \n    \"\"\"\ndirvec = np.array(q2, dtype=float) - np.array(q1, dtype=float)\ndirLength = np.linalg.norm(dirvec)\ndirvec /= dirLength\northovec = np.array([dirvec[1], -dirvec[0]])\nProjectMatrix = np.array([dirvec, orthovec])\ninsideEnergy = np.logical_and(positions[2] <= Emax, positions[2] >= Emin)\nif np.sum(insideEnergy) == 0:\n    return [np.array(np.array([])), np.array([]), np.array([]), np.array([])\n        ], [np.array([]), np.array([]), [Emin, Emax]]\npositions2D = np.array([positions[0][insideEnergy], positions[1][insideEnergy]]\n    )\npropos = np.dot(ProjectMatrix, positions2D - q1.reshape(2, 1))\nif extend == False:\n    if constantBins == False:\n        insideQ = np.logical_and(propos[0] > -0.05, propos[0] < dirLength *\n            1.05)\n    else:\n        insideQ = np.logical_and(propos[0] > 0.0, propos[0] < dirLength)\n    propos = propos[:, (insideQ)]\northobins = [-width / 2.0, width / 2.0]\ninsideWidth = np.logical_and(propos[1] < orthobins[1], propos[1] > orthobins[0]\n    )\nif constantBins == False:\n    lenbins = np.array(_tools.binEdges(propos[0][insideWidth], minPixel,\n        startPoint=0.0, endPoint=dirLength))\nelse:\n    Min, Max = _tools.minMax(propos[0][insideWidth])\n    lenbins = np.arange(Min, Max + 0.5 * minPixel, minPixel)\northopos = np.outer(orthobins, orthovec)\nbinpositions = np.outer(lenbins, dirvec) + q1\nif len(lenbins) == 0:\n    return [np.array(np.array([])), np.array([]), np.array([]), np.array([])\n        ], [np.array([]), orthopos, [Emin, Emax]]\nnormcounts = np.histogramdd(propos.T, bins=[lenbins, orthobins], weights=np\n    .ones(propos.shape[1]).flatten())[0]\nif extend == False:\n    intensity = np.histogramdd(propos.T, bins=[lenbins, orthobins], weights\n        =I[insideEnergy][insideQ].flatten())[0]\n    MonitorCount = np.histogramdd(propos.T, bins=[lenbins, orthobins],\n        weights=Monitor[insideEnergy][insideQ].flatten())[0]\n    Normalization = np.histogramdd(propos.T, bins=[lenbins, orthobins],\n        weights=Norm[insideEnergy][insideQ].flatten())[0]\nelse:\n    intensity = np.histogramdd(propos.T, bins=[lenbins, orthobins], weights\n        =I[insideEnergy].flatten())[0]\n    MonitorCount = np.histogramdd(propos.T, bins=[lenbins, orthobins],\n        weights=Monitor[insideEnergy].flatten())[0]\n    Normalization = np.histogramdd(propos.T, bins=[lenbins, orthobins],\n        weights=Norm[insideEnergy].flatten())[0]\nEmeanVec = np.ones((len(binpositions), 1)) * (Emin + Emax) * 0.5\nbinpositionsTotal = np.concatenate((binpositions, EmeanVec), axis=1)\nif not plotCoverage is False:\n    if not isinstance(plotCoverage, bool):\n        ax = plotCoverage\n        plotPoints = False\n    else:\n        fig, ax = plt.subplots()\n        plotPoints = True\n        ax.scatter(positions2D[0], positions2D[1], s=0.5, zorder=100)\n    ax.plot([binpositions[0][0] + orthopos[0][0], binpositions[-1][0] +\n        orthopos[0][0]], [binpositions[0][1] + orthopos[0][1], binpositions\n        [-1][1] + orthopos[0][1]], c='w', zorder=100)\n    ax.plot([binpositions[0][0] + orthopos[1][0], binpositions[-1][0] +\n        orthopos[1][0]], [binpositions[0][1] + orthopos[1][1], binpositions\n        [-1][1] + orthopos[1][1]], c='w', zorder=100)\n    for i in [0, -1]:\n        ax.plot([binpositions[i][0] + orthopos[0][0], binpositions[i][0] +\n            orthopos[1][0]], [binpositions[i][1] + orthopos[0][1], \n            binpositions[i][1] + orthopos[1][1]], c='w', zorder=100)\n    for binPos in binpositions:\n        ax.plot([binPos[0] + orthopos[0][0], binPos[0] + orthopos[1][0]], [\n            binPos[1] + orthopos[0][1], binPos[1] + orthopos[1][1]], c='w',\n            linewidth=0.5, zorder=100)\n    if extend == False and plotPoints:\n        ax.scatter(positions2D[0][insideQ][insideWidth], positions2D[1][\n            insideQ][insideWidth], s=0.5, zorder=100)\n    elif plotPoints:\n        ax.scatter(positions2D[0][insideWidth], positions2D[1][insideWidth],\n            s=0.5, zorder=100)\n    if plotPoints:\n        ax.set_aspect('equal', 'datalim')\n        ax.set_xlabel('Qx [$\\\\AA^{-1}$]')\n        ax.set_ylabel('Qy [$\\\\AA^{-1}$]')\nreturn [intensity, MonitorCount, Normalization, normcounts], [binpositionsTotal\n    , orthopos, np.array([Emin, Emax])]\n_tools.KwargChecker()"
}
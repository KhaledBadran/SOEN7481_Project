{
    "functionName": "plotCutELine",
    "className": "DataSet",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_DataSet.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Perform cut along energy in steps between two Q Point \n        \n        Args:\n\n            - Q1 (3D or 2D vector): Starting point for energy cut.\n\n            - Q2 (3D or 2D vector): End of energy cut\n            \n\n        Kwargs: \n\n            - ax (matplotlib axis): Axis into which the plot is to go (default None, new created)\n\n            - Emin (float): Start energy (default is self.Energy.min() for data in cut).\n            \n            - Emax (float): End energy (default is self.Energy.max() for data in cut).\n\n            - energyWidth (float): Height of energy bins (default 0.05 meV)\n\n            - minPixel (float): Minimal size of binning along the cutting direction. Points will be binned if they are closer than minPixel (default 0.1).\n\n            - width (float): Full width of cut in q-plane (default 0.02).\n\n            - rlu (bool): If True, provided Q point is interpreted as (h,k,l) otherwise as (qx,qy), (Default true)\n            \n            - dataFiles (list): Data files to be used. If none provided use the ones in self (default None)\n\n            - constantBins (bool): If True only bins of size minPixel is used (default False)\n\n            - Vmin (float): Lower limit for colorbar (default min(Intensity)).\n            \n            - Vmax (float): Upper limit for colorbar (default max(Intensity)).\n            \n        Returns:\n            \n            - Data list (pandas DataFrame): DataFrame containing qx,qy,H,K,L,Intensity,Normalization,Monitor,BinCount,Int,binDistance for 1D cut.\n            \n            - Bin list (1 array): Bin edge positions in energy\n\n        \"\"\"\nData, Bins = self.cutELine(Q1=Q1, Q2=Q2, Emin=Emin, Emax=Emax, energyWidth=\n    energyWidth, minPixel=minPixel, width=width, rlu=rlu, dataFiles=\n    dataFiles, constantBins=constantBins)\nif Vmin is None:\n    Vmin = Data['Int'].min()\nif Vmax is None:\n    Vmax = Data['Int'].max()\ndirvec = np.asarray(Q2) - np.asarray(Q1)\nif np.sign(dirvec[np.argmax(np.abs(dirvec))]) == -1:\n    dirvec = -dirvec\nif rlu:\n    QPointColumns = ['H', 'K', 'L']\n    visualizationBinPosition = np.array([-1, 1]) * 0.5 * np.linalg.norm(self\n        .convertToQxQy(dirvec)) / (len(Bins) - 1)\nelse:\n    QPointColumns = ['Qx', 'Qy']\n    visualizationBinPosition = np.array([-1, 1]) * 0.5 * np.linalg.norm(dirvec\n        ) / (len(Bins) - 1)\nmeshs = []\nif ax is None:\n    if rlu:\n        ortho = np.cross(self.sample[0].planeNormal, dirvec)\n        ax = RLUAxes.createQEAxes(self, projectionVector1=dirvec,\n            projectionVector2=ortho)\n    else:\n        fig, ax = plt.subplots()\nelse:\n    fig, ax = plt.subplots()\ncolumns = QPointColumns + ['Int', 'QCut']\nfor (_, _data), _bins in zip(Data[columns].groupby('QCut'), Bins):\n    Q = np.array(_data[QPointColumns].iloc[0])\n    if rlu:\n        position = visualizationBinPosition + np.dot(Q, dirvec\n            ) / np.linalg.norm(dirvec)\n    else:\n        position = visualizationBinPosition + np.linalg.norm(Q)\n    x, y = np.meshgrid(position, _bins[0])\n    pmesh = ax.pcolormesh(x, y, _data['Int'].values.reshape(-1, 1))\n    meshs.append(pmesh)\nax.meshs = meshs\ndef set_clim(vmin, vmax, meshs):\n    for p in meshs:\n        p.set_clim(vmin, vmax)\nax.set_clim = lambda Vmin, Vmax: set_clim(Vmin, Vmax, ax.meshs)\nax.set_clim(Vmin, Vmax)\nreturn ax, Data, Bins\n"
}
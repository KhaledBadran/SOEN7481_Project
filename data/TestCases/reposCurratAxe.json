{
    "functionName": "CurratAxe",
    "className": "Sample",
    "fileName": "/jakob-lass_&_MJOLNIR/MJOLNIR_&_Data_&_Sample.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"Function to calculate Currat-Axe position in QxQy coordinate system.\n    \n        Args:\n            \n            - Ei (float/list): Incoming energy in meV.\n            \n            - Ef (float/list): Outgoing energy in meV.\n            \n            - Bragg (list): Bragg peak in HKL or list of.\n            \n        Kwargs:\n            \n            - spurionType (str): Either \"Monochromator\" or \"Analyser\" for origin of \"wrong\" energy (default \"Monochromator\").\n            \n            - HKL (bool): Whether or not to recalculate to HKL instead of Qx, Qy, Qz (default False).\n            \n            - Projection (Bool): Whether or not to recalculate to Projection vectors instead of Qx, Qy, Qz (default False).\n            \n        Returns:\n            \n            - Position (list): List of size (len(Bragg),len(Ei),len(Ef),3), where last axis is Qx, Qy, Qz\n            \n        \"\"\"\nA3Off = self.theta\nEi = np.asarray(Ei).flatten()\nEf = np.asarray(Ef).flatten()\nBragg = np.asarray(Bragg).reshape(-1, 3)\nQlLocal = []\nif spurionType.lower() == 'monochromator':\n    for B in Bragg:\n        Ql = []\n        Angles = np.array([TasUBlib.calcTasQAngles(self.orientationMatrix,\n            self.planeNormal, 1.0, A3Off, np.array([B[0], B[1], B[2], e, e]\n            ))[:2] for e in Ef])\n        for ei in Ei:\n            Ql.append(np.array([TasUBlib.calcTasQH(self.\n                orientationMatrixINV, angle, ei, e, 0) for angle, e in zip(\n                Angles, Ef)])[:, (1)])\n        QlLocal.append(Ql)\nelif spurionType.lower() == 'analyser':\n    for B in Bragg:\n        Ql = []\n        for ei in Ei:\n            Angles2 = np.array(TasUBlib.calcTasQAngles(self.\n                orientationMatrix, self.planeNormal, 1.0, A3Off, np.array([\n                B[0], B[1], B[2], ei, ei]))[:2])\n            Ql.append(np.array([TasUBlib.calcTasQH(self.\n                orientationMatrixINV, Angles2, ei, e, A3Off * 0.0) for e in\n                Ef])[:, (1)])\n        QlLocal.append(Ql)\nelse:\n    raise AttributeError(\n        'Provided spurionType not understood. Expected \"Monochromator\" or \"Analyser\" but recieved \"{}\".'\n        .format(spurionType))\nreturnVal = np.array(QlLocal)\nif HKL == True or Projection == True:\n    returnValShape = np.array(returnVal.shape)\n    returnVal = self.calculateQxQyToHKL(returnVal[:, :, :, (0)].flatten(),\n        returnVal[:, :, :, (1)].flatten())\n    if Projection == True:\n        toProjection = self.calculateHKLtoProjection(returnVal[0],\n            returnVal[1], returnVal[2])\n        returnVal = np.array(self.inv_tr(toProjection[0], toProjection[1]))\n        returnValShape[-1] = 2\n    returnVal.shape = returnValShape\nreturn returnVal\n_tools.KwargChecker()"
}
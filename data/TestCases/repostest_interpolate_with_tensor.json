{
    "functionName": "test_interpolate_with_tensor",
    "className": null,
    "fileName": "/mesonepigreco_&_CellConstructor/tests_&_TestInterpolateDynmat_&_test_interpolate_with_tensor.py",
    "projectName": "repos",
    "Label": false,
    "isTest": true,
    "Body": "total_path = os.path.dirname(os.path.abspath(__file__))\nos.chdir(total_path)\ndyn = CC.Phonons.Phonons(dyn_name, nqirr)\ninterp_dyn = dyn.Interpolate(dyn.GetSupercell(), target_cell)\ninterp_dyn.Symmetrize()\ninterp_dyn.save_qe('__trial__')\nnew_interp_dyn = CC.Phonons.Phonons('__trial__', interp_dyn.nqirr)\nt2 = CC.ForceTensor.Tensor2(dyn.structure, dyn.structure.generate_supercell\n    (dyn.GetSupercell()), dyn.GetSupercell())\nt2.SetupFromPhonons(dyn)\nprint('Check before the centering')\nfor iq, q in enumerate(dyn.q_tot):\n    fc_mat = np.conj(t2.Interpolate(q, asr=False))\n    dist = dyn.dynmats[iq] - fc_mat\n    dist = np.max(np.abs(dist))\n    _m_ = np.tile(dyn.structure.get_masses_array(), (3, 1)).T.ravel()\n    dynmat = fc_mat / np.sqrt(np.outer(_m_, _m_))\n    w2 = np.linalg.eigvalsh(dynmat)\n    w = np.sqrt(np.abs(w2)) * np.sign(w2)\n    w_old, _ = dyn.DyagDinQ(iq)\n    print('Q:', q)\n    print('\\n'.join(['{:3d}) {:10.4f} | {:10.4f} cm-1'.format(j, w[j] *\n        RY_TO_CM, w_old[j] * RY_TO_CM) for j in range(len(w))]))\n    print('DIST:', dist)\n    assert dist < __EPSILON__, 'Error, the q = {} is wrong.'.format(q)\nt2.Center()\nprint('Check after the centering')\nfor iq, q in enumerate(dyn.q_tot):\n    fc_mat = np.conj(t2.Interpolate(q, asr=False))\n    dist = dyn.dynmats[iq] - fc_mat\n    dist = np.max(np.abs(dist))\n    _m_ = np.tile(dyn.structure.get_masses_array(), (3, 1)).T.ravel()\n    dynmat = fc_mat / np.sqrt(np.outer(_m_, _m_))\n    w2 = np.linalg.eigvalsh(dynmat)\n    w = np.sqrt(np.abs(w2)) * np.sign(w2)\n    w_old, _ = dyn.DyagDinQ(iq)\n    print('Q:', q)\n    print('\\n'.join(['{:3d}) {:10.4f} | {:10.4f} cm-1'.format(j, w[j] *\n        RY_TO_CM, w_old[j] * RY_TO_CM) for j in range(len(w))]))\n    assert dist < __EPSILON__, 'Error, the q = {} is wrong.'.format(q)\nnew_dyn = t2.GeneratePhonons(target_cell)\nnew_dyn.save_qe('__trial2__')\nnew_dyn.Symmetrize()\nprint('Testing the interpolation...')\nfor iq, q in enumerate(interp_dyn.q_tot):\n    dist = interp_dyn.dynmats[iq] - new_dyn.dynmats[iq]\n    dist = np.max(np.abs(dist))\n    w, _ = new_dyn.DyagDinQ(iq)\n    w_old, _ = interp_dyn.DyagDinQ(iq)\n    print('{:3d}) Q:'.format(iq), q, 'Q NEW:', new_dyn.q_tot[iq])\n    print('\\n'.join(['{:3d}) {:10.4f} | {:10.4f} cm-1'.format(j, w[j] *\n        RY_TO_CM, w_old[j] * RY_TO_CM) for j in range(len(w))]))\n    assert dist < __EPSILON__, 'Error, the q = {} is wrong by {}.'.format(q,\n        dist)\nw_qe, _ = interp_dyn.DiagonalizeSupercell()\nw_fc, _ = new_dyn.DiagonalizeSupercell()\nprint('ALl modes:')\nprint('\\n'.join(['{:3d}) {:10.4f} | {:10.4f} cm-1'.format(j, w_fc[j] *\n    RY_TO_CM, w_qe[j] * RY_TO_CM) for j in range(len(w_qe))]))\nfor i in range(len(w_qe)):\n    minindex = np.argmin(np.abs(w_qe[i] - w_fc))\n    delta = np.abs(w_qe[i] - w_fc[minindex])\n    assert delta < __EPSILON__, 'Error, frequency {} of the original interpolation not found in the new dynamical matrix.'.format(\n        w_qe[i] * RY_TO_CM)\npytest.mark.parametrize('dyn_name, nqirr, target_cell', TEST_DYN)"
}
{
    "functionName": "_setup_coop_filling_bulge",
    "className": "MixedInvasionPercolationCoop",
    "fileName": "/pmeal_&_OpenPNM/openpnm_&_algorithms_&_MixedInvasionPercolationCoop.py",
    "projectName": "repos",
    "Label": false,
    "isTest": false,
    "Body": "\"\"\"\n        Evaluate the cooperative pore filling condition that the combined\n        filling angle in next neighbor throats cannot exceed the geometric\n        angle between their throat planes.\n        This is used when the invading fluid has access to multiple throats\n        connected to a pore\n\n        Parameters\n        ----------\n        inv_points : array_like\n            The invasion pressures at which to assess coopertive pore filling.\n        \"\"\"\nnet = self.project.network\nphase = self.project.find_phase(self)\nall_phys = self.project.find_physics(phase=phase)\nif inv_points is None:\n    inv_points = np.arange(0, 1.01, 0.01) * self._max_pressure()\nstart = time.time()\ncpf = self.settings['cooperative_pore_filling']\ntfill_angle = cpf + '.alpha'\ntmen_rad = cpf + '.radius'\ntmen_cen = cpf + '.center'\ntry:\n    p_centroids = net['pore.centroid']\n    t_centroids = net['throat.centroid']\n    p_rad = net['pore.indiameter'] / 2\n    t_norms = net['throat.normal']\nexcept KeyError:\n    p_centroids = net['pore.coords']\n    temp = net['pore.coords'][net['throat.conns']]\n    t_centroids = np.mean(temp, axis=1)\n    p_rad = net['pore.diameter'] / 2\n    t_norms = net['throat.normal']\nPs, Ts, T1, T2 = self._get_throat_pairs()\npps = Ps[T1]\npt1 = Ts[T1]\npt2 = Ts[T2]\nT_all_t1 = Ts[np.concatenate((T1, T2))]\ndata = np.ones(len(T_all_t1), dtype=float)\ndata.fill(np.nan)\npp_cen = p_centroids[pps]\npp_rad = p_rad[pps]\nunit = np.linalg.norm(t_norms, axis=1)\nt_norms /= np.vstack((unit, unit, unit)).T\nfor Pc in inv_points:\n    for phys in all_phys:\n        phys.models[cpf]['target_Pc'] = Pc\n        phys.regenerate_models(propnames=cpf)\n    men_cen_dist = phase[tmen_cen]\n    men_cen_coord = self._apply_cen_to_throats(p_centroids[Ps], t_centroids\n        [Ts], t_norms[Ts], men_cen_dist[Ts])\n    pc1 = men_cen_coord[T1]\n    pc2 = men_cen_coord[T2]\n    c2c = pc1 - pc2\n    dist = np.linalg.norm(c2c, axis=1)\n    pr1 = phase[tmen_rad][pt1]\n    pr2 = phase[tmen_rad][pt2]\n    pr1[np.isnan(pr1)] = 0\n    pr2[np.isnan(pr2)] = 0\n    check_neg = np.logical_and(pr1 < 0, pr2 < 0)\n    check_rads = np.abs(pr1 + pr2) >= dist\n    check_alpha_T1 = ~np.isnan(phase[tfill_angle][pt1])\n    check_alpha_T2 = ~np.isnan(phase[tfill_angle][pt2])\n    check_alpha = check_alpha_T1 * check_alpha_T2\n    check_nans = np.asarray(np.isnan(self.tt_Pc[pt1, pt2]).tolist()[0])\n    mask = check_neg * check_alpha * check_nans * check_rads\n    if np.any(mask):\n        inter = self.trilaterate_v(P1=pc1[mask], P2=pc2[mask], P3=pp_cen[\n            mask], r1=pr1[mask][:, (np.newaxis)], r2=pr2[mask][:, (np.\n            newaxis)], r3=pp_rad[mask][:, (np.newaxis)])\n        inter = inter.flatten()\n        if np.any(inter):\n            self.tt_Pc[pt1[mask][inter], pt2[mask][inter]] = Pc\n            self.tt_Pc[pt2[mask][inter], pt1[mask][inter]] = Pc\n    men_data = {}\n    men_data['Ps'] = Ps\n    men_data['Ts'] = Ts\n    men_data['cen'] = men_cen_coord\n    men_data['rad'] = phase[tmen_rad][Ts]\nself.tt_Pc = self.tt_Pc.tolil()\nlogger.info('Coop filling finished in ' + str(np.around(time.time() - start,\n    2)) + ' s')\n"
}